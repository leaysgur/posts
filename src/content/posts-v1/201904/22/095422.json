{
  "title": "WebRTCやるのに最低限必要なJavaScriptのAPIについて",
  "html": "\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2017/06/05/102203\">JavaScript&#x3067;WebRTC&#x3084;&#x308B;&#x305F;&#x3081;&#x306E;&#x57FA;&#x790E;&#x77E5;&#x8B58; - console.lealog();</a></p>\n\n    </blockquote>\n<p>春なので書きました。<br />\n言うなれば、これの2019年度版です。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>はじめに</h3>\n    <p>最低限の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>でWebRTCを扱うにあたり、どういうクラスがあって、どういう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を、どう使うのかについての記事です。</p><p>いわゆるフロントエンドのエンジニアがWebRTCを使ったサービスを作るなどの場合は、だいたい何かしらの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>を使うと思います。<br />\nその場合はその<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>のDocsを読めばそれで十分で、その先の仕組みを知る必要はないかなーと思います。</p><p>ただし、</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>の中で何が行われてるか知っておきたい</li>\n<li>WebRTCの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>を作る側である</li>\n</ul><p>みたいな場合は、一読の価値ありかもです。</p><p>ようするに、弊社の新入社員のような人材のための記事です！</p><p>基本的なWebRTCの仕組みみたいなパートはざっくり軽めにして、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>について濃い目に書いていこうと思ってます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>WebRTCとは</h3>\n    <p>まずは概要から。</p>\n\n<ul>\n<li>Web（ブラウザ）で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信ができる仕様です</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Skype\">Skype</a>やLINEみたいな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D3%A5%C7%A5%AA%A5%C1%A5%E3%A5%C3%A5%C8\">ビデオチャット</a>が、なんとブラウザの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>だけで作れます\n<ul>\n<li>カメラとマイクがついた端末で、それ用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使ってビデオのストリームを取得し</li>\n<li>そのストリームを、それ用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で別の端末と送受信できます</li>\n</ul></li>\n<li>メディア以外にバイナリデータなどを送ることもできます</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>を確立するためには、お互いの通信要件を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CD%A5%B4%A5%B7%A5%A8%A1%BC%A5%B7%A5%E7%A5%F3\">ネゴシエーション</a>する必要があります\n<ul>\n<li>これを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>と言います</li>\n<li>第3者としてのサーバーを立ててやり取りするのが一般的です</li>\n<li>やり方に規定はなく、WebSocketでもいいし、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C5%C1%BD%F1%C8%B7\">伝書鳩</a>でもいいです</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>の相手はブラウザでもいいし、実装があればサーバーでもいいです\n<ul>\n<li>サーバーにやらせて端末の配信負荷を軽減する手法もあったりします</li>\n</ul></li>\n</ul><p>事前知識をもう少し。</p>\n\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a></h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信を確立するために必要なステップです。</p><p>前述の通りどんな方法でやり取りしてもいいのでそこはさておき、「どんな情報をやり取りするか」についてです。</p><p>基本的には`SDP`というフォーマットをやり取りすることになります。</p><p>具体的にはこんな資料があります。（日付は古いけど内容的には問題なしです）</p>\n\n    <blockquote>\n        <p><a href=\"https://www.slideshare.net/iwashi86/webrtc-for-sdp\">SDP for WebRTC</a></p>\n\n    </blockquote>\n<p>ざっくり含まれる情報を分類すると、</p>\n\n<ul>\n<li>何を送受信したいのか\n<ul>\n<li>動画なのか音声なのかデータなのか</li>\n<li>1つなのか2つなのかNつなのか</li>\n<li>送受信したいのか、送信・受信専用でいいのか</li>\n<li>どんなコーデックでどんな拡張を使うのか</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信を実行するトランスポートの候補\n<ul>\n<li>いわゆる通信の経路</li>\n<li>どのIPのどのポートでどの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>か</li>\n<li>選択肢が多いほうがつながる確率が高いので複数の候補を</li>\n</ul></li>\n<li>その候補から経路を確定するために必要なパラメータ\n<ul>\n<li>具体的にはICEという<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>を使って経路を決める</li>\n<li>その過程で必要なユーザー名とかパスワード</li>\n<li>あとは経路が決まったあとにデータを暗号化するためのパラメータなど</li>\n</ul></li>\n<li>その他\n<ul>\n<li>帯域を指定したり</li>\n<li>SDPのフォーマットとして必要なだけで、WebRTCには関係ないテンプレとか</li>\n</ul></li>\n</ul><p>とりあえず抑えておきたいこととしては、この「SDPに含まれている情報が全て」であり、基本的にはSDPを見れば、どういう通信をしているかがわかることになってます。</p><p>なので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>も、「どの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>をどう使えばSDPに反映されるのか」を気にして見ていくことになります。</p><p>ちなみにSDPですが、ただのテキストファイルのくせに情報量が多くつらつらと長ったらしくパースも大変なくせにその上フォーマットも紆余曲折あったりと、WebRTC界隈でのdisられ筆頭です。</p>\n\n</div>\n<div class=\"section\">\n    <h3>WebRTCがつながるまで</h3>\n    <p>さて本題に入るため、参考にするシナリオを考えます。<br />\nなんだか本題に入るまでが長くなってますが、そんな技術と歴史の積み重ねで成り立ってるのがWebRTC・・・！</p><p>この記事では、「AさんとBくんがお互いに動画と音声を送受信したい場合」を考えていきます。</p>\n\n<ul>\n<li>Aさんの準備\n<ul>\n<li>カメラととマイクから動画と音声を取得</li>\n<li>使えるコーデックやらを整理（ブラウザがよしなにまとめてくれる）</li>\n<li>通信経路の候補も集める</li>\n</ul></li>\n<li>Bくんも準備\n<ul>\n<li>Aさんと同じことをする</li>\n</ul></li>\n<li>Aさんからオファーを作って送る\n<ul>\n<li>自身の情報をさっきのSDPにまとめあげて、オファーとしてBくんに渡す</li>\n</ul></li>\n<li>Bくんがオファーを受け取る\n<ul>\n<li>そのオファーに対して、了承するなり拒否するなり、アンサーを作る</li>\n</ul></li>\n<li>Bくんもアンサーを作って送る\n<ul>\n<li>同じくSDPにまとめあげて、自身の情報 + オファーに対する解としてAさんに渡す</li>\n</ul></li>\n<li>Aさんがアンサーを受け取る\n<ul>\n<li>それを受け取ったら、いざ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>の開始</li>\n</ul></li>\n</ul><p>WebRTCの流れで「オファー・アンサー」というキーワードが出てくるのはこういう流れからです。<br />\nもちろん細かいところは端折ってますが、概ねこんな感じで、必要あれば後からまた補足します。</p><p>さてここからがやっと本題です。<br />\nそれぞれのステップを実現するためにどういうクラスと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使うのかを見ていきます！</p>\n\n</div>\n<div class=\"section\">\n    <h3>ブラウザの実装について</h3>\n    <p>と言いたいところですが先にコレも・・。</p><p>WebRTCの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>群は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>的にもまだ完全にFixした段階ではないです。<br />\nここ数年でだいぶマシになってほぼほぼ固まってきた感じはあるけど。</p><p>なので、</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/W3C\">W3C</a>の仕様にはあるけど実装がない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/W3C\">W3C</a>の仕様にはないけど実装されてる</li>\n<li>ブラウザAにはあるけどブラウザBにはない</li>\n<li>ブラウザAでもバージョンによって違う\n<ul>\n<li>動いたり動かなかったり</li>\n<li>挙動が違ったり</li>\n</ul></li>\n</ul><p>的なことが往々にしてあります。<br />\nまぁ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>界隈的には普通のことですね・・。</p><p>この記事の内容も、現時点ではこうですが、将来的には変わるかもしれません。<br />\nインターネットに転がってる記事も、当時の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使ってる今となっては古いやつとかあったりするので、逐次ちゃんと実際のブラウザで検証するのがいいです。</p><p>では今度こそ本題へ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection</h3>\n    <p>その名の通り、WebRTCするなら必須のクラスです。<br />\nこれに生えてる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使って処理を進めていきます。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(options);\n</pre><p>`options`にはオブジェクトを指定でき、そのキーにできるものはいくつかありますが、よく使われるものとしては、</p>\n\n<ul>\n<li>`iceServers`</li>\n<li>`iceTransportPolicy`</li>\n</ul><p>があります。</p><p>で、これが何なのかを説明するためにはまた事前知識が必要になってきます。</p>\n\n<div class=\"section\">\n    <h4>ICEとは</h4>\n    <p>さっきから何度も登場してるこの単語についてです。</p>\n\n<ul>\n<li>ICEは、WebRTCの通信を実行する経路をいい感じに見つけ出す仕組みです\n<ul>\n<li>ブラウザがその実装を持っていて、内部的に使われてます</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で直<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%DC%BF%A8\">接触</a>ることはないです（いちおう）</li>\n</ul></li>\n<li>これも内部的にですが、SDPに載せる通信経路の候補を集めるフェーズがあります</li>\n<li>集められる経路候補にはタイプがあります\n<ul>\n<li>ローカルホストとか、外部のネットワーク（インターネットから見た）とか</li>\n</ul></li>\n<li>集めたいタイプはある程度`RTCPeerConnection`のオプションで制限できます\n<ul>\n<li>デフォルトだとローカル限定で経路を集めます</li>\n<li>ただローカルNWのIPなんて教えたところで、インターネット越しでは通信できません</li>\n<li>プライベートなNW内での通信ならできるけど</li>\n</ul></li>\n<li>なので、基本的にはインターネットから見た経路を伝えたいはず</li>\n<li>そのために自分がインターネットからどう見えているのか、インターネットにいるサーバーに問い合わせます\n<ul>\n<li>これをSTUNという仕組みでやってます</li>\n</ul></li>\n<li>同様に、企業NWのように制約が多い場合は自由に経路を選べません\n<ul>\n<li>なので、通信の経路を純粋な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>ではなく、中継サーバー経由にすることもできます</li>\n<li>これをTURNという仕組みでやってます</li>\n</ul></li>\n</ul><p>で、このSTUNとかTURNを使うためのオプションが、さっきのやつです。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// STUNを使う</span>\n<span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  iceServers: <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{</span> urls: <span class=\"synConstant\">&quot;stun:1.2.3.4&quot;</span> <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// TURNを強制</span>\n<span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  iceServers: <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{</span>\n      urls: <span class=\"synConstant\">&quot;turn:1.2.3.4&quot;</span>,\n      credential: <span class=\"synConstant\">&quot;cred&quot;</span>,\n      username: <span class=\"synConstant\">&quot;user&quot;</span>,\n    <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">]</span>,\n  iceTransportPolicy: <span class=\"synConstant\">&quot;relay&quot;</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>もちろん実際にはSTUN/TURNサーバーのアドレスに適当なものを指定して使います。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#createOffer()</h3>\n    <p>さて、とにもかくにもSDPを用意します。</p><p>「WebRTCがつながるまで」の章で書いたように、まずはオファー用のSDPを作って、それを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>します。</p><p>オファー用のSDPを作るための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が`createOffer()`です。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n<span class=\"synStatement\">const</span> offer = await pc.createOffer();\n\noffer.type; <span class=\"synComment\">// &quot;offer&quot;</span>\noffer.sdp; <span class=\"synComment\">// SDP本体</span>\n</pre><p>値は`Promise`で返るのでよしなに。</p><p>ちなみに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のM73でこれだけ実行すると、次のSDPが出力されます。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>v=0\no=- 4601616591182606030 3 IN IP4 127.0.0.1\ns=-\nt=0 0\na=msid-semantic: WMS</pre><p>今の時点ではなんの情報もないです。<br />\nどんなメディアを送りたいかとか、そういう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を一切使ってないからです。</p><p>このSDPを育てていくのがここからの話。</p>\n\n</div>\n<div class=\"section\">\n    <h3>MediaStream / MediaStreamTrack</h3>\n    <p>今回は動画と音声を送受信したいので、やることとしては、</p>\n\n<ul>\n<li>動画と音声のストリームを取得</li>\n<li>それをSDPに反映</li>\n</ul><p>まずはストリームの取得なのですが、`RTCPeerConnection`にそれ用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はありません。<br />\nが、安心してください！別の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>がちゃんとありますよ！というわけで。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>的には、`MediaStream`というクラスと、それを構成する`MediaStreamTrack`というクラスがそれです。</p><p>取得する方法はいくつかあるのですが、代表的なものは以下のコードの通り。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// video + audio</span>\n<span class=\"synStatement\">const</span> videoAndAudioStream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  video: <span class=\"synConstant\">true</span>,\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// audioのみ</span>\n<span class=\"synStatement\">const</span> audioStream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// 画面共有</span>\n<span class=\"synStatement\">const</span> displayStream = await navigator.mediaDevices.getDisplayMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n</pre><p>`getUserMedia()`の引数オブジェクトはもっと細かく指定できるのですが、今回は割愛します。</p><p>取得した`MediaStream`には、N個の`MediaStreamTrack`が内包されてます。<br />\n動画と音声なら、動画の`video`と音声の`audio`の2つ、画面共有なら画面の動画の`video`の1つだけ。</p><p>それぞれ取り出すこともできます。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  video: <span class=\"synConstant\">true</span>,\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\nstream.getTracks(); <span class=\"synComment\">// MSTぜんぶ</span>\nstream.getAudioTracks(); <span class=\"synComment\">// audioのMSTだけ</span>\nstream.getVideoTracks(); <span class=\"synComment\">// videoのMSTだけ</span>\n</pre><p>なぜ`MediaStreamTrack`単位で考えるかというと、それがWebRTCにおいてよくある<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>だからです。</p><p>動画だけ送りたい、音声だけ受け取りたいみたいなケースのために、そもそも`MediaStream`ではなく、`MediaStreamTrack`単位でいろいろ処理してこ！というのが最近のトレンドなわけです。</p>\n\n<div class=\"section\">\n    <h4>MediaStream(Track)をDOMに表示する</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  video: <span class=\"synConstant\">true</span>,\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">const</span> $video = <span class=\"synStatement\">document</span>.querySelector(<span class=\"synConstant\">'video'</span>);\n<span class=\"synComment\">// もしくは</span>\n<span class=\"synStatement\">const</span> $video = <span class=\"synStatement\">document</span>.createElement(<span class=\"synConstant\">'video'</span>);\n\n$video.srcObject = stream;\nawait $video.play();\n</pre><p>このように、`HTMLVideoElement`の`srcObject`に渡すことで再生できます。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#addTrack()</h3>\n    <p>さて、`MediaStreamTrack`を手に入れたので、それを`RTCPeerConnection`に渡します。</p><p>`addTrack()`という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>に、`MediaStreamTrack`と`MediaStream`を渡します。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\n<span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  video: <span class=\"synConstant\">true</span>,\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">for</span> (<span class=\"synStatement\">const</span> track of stream.getTracks()) <span class=\"synIdentifier\">{</span>\n  pc.addTrack(track, stream);\n<span class=\"synIdentifier\">}</span>\n</pre><p>これでこのメディアを送信したいという意図を伝えることができました。<br />\nこの状態で再び`createOffer()`を実行してSDPを生成すると、さっきと大きく結果が変わります。</p><p>実際にやってみるとわかりますが、めちゃくちゃ長いテキストになります。<br />\nまじで長いので割愛しますが、「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>」の章で書いたSDPに含まれるべき情報のほとんどが出力されます。</p><p>ほとんど、と言ったのは全てではないからで、この時点では「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信を実行するトランスポートの候補」の情報は載ってません。</p><p>この通信経路の候補を集める処理は、これでいくぞ！オファー出すぞ！という意思が固まったタイミングで行われます。<br />\nなので逆にいうとそれまでは、</p>\n\n<ul>\n<li>`addTrack()`したものを取り消すこともできる\n<ul>\n<li>今回の記事では紹介してない<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使えば</li>\n</ul></li>\n<li>追加で`addTrack()`してもいい</li>\n</ul><p>というわけです。</p><p>では次に、オファー出すぞ！これで確定するぞ！の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>です。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#setLocalDescription()</h3>\n    <p>作成したオファーSDPは、相手に送り届けると同時に、自身の設定として`RTCPeerConnection`に反映します。<br />\nそのための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が、`setLocalDescription()`です。</p><p>オファー側のコードの流れをおさらいするとこのように。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\n<span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span>\n  video: <span class=\"synConstant\">true</span>,\n  audio: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">for</span> (<span class=\"synStatement\">const</span> track of stream.getTracks()) <span class=\"synIdentifier\">{</span>\n  pc.addTrack(track, stream);\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> offer = await pc.createOffer();\n\nawait pc.setLocalDescription(offer);\n\npc.localDescription; <span class=\"synComment\">// ココで確認できる</span>\n</pre><p>WebRTCに関する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>の仕様的には、「`createOffer()`してから`setLocalDescription()`するまでの間に、オファーのSDPを書き換えてはいけない」です。</p><p>ただ実際にはSDPに変更を加えたいけど、それ用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が実装されてないなどの理由で、SDPを自分たちで修正することがあったりもします。</p><p>何はともあれ、`setLocalDescription()`することで処理はまた一つ次へ進みます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#onicecandidate</h3>\n    <p>今の状態のSDPを送っても、「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信を実行するトランスポートの候補」が含まれていないため実際に通信はできません。</p><p>相手のオファーを受け取って、「メディアの送受信がしたい旨はわかったけど、どこのIPのどのポートと送受信すればいいの？」ってなるからです。</p><p>その「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信を実行するトランスポートの候補」は、`RTCIceCandidate`というクラスで表され、`RTCPeerConnection`の`icecandidate`イベントを監視することで入手できます。</p><p>`setLocalDescription()`するとこの候補たちが収拾されて、見つかり次第イベントが発火します。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\npc.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate !== <span class=\"synStatement\">null</span>) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 経路の候補が見つかったとき</span>\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// 全ての経路を見つけ尽くしたとき</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>先述の通りローカルNWであるホストのIPとポートだけなら、自分のことなので一瞬でわかります。<br />\nただしインターネット側から見た場合の、STUNやTURNを利用する場合のIPとポートは、すぐにはわかりません。</p><p>なので、非同期にこのイベントを監視して、</p>\n\n<ul>\n<li>全ての経路を見つけ尽くしてから、まとめて送る</li>\n<li>経路が見つかり次第、送ってあげる</li>\n</ul><p>この2パターンが考えられるわけで、前者を「<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vanilla%20ICE\">Vanilla ICE</a>」、後者を「Trickle ICE」と呼んだりします。</p><p>つまり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>というのは、ICEの経路候補 + それ以外の情報を、なんとかして通信相手に伝えることを指します。</p><p>前者の場合は、`ev.candidate === null`になってから、`pc.localDescription`を確認することで、ICEの経路候補がSDPに含まれていることを確認できます。<br />\n`a=candidate`からはじまる行があればそれです。</p><p>こうして出来上がったSDPの完全体を、何らかの方法で通信相手に送ります。</p><p>ここまででオファーを出す側は一段落で、次はオファーを受け取ってアンサーを返す側へスイッチ。</p><p>このイベントで受け取った`RTCIceCandidate`と「Trickle ICE」については、またあとで紹介します。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#setRemoteDescription()</h3>\n    <p>`setLocalDescription()`と対になる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>です。</p><p>自身が生成したSDPを反映するのが`setLocalDescription()`で、通信相手から受け取ったSDPを反映するのが`setRemoteDescription()`です。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\n<span class=\"synComment\">// なんらかの手段で offer を受け取ったものとして</span>\n\nawait pc.setRemoteDescription(offer);\n\npc.remoteDescription; <span class=\"synComment\">// ココで確認できる</span>\n</pre><p>今回はどちらも動画と音声を送受信するので、`addTrack()`をよしななタイミングでやっておくのも忘れずに。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#createAnswer()</h3>\n    <p>ここまでで紹介してない最後の1ピースが`createAnswer()`で、`createOffer()`と対になる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>です。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\n<span class=\"synComment\">// なんらかの手段で offer を受け取ったものとして</span>\n\nawait pc.setRemoteDescription(offer);\n\n<span class=\"synStatement\">const</span> answer = await pc.createAnswer();\n\nanswer.type; <span class=\"synComment\">// &quot;answer&quot;</span>\nanswer.sdp; <span class=\"synComment\">// SDP本体</span>\n\nawait pc.setLocalDescription(answer);\n</pre><p>受け取ったオファーを解釈して、そのオファーを快諾するのか、一部は拒否するのかなどオペレーションを経た後に、アンサーSDPを生成します。</p><p>ここでいうオペレーションとは、オファーと同じく動画と音声を送受信したいので適切に`addTrack()`するとか、やっぱり受信専用がいいので`addTrack()`しないとかのことです。<br />\nその判断をした後に、`createAnswer()`を実行します。</p><p>SDPを生成したら、オファー側と同じように`setLocalDescription()`するまでがセットです。</p><p>あとはそのアンサーを、オファー側になんらかの手段で送り返すだけ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnectionおさらい</h3>\n    <p>流れのおさらいです。</p><p>オファー側から、</p>\n\n<ul>\n<li>`createOffer()`</li>\n<li>`setLocalDescription()`</li>\n<li>通信経路の候補が出揃うのを待つ</li>\n<li>オファー送信</li>\n</ul><p>そしてアンサー側で、</p>\n\n<ul>\n<li>オファー受取</li>\n<li>`setRemoteDescription()`</li>\n<li>`createAnswer()`</li>\n<li>`setLocalDescription()`</li>\n<li>通信経路の候補が出揃うのを待つ</li>\n<li>アンサー送信</li>\n</ul><p>またオファー側に戻って、</p>\n\n<ul>\n<li>アンサー受取</li>\n<li>`setRemoteDescription()`</li>\n</ul><p>という流れで処理を行います。</p><p>オファー側は`createOffer()`で、アンサー側は`createAnswer()`で適切なSDPを生成し、両側で`setLocalDescription()`と`setRemoteDescription()`を呼び終えたら、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信が開始されるはずです。</p><p>これだけ見ると割とわかりやすいフローですね・・？</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#addIceCandidate()</h3>\n    <p>ここまでの説明は、ICEの通信経路の候補が見つけ尽くしてから、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>する前提で書いてました。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\npc.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate !== <span class=\"synStatement\">null</span>) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 経路の候補が見つかった</span>\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// 全ての経路を見つけ尽くした</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>この分岐の下のパターンを\"待ってから\"、処理していたという意味です。</p><p>これは実装としても仕様としても問題なく動くのですが、昨今のトレンドとしては「一秒でも早く通信を開始したい」というものがあります。<br />\nあとは環境によって（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>が使えなかったりとかなにかと事情があるはず）、すべての経路を見つけ尽くすまで（=`ev.candidate === null`になるまで）、思ったより時間がかかる場合があります。</p><p>それをただ待ち続けるのもイケてないので、先述の「Trickle ICE」をやろう！となるわけです。</p><p>「Trickle ICE」では、見つかった候補をすぐに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>します。<br />\nそしてその候補を受け取って取り込むための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が、この`addIceCandidate()`です。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\n<span class=\"synComment\">// なんらかの手段で candidate を受け取ったものとして</span>\n\nawait pc.addIceCandidate(candidate);\n</pre><p>ただしこのメソッドを呼んでいいのは、`setRemoteDescription()`した後だけです。<br />\n`RTCIceCandidate`には、「この経路候補は、SDPの中に記述されてるこの動画を送るためのもの」みたいなヒモ付があって、その情報がないと対応に困るからです。</p><p>適切なタイミングでこのメソッドを実行すると、受け取った経路候補を自身の候補と最速で照らし合わせて、使える経路が見つかり次第即、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信をはじめます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#ontrack</h3>\n    <p>オファー・アンサーで無事にSDPを交換して、ICEの経路もいい感じにやり取りできたとして、メディアが送受信されることをどう補足するのか？です。</p><p>ちゃんとそれ用のイベントがあります！</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\npc.addEventListener(<span class=\"synConstant\">'track'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  ev.track; <span class=\"synComment\">// MediaStreamTrack</span>\n  ev.streams; <span class=\"synComment\">// [MediaStream]</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>このように、通信相手が何かメディアを送っていた場合、その`MediaStreamTrack`（と、`MediaStream`）がイベントで拾えます。<br />\nなのでこれを使って相手のストリームをDOMに表示すれば、晴れてブラウザで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D3%A5%C7%A5%AA%A5%C1%A5%E3%A5%C3%A5%C8\">ビデオチャット</a>が実装できるというわけです。</p><p>今回は割愛しますが、他にも`RTCPeerConnection`から`MediaStreamTrack`を拾う方法はあります。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#on...</h3>\n    <p>なんらかの問題があって、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>やメディアの送受信に失敗することもあります。<br />\n一度メディアが流れて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>していても、回線が不安定になったりで切断されてしまうこともあります。</p><p>そういうあれこれをどう捕捉するか？ですが、もちろんあれこれイベントが用意されてるのでそれを監視することになります。<br />\nイベントはいろいろあるのですが、選りすぐって紹介します。</p>\n\n<div class=\"section\">\n    <h4>signalingstatechange</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\npc.addEventListener(<span class=\"synConstant\">'signalingstatechange'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n  pc.signalingState; <span class=\"synComment\">// ココで確認できる</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>の状況です。</p><p>つまり、`setLocalDescription()`したかどうか、`setRemoteDescription()`したかどうかなどの状態が取れます。</p><p>この値が`have-remote-offer`じゃない場合は、`addIceCandidate()`するのやめてキューに貯めて待つ・・みたいな実装ができます。</p>\n\n</div>\n<div class=\"section\">\n    <h4>iceconnectionstatechange</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection();\n\npc.addEventListener(<span class=\"synConstant\">'iceconnectionstatechange'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n  pc.iceConnectionState; <span class=\"synComment\">// ココで確認できる</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>ICEの接続状態、aka、WebRTCの通信の接続状態です。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>からはさわれないネットワークのレイヤーの状況を知るための唯一の手段です。</p><p>これが`failed`とか`disconnected`になると、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>の通信も途絶えていることになります。<br />\n受信している動画はバッファを再生しきったら止まるし、こちらからも送信できなくなります。</p><p>なのでこのイベントは常に監視して、エラー表示するとか、再接続を試みるとか、なんらかのアクションを取ることになります。</p><p>これも今回は割愛しますが、ICEの接続をやり直すことを、「ICEリスタート」と呼んだりもします。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection#close()</h3>\n    <p>その名の通り、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>接続の終了を意味する`close()`です。</p><p>一度`close()`した`RTCPeerConnection`を復活させることはできないので、そこだけ注意が必要です。</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>最もありがちな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>を最もシンプルに実現するために必要な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>だけを紹介してきましたが、それでも結構な量になりましたね・・。</p><p>おさらいすると、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>のクラスとして最低限知っておくべきは3つ。</p>\n\n<ul>\n<li>RTCPeerConnection\n<ul>\n<li><a href=\"https://w3c.github.io/webrtc-pc\">https://w3c.github.io/webrtc-pc</a></li>\n</ul></li>\n<li>MediaStream</li>\n<li>MediaStreamTrack\n<ul>\n<li><a href=\"https://w3c.github.io/mediacapture-main\">https://w3c.github.io/mediacapture-main</a></li>\n<li><a href=\"https://w3c.github.io/mediacapture-screen-share/\">https://w3c.github.io/mediacapture-screen-share/</a></li>\n</ul></li>\n</ul><p>あとは主に`RTCPeerConnection`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使ってSDPを生成して、それをなんらかの方法で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>するだけです。</p><p>単純な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>をやるだけならこの記事で紹介した<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>でいいですが、ここから一歩でも踏み込もうとすると、また知っておくべき<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>がいろいろでてきます・・！</p><p>まぁそれはまた機会があればいずれ・・ということで、その時のための章立てだけ書き残しておきます。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>* シグナリングサーバーの実装Tips\n- グレアをいかにして解消するか\n- `negotiationneeded`イベント\n\n* 同じ挙動を実装する方法は何パターンかある話\n- `RTCPeerConnection`を複数つくるとか\n- SDPを使わないでシグナリングするとか\n\n* `addTransceiver()`および`RTCRtpTransceiver`\n- 送信のみ・受信のみ\n- SDPとの関係\n\n* `RTCRtpSender`よもやま\n- `RTPSender`と`RTPReceiver`\n- 各種RTPパラメータたち\n\n* `RTCDataChannel`\n- 仕組み\n- WebSocketとの差異\n\n* `MediaStream`まわり\n- `MediaStreamTrack`の合成\n- ミュート処理\n- `RTCRtpSender#replaceTrack()`\n- メディアデバイスの指定\n- メディアに関する制約（モバイル含め）\n- `ImageCapture`や`MediaRecorder`など周辺API\n\n* その他のクラスとAPI\n- `RTCStatsReport`\n-- WebRTCで統計データを扱う\n- `RTCCertificate`\n-- `generateCertificate()`\n\n* 多人数での通信について\n- SFUの存在意義とか\n- Simulcast/SVCの現状\n\n* 未来のはなし\n- `RTCIceTransport`\n- `RTCQuicTransport`</pre><p>無限に記事が書けますね・・ｗ</p><p>ではでは、なにかあれば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a>などでお気軽にお声がけください！</p>\n\n</div>"
}
