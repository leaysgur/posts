{
  "title": "Qwik(City)を試してみた感想",
  "html": "<p>もとい、Svelte(Kit)なプロジェクトを、Qwik(City)で書き直してみての学び。</p><p>待望のやつではあるが、端切れの悪いタイトルなのは、移行途中でどうしようもなくハマってしまい、採用を見送ることにしたから・・😇</p><p>そういうわけなので、使い込んでみたわけでもまったくないし、最高！とか微妙・・・とかそういう判断というよか、ただの感想文って感じ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3 id=\"QwikCityありき\">QwikCityありき</h3>\n    <p>`npm create qwik`のスターターが、そもそもQwik単体ではなく、QwikCityがセットになってた。</p><p>今回はSSG/SPA用途だったので、できればQwikだけ使えればいいかなーと思ってたけどそんな選択肢はなかった。こういうメタ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>が前提になってたりすることが多くて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>なコンテキストを回避するコードを書きたくないし、挙動としても囚われたくなかったのに・・。</p><p>あとはコードベースもTypeScript一択になってて、拡張子を適当に変えてみるとビルドできなくなったりと、当面このへんはどうにもならなさそう。<br />\nスターターが生成するファイル群（`entry.xxx`とか`root.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/tsx\">tsx</a>`とか）も、場所を動かすことすら許されない感じだった・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"SSRから逃げられない\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>から逃げられない</h3>\n    <p>上述のとおり、完全にSPAとして作りたい場合（将来的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>への移行なんかも考えなくて良い）は、そもそもコードのすべてがクライアントで実行されてしまっていい。SSG的な初回<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>もいらない。</p><p>という場合に、コードベースから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>成分を完全に排除できるメタフレームは、知る限りSvelteKitしかない。（根本で`export const <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a> = false`すればいい）</p><p>この設定ができないNextとかSolidStartとかだと、それ用の`NoSsr`みたいな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を自作する必要がある。（`useEffect()`でフラグを立てるまではメインの`children`を描画しないみたいなやつ）</p><p>が、Qwik(City)では、この作戦も通用しなかった。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synType\">const</span> NoSsr <span class=\"synStatement\">=</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synType\">const</span> csr <span class=\"synStatement\">=</span> useSignal<span class=\"synStatement\">(</span><span class=\"synConstant\">false</span><span class=\"synStatement\">);</span>\n  useClientEffect$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span> csr.value <span class=\"synStatement\">=</span> <span class=\"synConstant\">true</span><span class=\"synStatement\">;</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n  <span class=\"synStatement\">return</span> csr.value ? <span class=\"synStatement\">&lt;</span>Slot /<span class=\"synStatement\">&gt;</span> : <span class=\"synStatement\">&lt;</span>div<span class=\"synStatement\">&gt;</span>LOADING...<span class=\"synStatement\">&lt;</span>/div<span class=\"synStatement\">&gt;;</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>理論上（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>ツリー的な）は問題ないと思うし、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>も通るけど、実際には下層の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>までしっかり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>なコンテキストで事前実行されてしまうらしく、普通に`localStorage is not defined`みたいになる。</p><p>下層の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>であっても、Qwik-wayに遅延ロードできるチャンクに変換すべく、一通りは実行する的な挙動っぽい。そういう意味では、常にすべての<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>をユニバーサルなコードとして紡ぐ必要があり、そうなると必然的にブラウザでだけ動く<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使ったコードをよく使うプロジェクトは書きにくい・・よな〜って。</p>\n\n    <blockquote>\n        <p><a href=\"https://qwik.builder.io/docs/components/rendering/\">https://qwik.builder.io/docs/components/rendering/</a></p>\n\n    </blockquote>\n<p>Out-of-orderっていう概念がたぶんそれ。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"Think-Qwikむずい\">Think Qwikむずい</h3>\n    <p>Qwikを支える、Resumability & Serializationを理解し、コードに落とし込めるようになるまで、めっちゃ時間かかりそうって話。</p><p>まあ既存のものとは一線を画するFWっていう意味では、学習コストが高いのは仕方ないというか、そういうものなんやけど。</p><p>たとえば、遅延実行のために`$`で隔てられた境界を超えるためには、HTMLの属性値として<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%EA%A5%A2%A5%E9%A5%A4%A5%BA\">シリアライズ</a>できる必要がある。そうなるともちろん<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JSON\">JSON</a>にできないもの（`class`とか関数とか）を、特別な方法で扱う必要が出てくるわけで。そのために`noSerialize()`っていう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>でラップしたりとひと手間が必要で、ここ自動じゃないんや・・ってなる。</p><p>あとは内部的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/QRL\">QRL</a>と呼ばれてるQwikの最小実行単位みたいな枠に収まるコードにする必要もあって、たとえばこういうのがエラーになる。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synType\">const</span> WORLD <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;world&quot;</span><span class=\"synStatement\">;</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>p<span class=\"synStatement\">&gt;</span>Hello<span class=\"synStatement\">,</span> <span class=\"synIdentifier\">{</span>WORLD<span class=\"synIdentifier\">}</span><span class=\"synStatement\">&lt;</span>/p<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>こういう雑なスコープの変数は、`$`境界を超えて扱うことができない。</p><p>明示的にファイルを切って`export`するとか、インラインで書く必要がある。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> WORLD <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;...&quot;</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>p<span class=\"synStatement\">&gt;</span>Hello<span class=\"synStatement\">,</span> <span class=\"synIdentifier\">{</span>WORLD<span class=\"synIdentifier\">}</span><span class=\"synStatement\">&lt;</span>/p<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// OR</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synType\">const</span> WORLD <span class=\"synStatement\">=</span> <span class=\"synConstant\">&quot;world&quot;</span><span class=\"synStatement\">;</span>\n\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>p<span class=\"synStatement\">&gt;</span>Hello<span class=\"synStatement\">,</span> <span class=\"synIdentifier\">{</span>WORLD<span class=\"synIdentifier\">}</span><span class=\"synStatement\">&lt;</span>/p<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>インラインだとしても、関数なんかを変数化するにはひと手間が必要。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// const onClick = () =&gt; console.log(&quot;world!&quot;);</span>\n  <span class=\"synComment\">// Need to wrap with `$`</span>\n  <span class=\"synType\">const</span> <span class=\"synSpecial\">onClick</span> <span class=\"synStatement\">=</span> $<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synSpecial\">console</span>.log<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;world!&quot;</span><span class=\"synStatement\">));</span>\n\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>button onClick$<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span><span class=\"synSpecial\">onClick</span><span class=\"synIdentifier\">}</span><span class=\"synStatement\">&gt;</span>Hello<span class=\"synStatement\">&lt;</span>/button<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>どこまでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の気持ちにならないといけない。</p><p>まあ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>がいちいち賢く怒ってくれるので、ある程度はなんとかなるとはいえ、めんどくさいなって。</p><p>他にも、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>までも非同期なので、`ev.preventDefault()`も特別な書き方が必要とかある。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> component$<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>form onSubmit$<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span><span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span> <span class=\"synComment\">/* ... */</span> <span class=\"synIdentifier\">}}</span> preventdefault:submit<span class=\"synStatement\">&gt;</span>\n      ...\n    <span class=\"synStatement\">&lt;</span>/form<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">);</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>React知ってればQwik書けるぜ的な宣伝のされ方してるけど、ぜんぜんそんなことない。</p><p>あとは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が怒ってくれないけど落ちるみたいなやつを踏んだ時、本当にどうしようもない・・・。（それで採用やめた勢としては）<br />\n<br />\n</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"自動で遅延ロードされる難しさ\">自動で遅延ロードされる難しさ</h3>\n    <p>QwikCityでは、`ServiceWorker`がprefetchをめちゃめちゃがんばってる。（Qwik単体だとプリフェッチの仕組みはなかったはず）</p>\n\n    <blockquote>\n        <p><a href=\"https://qwik.builder.io/qwikcity/prefetching/request-response-cache/\">Qwik City Caching Request and Response Pairs - Qwik</a></p>\n\n    </blockquote>\n<p>`link[rel=prefetch]`よりも洗練されてるらしい。複数の場所から同じリソースを読もうとしたときに、リク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トが重複しちゃうとかそういう心配がないとのこと。</p><p>ただ、帯域やパケットという意味ではどうなんだという気持ちになっちゃう。確かに実行は遅延されるけど、せっかくダウンロードしたのに実行されないコードも出てくるので。</p><p>このへんは全自動だとやっぱりむずかしいのかなーと。小さいフォームがあるだけのページで、フォーム要素それぞれの`input.onInput`を遅延読み込みする必要あるか？とか考えてしまう。</p><p>あとはチャンクが細かくなるということは、Svelteのそれみたく、ある一定以上の規模になると、ボイラープレートがかさんでトータルのサイズが大きくなってしまう問題もありそう。サイズは目的としてないってどこかに書いてあったような気もする。</p><p>そういうデザインなので仕方がない。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"結局いつ輝くのか\">結局いつ輝くのか</h3>\n    <p>個人的にずっと思ってるやつ。</p><p>すべてが遅延ロードできる = ロードしたいものがたくさんある前提、というところで、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の総量が少ないサイトではそもそも採用意義が薄いはず。</p><p>なぜかSPA化されてしまってる静的な成分が多めのサイトであれば、まずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MPA\">MPA</a>にするとか、Astroくらいの遅延実行でも十分というか。部分だけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>できるようにもなったしなおさら。（もちろんハイドレーション自体が・・というのはあるけど）</p><p>となるとやはり対象は、巨大なSPAなのかなと思うけど、クライアント専用のJSが多いコードは、上述の理由からあまり書きやすいとは思えず。もちろんパフォーマンスのために開発者が骨を折るのは理解できるとしても。</p><p>でもそれも、ルートごとにやるのはもちろん、特別に重いとか優先度の低い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を、手動で`lazy()`に読み込むとかでそれなりにカバーできそうな気もしていて。</p><p>というところで、相変わらず自分のこれまでの経験と、それらに対する択という意味ではあまり刺さるシーンがない気がするなあというこの気持ちは、実際にコードを書いてみてもあまり変わらんかった。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"おわりに\">おわりに</h3>\n    <p>すべてを遅延ロード・遅延実行できるのは確かに理想的ではあるが、そのためにかけられるオー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B5%A5%EA%A5%F3\">サリン</a>グのコストとしてはやや予算オーバーで、遅延の単位ももう少し調整させてほしいな〜というのが正直なところ。</p><p>そもそも現時点ではまだベータなので、そりゃあ思ったほどすんなりはいかんよってことは承知の上で、これからに期待しつつ、またの機会に試そうかと。</p><p>せっかく書きやすいReactiveプリミティブ（`useSignal()`とか`useResource$()`とか）や`useStylesScoped$()`あるので、SPAがもっと楽に書けるようになってほしいな〜。</p>\n\n</div>"
}
