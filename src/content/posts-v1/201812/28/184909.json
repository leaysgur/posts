{
  "title": "NodeJSでSTUN(RFC5389)(の一部)を実装した",
  "html": "<p>そもそも「STUNを実装する is 何」というところから整理しないとですが、しました。</p><p>ただしタイトルにもある通り、一部です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/webrtc-stun\">GitHub - leader22/webrtc-stun: 100% TypeScript STUN implementation for WebRTC.</a></p>\n\n    </blockquote>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の先行実装はいろいろ見つかるけど、TypeScriptの実装はたぶん初。</p><p>`webrtc-stun`というパッケージ名で、npmからもインストールできます。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>そもそもSTUNとは</h3>\n    \n<ul>\n<li>Session Traversal Utilities for NAT の略</li>\n<li>WebRTCでピア同士がつながるために、NATの向こう側にいる相手のIPやらが必要\n<ul>\n<li>それをどうにかして取ってくるための方法がまとまってる仕様</li>\n<li>手続きとそれに使うツールの作り方が書いてある</li>\n<li>簡単に言うと、固定長のヘッダ + 任意の数の属性からなるメッセージを送り合う決まりになってる</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>のURLはこちら\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc5389\">RFC 5389 - Session Traversal Utilities for NAT (STUN)</a></li>\n</ul></li>\n<li>元々はRFC3489で定義されてて、classic STUNと称されたりする\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc3489\">RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</a></li>\n</ul></li>\n</ul><p>ただこの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>はあくまでSTUNそれ自体の説明書であって、ただの辞書です。</p><p>WebRTCにおいてどういう用途で使うとかはほぼ書いてなくて、これがWebRTCスタックを実装する時にいちばんつらいところらしい。</p><p>しかも別の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>でしれっと拡張されてたりもするので、全容が把握できなくていい感じにコード書くのつらい。まじつらい。</p>\n\n</div>\n<div class=\"section\">\n    <h3>WebRTCにおけるSTUNの用途</h3>\n    <p>このあたりは、主にはICEとして別の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>にまとまってる。</p>\n\n<ul>\n<li>Interactive Connectivity Establishment\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc8445\">RFC 8445 - Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</a></li>\n<li>= いい感じに接続を確立するためのあれこれ</li>\n</ul></li>\n<li>用途はいくつかあって、随所にSTUNが使われてる\n<ul>\n<li>早速さっきの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>を拡張しますとか書いてあったりもする</li>\n</ul></li>\n<li>もちろんこの他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>でも使われたり拡張されたりするけど\n<ul>\n<li>DTLSとか</li>\n<li>TURNとか</li>\n</ul></li>\n</ul><p>ともあれ、今回実装したのはあくまで、</p>\n\n<ul>\n<li>RFC8445に書いてある<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>のうち</li>\n<li>RFC5389に書いてある仕様だけで完結する部分\n<ul>\n<li>と余力のある限り他のRFC5389に書いてある部分</li>\n</ul></li>\n</ul><p>です。</p><p>で、具体的な用途として使えるのは、`icecandidate`の候補収集。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ICEの候補収集</h3>\n    <p>SDPに載る`a=candididate`の行の話。</p><p>`RTCPeerConnection`の`iceServers`でオプションを渡すと、ICEの経路収集でそのSTUNサーバーが使われるようになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  sdpSemantics: <span class=\"synConstant\">'unified-plan'</span>,\n  <span class=\"synComment\">// コレを指定すると</span>\n  iceServers: <span class=\"synIdentifier\">[{</span> urls: <span class=\"synConstant\">'stun:stun.l.google.com:19302'</span> <span class=\"synIdentifier\">}]</span>,\n<span class=\"synIdentifier\">}</span>);\n\npc.createDataChannel(<span class=\"synConstant\">''</span>);\npc.createOffer()\n  .then(s =&gt; pc.setLocalDescription(s));\n\n<span class=\"synComment\">// ココが多く発火する</span>\npc.onicecandidate = ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate !== <span class=\"synStatement\">null</span>) <span class=\"synIdentifier\">{</span>\n    console.log(ev.candidate.candidate);\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n    console.log(pc.localDescription.sdp);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>このオプションの有無で、`onicecandidate`が発火する回数が変わるし、指定してた場合は、`srflx`っていう`candidate-type`がついた経路が取得できるはず。</p><p>つまりブラウザの中にSTUNのクライアントの実装がいて、`setLocalDescription()`のタイミングで指定されたSTUNサーバーに問い合わせ（`BINDING-REQUEST`）をしてる。</p><p>STUNサーバーはそれを受けてあなたのIPやらポートはこうですという返事（`BINDING-RESPONSE`）をする、その返事の中で`XOR-MAPPED-ADDRESS`という属性を付与して返すのが決まり。</p><p>その結果、ブラウザがそれを`candidate`としてSDPに書くという流れ。</p><p>ちなみに、ブラウザではなくサーバーで動かすWebRTCの実装をする場合は、そもそも別のやりかたでグローバルなIPがわかってたりもするはずで、この用途においてはSTUNを使う必要がなかったりもする。</p>\n\n</div>\n<div class=\"section\">\n    <h3>BINDING-REQUESTを送る</h3>\n    <p>実装したSTUNを使って、実際にリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トを送信するコードがこちら。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> dgram = require(<span class=\"synConstant\">'dgram'</span>);\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> StunMessage <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'webrtc-stun'</span>);\n\n<span class=\"synStatement\">const</span> socket = dgram.createSocket(<span class=\"synIdentifier\">{</span> type: <span class=\"synConstant\">'udp4'</span> <span class=\"synIdentifier\">}</span>);\n\nsocket.on(<span class=\"synConstant\">'message'</span>, msg =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> res = StunMessage.createBlank();\n\n  <span class=\"synComment\">// if msg is valid STUN message</span>\n  <span class=\"synStatement\">if</span> (res.loadBuffer(msg)) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// if msg is BINDING_RESPONSE_SUCCESS</span>\n    <span class=\"synStatement\">if</span> (res.isBindingResponseSuccess()) <span class=\"synIdentifier\">{</span>\n      <span class=\"synStatement\">const</span> attr = res.getXorMappedAddressAttribute();\n      <span class=\"synComment\">// if msg includes attr</span>\n      <span class=\"synStatement\">if</span> (attr) <span class=\"synIdentifier\">{</span>\n        console.log(<span class=\"synConstant\">'RESPONSE'</span>, res);\n        console.log(attr.ip, attr.port);\n      <span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>\n\n  socket.close();\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">const</span> req = StunMessage.createBindingRequest();\nconsole.log(<span class=\"synConstant\">'REQUEST'</span>, req);\nsocket.send(req.toBuffer(), 19302, <span class=\"synConstant\">'stun.l.google.com'</span>);\n</pre><p>やってることはコード見たらわかるくらい単純なので割愛。</p><p>今回は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>でSTUNメッセージをやり取りするので、`dgram`を使うくらい。<br />\nWebRTC的には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>を使うこともあるらしい。</p>\n\n<div class=\"section\">\n    <h4>レスポンス例</h4>\n    <p>インターネットに公開されてるSTUNサーバーはいくつもあって、上のコード例で使ってる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a>の他にもいろいろある。（検索するとリストいっぱいでてくる）</p><p>`BINDING-REQUEST`を送った場合、`BINDING-RESPONSE`で返ってくる属性はこんな感じだった。</p>\n\n<ul>\n<li>`stun.l.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\">google</a>.com:19302`\n<ul>\n<li>RFC5389: XOR-MAPPED-ADDRESS</li>\n</ul></li>\n<li>`stun.webrtc.ecl.ntt.com:3478`\n<ul>\n<li>RFC5389: XOR-MAPPED-ADDRESS</li>\n<li>RFC5389: MAPPED-ADDRESS</li>\n<li>RFC5389: SOFTWARE</li>\n<li>RFC5389: FINGERPRINT</li>\n<li>RFC5780: RESPONSE-ORIGIN</li>\n</ul></li>\n</ul><p>`XOR-MAPPED-ADDRESS`だけあれば、この用途としては十分だということがわかる・・。<br />\nその他は返ってきても使わないので。</p><p>レスポンスには一応`SUCCESS`と`ERROR`があるけど、`SUCCESS`を返すに値しないリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トは無視する！っていう挙動のSTUNサーバーも割といました。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>BINDING-RESPONSEを返す</h3>\n    <p>さっきの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>のコードの`iceServers`の部分を、自分で実装したSTUNに向ければもちろん試すことができる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> dgram = require(<span class=\"synConstant\">'dgram'</span>);\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> StunMessage <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'webrtc-stun'</span>);\n\n<span class=\"synStatement\">const</span> socket = dgram.createSocket(<span class=\"synIdentifier\">{</span> type: <span class=\"synConstant\">'udp4'</span> <span class=\"synIdentifier\">}</span>);\n\nsocket.on(<span class=\"synConstant\">'message'</span>, (msg, rinfo) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> req = StunMessage.createBlank();\n\n  <span class=\"synComment\">// if msg is valid STUN message</span>\n  <span class=\"synStatement\">if</span> (req.loadBuffer(msg)) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// if STUN message has BINDING_REQUEST as its type</span>\n    <span class=\"synStatement\">if</span> (req.isBindingRequest()) <span class=\"synIdentifier\">{</span>\n      console.log(<span class=\"synConstant\">'REQUEST'</span>, req);\n\n      <span class=\"synStatement\">const</span> res = req\n        .createBindingResponse(<span class=\"synConstant\">true</span>)\n        .setXorMappedAddressAttribute(rinfo);\n      console.log(<span class=\"synConstant\">'RESPONSE'</span>, res);\n      socket.send(res.toBuffer(), rinfo.port, rinfo.address);\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\nsocket.bind(55555);\n</pre><p>サーバーなのでポートを`bind()`してる。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>のメッセージを受けると`RemoteInfo`がついてるので、それを送り返すだけの簡単なお仕事。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>も<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>も<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>も、この用途に関しては何の属性もつけてこない模様。</p><p>1つ注意するとすれば、`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`でSTUNサーバーを立ててしまうと、そもそも`host`のネットワークと一緒やんけ！ってことで無視されてSDPに載らないです。</p>\n\n</div>\n<div class=\"section\">\n    <h3>その他の用途</h3>\n    <p>RFC5389の範囲をこえた用途の一例 = RFC8445に書いてある例を書いとく。</p><p>だいたいが収集された`candidate`から最終的な経路が選ばれて接続を確立したあとに必要な用途で、Keep AliveとかConsent FreshnessとかConnectivity Checksとか定義されてる。</p><p>ちなみにこれらの挙動はテキトーなSDPをでっちあげてブラウザに渡すと確認できて、新たな属性にも出会えます・・。</p><p>属性の名前と、出自<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>はこんな感じ。</p>\n\n<ul>\n<li>RFC5389: USERNAME</li>\n<li>RFC5389: MESSAGE-INTEGRITY</li>\n<li>RFC8445: PRIORITY</li>\n<li>RFC8445: USE-CANDIDATE</li>\n<li>RFC8445: ICE-CONTROLLING</li>\n<li>RFC5389: FINGERPRINT</li>\n<li>NETWORK-INFO\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>限定で、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>にはなってない属性</li>\n<li><a href=\"https://tools.ietf.org/html/draft-thatcher-ice-network-cost-00\">draft-thatcher-ice-network-cost-00 - ICE Network Cost: Dynamically selecting ICE candidate pairs based on relative cost of network interfaces</a></li>\n</ul></li>\n</ul><p>いやー奥が深まりますね！</p><p>STUN = RFC5389を実装するためには、そもそもの用途を規定するRFC8445を理解しないといけないという。</p>\n\n</div>\n<div class=\"section\">\n    <h3>webrtc-stunについて</h3>\n    <p>いちおうWebRTCにおけるSTUNの用途の必要なところだけを実装するつもりで、この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>を`webrtc-stun`と名付けて開発してたんですが、上述の通りRFC5389だけではそれをカバーできてないです。</p><p>なので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>もこの構成がベストかどうかまだ判断しかねる状態で、他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>を実装してたらまたまるっと書き直すとかも普通にあるのでは・・？という感じ。</p><p>この先を追って実装するかはまだ未定ですが、なんか進捗あればまた書きます。</p><p>やるとしたらロードマップはこんな感じ。</p>\n\n<ul>\n<li>[x] RFC5389: candidate収集に必要な部分</li>\n<li>[ ] RFC5389: その他の属性\n<ul>\n<li>いま4/10だけ実装した</li>\n</ul></li>\n<li>[ ] さらに他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>で拡張されてるもの\n<ul>\n<li>全容は不明</li>\n</ul></li>\n</ul><p>割と長い道のりですよね・・！</p><p>ちなみにこのへん全部実装してあるのが、この間まで読んでたNodeRTCのSTUN実装です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/stun\">GitHub - nodertc/stun: Low-level Session Traversal Utilities for NAT (STUN) server</a></p>\n\n    </blockquote>\n<p>まじすごい。</p>\n\n</div>"
}
