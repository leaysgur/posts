{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.4",
  "html": "<p>Part.1はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2018/11/26/174220\">NodeJS&#x88FD;WebRTC DataChannel&#x3001;NodeRTC&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; Part.1 - console.lealog();</a></p>\n\n    </blockquote>\n<p>この記事では、前回から読んでるDTLS部分の後編を。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>前編のおさらい</h3>\n    \n<ul>\n<li>DTLSのソケットがつながる過程を追ってた\n<ul>\n<li>`Socket`がその本丸</li>\n</ul></li>\n<li>その`constructor()`でやってたことを追ってたのが前回\n<ul>\n<li>`ClientSession`および登場人物がいっぱいいた</li>\n<li>追えてない残りが`pipeline()`で`Stream`をまとめてること</li>\n</ul></li>\n</ul><p>具体的にはこのコード。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pipeline(writer, socket, onerror);\npipeline(socket, isdtls, decoder, reorder, defrag, protocol, onerror);\n</pre><p>そもそもDTLSの層は初期化の時点で渡してる`unicast`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットの土管でしかない。</p>\n\n<ul>\n<li>この`unicast`ソケットを`pipe()`か`on('data')`してデータを受け取って</li>\n<li>この`unicast`ソケットに大して`write()`してる</li>\n</ul><p>この2箇所がどこかにあるはずで、それがこの`pipeline()`ってわけ。</p><p>最初の`pipeline()`では`Writable`として、後者のは`Readable`として使われてることになる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`pipeline(writer, socket, onerror);`</h3>\n    <p>変数名が違うけど、`writer`は`new Sendor(session)`なので、クラスとしての`Sender`を追えば良さそう。</p>\n\n<div class=\"section\">\n    <h4>class: Sendor</h4>\n    \n<ul>\n<li>extends `Readable`\n<ul>\n<li>しかし`_read()`は空っぽ</li>\n<li>代わりにどこかで`this.push()`してるはず</li>\n<li>実態はおそらく`constructor()`で受け取った`session`からデータを供給する存在</li>\n</ul></li>\n<li>`this.push()`してるのは主に`_bufferDrain()`\n<ul>\n<li>これは`output.record.on('data')`で呼ばれる</li>\n</ul></li>\n<li>`output.record`\n<ul>\n<li><a href=\"https://github.com/reklatsmasters/binary-data\">GitHub - reklatsmasters/binary-data: Declarative encoder/decoder of various binary data.</a> の`createEncodeStream()`</li>\n<li>これの`write()`でデータが流れる</li>\n</ul></li>\n<li>`sendRecord()`という関数がそれ\n<ul>\n<li>各所で呼ばれてるが、メインは`_applicationData()`</li>\n<li>これは`session.on('send:appdata')`で呼ばれる</li>\n</ul></li>\n<li>これが`emit()`されるのは、`session.sendMessage()`\n<ul>\n<li>そしてこれは`socket._write()`すると呼ばれる</li>\n</ul></li>\n</ul><p>つまり・・・、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// socket from socket.js</span>\nsocket._write()\n  session.sendMessage()\n    <span class=\"synIdentifier\">this</span>.emit(<span class=\"synConstant\">'send:appdata'</span>)\n\n<span class=\"synComment\">// writer from sender.js</span>\nsession.on(<span class=\"synConstant\">'send:appdata'</span>)\n  <span class=\"synIdentifier\">this</span>.sendRecord()\n    <span class=\"synIdentifier\">this</span>.output.record.write(record);\n\n<span class=\"synIdentifier\">this</span>.output.record.on(<span class=\"synConstant\">'data'</span>)\n  <span class=\"synIdentifier\">this[</span>_bufferDrain<span class=\"synIdentifier\">]</span>(packet)\n    <span class=\"synIdentifier\">this</span>.push(packet)\n</pre><p>これで回り回って、`pipeline()`につないだ次の`socket`（つまり接続ピア）にデータが流れてくことになる。</p><p>最初に呼ばれるであろう`socket._write()`はこうなってた。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>_write(chunk, encoding, callback) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (<span class=\"synIdentifier\">this[</span>_session<span class=\"synIdentifier\">]</span>.isHandshakeInProcess) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this[</span>_queue<span class=\"synIdentifier\">]</span>.push(chunk);\n    <span class=\"synIdentifier\">this</span>.once(<span class=\"synConstant\">'connect'</span>, () =&gt; callback());\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this[</span>_session<span class=\"synIdentifier\">]</span>.sendMessage(chunk);\n    callback();\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>ハンドシェイクが終わるまでキューに貯めてる。</p><p>`Writable._write()`は、1つ上の層（おそらくSCTPの実装）で使われるてるはず。<br />\n`socket.write()`的な感じで。</p>\n\n</div>\n<div class=\"section\">\n    <h4>binary-data</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/reklatsmasters/binary-data\">GitHub - reklatsmasters/binary-data: Declarative encoder/decoder of various binary data.</a></p>\n\n    </blockquote>\n<p>作者謹製のライブラリで、頻繁に使われてるので軽く見ておく。</p>\n\n<ul>\n<li>バイナリに対して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE\">スキーマ</a>を定義できる</li>\n<li>それを`encode()` / `decode()`することで、バイナリを意識しないでいい\n<ul>\n<li>`Transform`ストリームも作れる</li>\n</ul></li>\n</ul><pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> protocol = <span class=\"synIdentifier\">{</span>\n  type: uint8,\n  value: array(string(<span class=\"synStatement\">null</span>), uint8),\n<span class=\"synIdentifier\">}</span>;\n<span class=\"synStatement\">const</span> message = <span class=\"synIdentifier\">{</span>\n  type: 12,\n  value: <span class=\"synIdentifier\">[</span><span class=\"synConstant\">'foo'</span>, 1<span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>;\n\nsocket.on(<span class=\"synConstant\">'message'</span>, msg =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> packet = decode(msg, protocol);\n<span class=\"synIdentifier\">}</span>);\n\nsocket.write(encode(msg, protocol));\n</pre><p>まあ確かにこういうの欲しいよねーという感じ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>`pipeline(socket, isdtls, decoder, reorder, defrag, protocol, onerror);`</h3>\n    <p>もう1つの`pipeline()`がコレ。</p>\n\n<ul>\n<li>先頭の`socket`は`session.on('data')`で`this.push()`</li>\n<li>`isdtls`から`defrag`までは`Transform`ストリーム</li>\n<li>`isdtls`\n<ul>\n<li>STUNの時にもあった「パケットの先頭のbyteを見て、DTLSのそれかどうか」を判別するやつ</li>\n</ul></li>\n<li>`decorder` / `reorder` / `defrag`\n<ul>\n<li>`filter/*.js`にあるやつら</li>\n<li>内容は割愛するけど、おそらく名前どおり、暗号を解いて送信順序を整えて・・みたいなことをしてる</li>\n</ul></li>\n<li>`protocol`\n<ul>\n<li>`fsm/protocol.js`</li>\n</ul></li>\n</ul><p>目的地である`Writable`な`protocol`は次で読む。</p>\n\n<div class=\"section\">\n    <h4>class: Protocol12ReaderClient</h4>\n    <p>変数`protocol`の中身。</p>\n\n<ul>\n<li>extends `Writable`\n<ul>\n<li>`constructor()`で`session`を受け取る</li>\n</ul></li>\n<li>`session.handshakeProtocolReaderState`で挙動が変わる</li>\n<li>`_write()`で最終的にデータを流すかどうか判断してる</li>\n<li>疎通後のデータは`this.session.packet()`で流される\n<ul>\n<li>`session.emit('data')`</li>\n</ul></li>\n</ul><p>これがまたおそらく次に読むSCTPのどこかで`on('data')`されてるはず・・。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>そもそも</h3>\n    <p>コードを読みながらいくつか疑問があった。</p>\n\n<ul>\n<li>NodeJSには`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/tls\">tls</a>`のモジュールが標準で存在するけど、それは使わない？</li>\n<li>そもそも自前で実装するしかない？</li>\n</ul><p>で、それを調べてたときに見つかったIssueをご紹介。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodejs/node/issues/2398\">DTLS Discussion &middot; Issue #2398 &middot; nodejs/node &middot; GitHub</a></p>\n\n    </blockquote>\n<p>要約すると、</p>\n\n<ul>\n<li>NodeJSのコアでDTLSを実装したいよね</li>\n<li>でも実装するの大変よね</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TLS\">TLS</a>とDTLSって微妙に違うくてどうしたものか\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>はStreamベースでもないし</li>\n<li>`dgram`にも手をいれないといけないかも</li>\n<li>実装するならEventEmitterベースかな</li>\n</ul></li>\n<li>Nodeのinternalなレイヤーで、`TLSWrap`みたいなの作るのが筋良い？</li>\n<li>そもそもNodeよりも`libuv`のレイヤーのほうが嬉しくない？\n<ul>\n<li>`libuv-extra`っていうア<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C7%A5%A2\">イデア</a>はどうだろう</li>\n</ul></li>\n<li>ア<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C7%A5%A2\">イデア</a>出すしレビューはできると思うけど、実装は重すぎるからできそうにない\n<ul>\n<li>という人がほとんど</li>\n</ul></li>\n<li>〜それから半年〜</li>\n<li>NodeRTCの作者: DTLSを実装してみたよ\n<ul>\n<li>しかしコミュニティからの反応なし</li>\n</ul></li>\n<li>議論止まってるからCloseするね <- いまここ</li>\n</ul><p>という感じで、現時点だと自力で実装するしかないという結論に。</p>\n\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    \n<ul>\n<li>`Stream`まわりに慣れ親しんでないと書けないし読めない\n<ul>\n<li>特に`Duplex`はどっち方向の処理に関するコードなのか読み分けないと厳しい</li>\n</ul></li>\n<li>コードコメントの有るところ無いところあるので、仕様を知らずに読むのまじつらい\n<ul>\n<li>型があればエディタで補完しつつ読めて多少マシ</li>\n</ul></li>\n<li>既にだいぶ重いけど、100％の仕様を満たしてない予感もする\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TLS\">TLS</a>を実装するとはそういうこと</li>\n</ul></li>\n<li>まあでもこれだけの行数で実装できるなら、思ってたよりかはマシ</li>\n</ul><p>次はSCTPなんですが、毛色は違うけどDTLS以上に重い実装な予感がしてて震えてる！</p>\n\n</div>"
}
