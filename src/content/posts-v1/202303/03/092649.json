{
  "title": "ブラウザで動くSQLite alternativesとしてのLovefield",
  "html": "<p>タイトルはさておき、Lovefieldという<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQL\">SQL</a>ライクな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が使えるライブラリがあって、個人的に便利だったので。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3 id=\"Lovefieldとは\">Lovefieldとは</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/google/lovefield\">https://github.com/google/lovefield</a></p>\n\n    </blockquote>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a>製で</li>\n<li>Pure JSの</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%ED%A5%B9%A5%D6%A5%E9%A5%A6%A5%B6\">クロスブラウザ</a>ーで動作する</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQL\">SQL</a>ライクな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が使えるリレーショナルデータベース</li>\n</ul><p>っていうライブラリ。</p><p>実績としては<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Gmail\">Gmail</a>で使われてたらしい。（現在もそうなのかは不明）</p>\n\n    <blockquote>\n        <p>Is Lovefield production quality?<br />\nYes. As of May 2016, Inbox by <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GMail\">GMail</a> heavily relies on Lovefield to perform complex client-side structural data queries.<br />\n<a href=\"https://github.com/google/lovefield/blob/master/docs/FAQ.md#is-lovefield-production-quality\">https://github.com/google/lovefield/blob/master/docs/FAQ.md#is-lovefield-production-quality</a></p>\n\n    </blockquote>\n<p>（コードが書かれたのは主に2015年頃らしいなので、今さらも今さらなネタではある。けど、そもそも日本でそんなに話題になってなかった気がする？）</p>\n\n<div class=\"section\">\n    <h4 id=\"Public-archiveだが\">Public archiveだが</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AB%A5%A4%A5%D6\">アーカイブ</a>状態になってるやん！って思いますよね？私は思いました。</p><p>これも中の人によると、</p>\n\n    <blockquote>\n        <p>Lovefield is under long-term maintenance but there will be no new features (i.e. feature freeze). G-Mail is using it and as long as G-Mail is still using it we'll keep supporting it. There are not many updates because Lovefield has very few bugs (G-Mail only managed to find 7 bugs during their whole usage, and they are all fixed of course).<br />\n<a href=\"https://github.com/google/lovefield/issues/266#issuecomment-678883485\">https://github.com/google/lovefield/issues/266#issuecomment-678883485</a></p>\n\n    </blockquote>\n<p>という感じで、機能追加の予定がないから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AB%A5%A4%A5%D6\">アーカイブ</a>ってだけで、バグってるとかメンテされてないとかそういうわけではないとのこと。</p><p>（このコメントは2020年なので、しれっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Gmail\">Gmail</a>は2020年でもLovefieldを使ってた情報が更新されてる）<br />\n<br />\n</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"Lovefield-TS\">Lovefield-TS</h3>\n    <p>さっきのコメントにもあるけど、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a>としてのLovefieldの開発は終わってるけど、中の人が個人的にTypeScriptにポートしたリライト版がある。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/arthurhsu/lovefield-ts\">https://github.com/arthurhsu/lovefield-ts</a></p>\n\n    </blockquote>\n<p>サポートブラウザがよりモダンに限定されてたりNode.jsでも動くようになってたり、本家とは微妙に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が変わったりしてるらしいけど、今から使うならこっちでよさそう。</p><p>というわけで、`lovefield-ts`をnpmからいつもどおりインストールして使えばよい。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"モチベーション\">モチベーション</h3>\n    <p>そもそもなぜブラウザで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQL\">SQL</a>？ってところに関しては、まあそうしたい理由があったからってだけなので割愛するとして。</p><p>最近なら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQLite\">SQLite</a>のWASM版を動かすっていう選択肢もあるし、Lovefieldの他にも似たようなライブラリはある。そんな中での差別化ポイントとしては、やはり軽いことと依存がないってところ。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQLite\">SQLite</a>のWASM版はbr圧縮でも最低300KBくらいかかるし、他のライブラリたちもそれなりに重い。インメモリでだけ使いたいのに、そう設定してもIndexedDB（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>のPrivateモードで使えない）が必要だったりと、いまいちハマらなかった。その点Lovefield-TSだと依存なしで最大50KB（Tree-shakingされたらもっと小さい）で済む。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQLite\">SQLite</a>互換な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が必要というよりは、単に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RDB\">RDB</a>ライクな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>であればなんでもよかった。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"基本的な使い方\">基本的な使い方</h3>\n    <p>Lovefield本家はドキュメントがとにかくわかりにくい（個人の感想です）しコードの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>も古いので、Lovefield-TSの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>の`docs`配下を参照するのがもっともよいかと。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/arthurhsu/lovefield-ts/blob/master/docs/index.md\">https://github.com/arthurhsu/lovefield-ts/blob/master/docs/index.md</a></p>\n\n    </blockquote>\n<p>いちおう最低限のコードも載せておくと。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> schema<span class=\"synStatement\">,</span> Type<span class=\"synStatement\">,</span> DataStoreType <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;lovefield-ts/dist/es6/lf&quot;</span>\n\n<span class=\"synComment\">// 1. Create tables</span>\n<span class=\"synType\">const</span> builder <span class=\"synStatement\">=</span> schema.create<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;my-db&quot;</span><span class=\"synStatement\">,</span> <span class=\"synConstant\">1</span><span class=\"synStatement\">);</span>\nbuilder\n  .createTable<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;items&quot;</span><span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;id&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;title&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">,</span> Type.NUMBER<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;url&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addNullable<span class=\"synStatement\">(</span><span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;url&quot;</span><span class=\"synIdentifier\">]</span><span class=\"synStatement\">)</span>\n  .addPrimaryKey<span class=\"synStatement\">(</span><span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;id&quot;</span><span class=\"synIdentifier\">]</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// 2. Connect to instance(default is `INDEXED_DB`)</span>\n<span class=\"synType\">const</span> db <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> builder.connect<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span> storeType: DataStoreType.MEMORY <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// 3. Insert data</span>\n<span class=\"synType\">const</span> items <span class=\"synStatement\">=</span> db.getSchema<span class=\"synStatement\">()</span>.table<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;items&quot;</span><span class=\"synStatement\">);</span>\n<span class=\"synType\">const</span> itemsRows <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">for</span> <span class=\"synStatement\">(</span><span class=\"synType\">const</span> data <span class=\"synStatement\">of</span> DATA<span class=\"synStatement\">)</span> <span class=\"synIdentifier\">{</span>\n  itemsRows.push<span class=\"synStatement\">(</span>items.createRow<span class=\"synStatement\">(</span>data<span class=\"synStatement\">));</span>\n<span class=\"synIdentifier\">}</span>\n<span class=\"synStatement\">await</span> db.insert<span class=\"synStatement\">()</span>.into<span class=\"synStatement\">(</span>items<span class=\"synStatement\">)</span>.values<span class=\"synStatement\">(</span>itemsRows<span class=\"synStatement\">)</span>.exec<span class=\"synStatement\">();</span>\n\n<span class=\"synComment\">// 4. Query</span>\n<span class=\"synType\">const</span> rows <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> db\n  .select<span class=\"synStatement\">(</span>\n    items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;title&quot;</span><span class=\"synStatement\">),</span>\n    items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">)</span>\n  <span class=\"synStatement\">)</span>\n  .<span class=\"synStatement\">from(</span>items<span class=\"synStatement\">)</span>\n  .where<span class=\"synStatement\">(</span>items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">)</span>.gt<span class=\"synStatement\">(</span><span class=\"synConstant\">4</span><span class=\"synStatement\">))</span>\n  .exec<span class=\"synStatement\">()</span>\n  .then<span class=\"synStatement\">((</span>rows<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synComment\">/** @type {{ title: string; count: number }[]} */</span> <span class=\"synStatement\">(</span>rows<span class=\"synStatement\">));</span>\n</pre><p>という感じ。直感的でよい。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"気になったところ\">気になったところ</h3>\n    \n<div class=\"section\">\n    <h4 id=\"importまわり\">importまわり</h4>\n    <pre class=\"code\" data-lang=\"\" data-unlink>├── LICENSE\n├── README.md\n├── dist\n│   ├── es5\n│   │   ├── lf.d.ts\n│   │   ├── lf.d.ts.map\n│   │   ├── lf.js\n│   │   └── lf.js.map\n│   ├── es6\n│   │   ├── lf.d.ts\n│   │   ├── lf.d.ts.map\n│   │   ├── lf.js\n│   │   └── lf.js.map\n│   └── lf.ts\n├── index.js\n└── package.json</pre><p>npmへはこういうファイル構成で配布されてて、`from \"lovefield-ts\"`で`import`すると全部いりの`dist/es5/lf`が降ってくるようになってる。</p><p>なのでTree-shakingのためには、`from \"lovefield-ts/dist/es6/lf\"`ってやるか、`\"lovefield-ts/dist/lf\"`のTSを直で参照してこっちで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>するかになる。</p><p>このへんの挙動はバンドラの設定とかでも微妙に変わるはずで、なんしか試行錯誤が少し必要になってなんだかな・・ってちょっとなった。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"型のサポート\">型のサポート</h4>\n    <p>TSで書かれてるけど、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B8%A5%A7%A5%CD%A5%EA%A5%AF%A5%B9\">ジェネリクス</a>で定義されてない<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が結構あって、利用者サイドの型を楽につけられないことが多かった。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// これとか</span>\nitems.createRow<span class=\"synStatement\">(</span>data<span class=\"synStatement\">);</span> <span class=\"synComment\">// Table.createRow(value?: object | undefined): Row</span>\n\n<span class=\"synComment\">// これとか</span>\n<span class=\"synType\">const</span> rows <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> db\n  .select<span class=\"synStatement\">()</span>\n  .<span class=\"synStatement\">from(</span>items<span class=\"synStatement\">)</span>\n  .exec<span class=\"synStatement\">();</span> <span class=\"synComment\">// QueryBuilder.exec(): Promise&lt;unknown&gt;</span>\n</pre><p>別にキャストすればいいけど、ちょっと物足りない。あとは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AB%A5%E9%A5%E0%CC%BE\">カラム名</a>の入力補完も効かない。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"あくまでSQLライク\">あくまで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQL\">SQL</a>ライク</h4>\n    <p>そこまで使い込んだわけではないけど、いわゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SQL\">SQL</a>でいうアレ、できないの？ってなったところ。</p>\n\n<ul>\n<li>`JOIN`は`INNER`と`LEFT OUTER`だけ</li>\n<li>`DISTINCT`で対象にできるカラムが1つだけ</li>\n<li>`HAVING`はサポートされてない</li>\n</ul><p>でもまあこれくらいかも。ヘビーなクエリは書いてないので。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"おわりに\">おわりに</h3>\n    <p>ここで書いてるほかにも、</p>\n\n<ul>\n<li>import/export</li>\n<li>バージョンニングと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%A4%A5%B0%A5%EC%A1%BC%A5%B7%A5%E7%A5%F3\">マイグレーション</a></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B6%A5%AF%A5%B7%A5%E7%A5%F3\">トランザクション</a></li>\n</ul><p>などなど、いろいろサポートされてるので、また別の機会で使ってみたい一品だったという話でした。</p>\n\n</div>"
}
