{
  "title": "JavaScriptのTypedArrayについて",
  "html": "<p>調べたのでメモ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>TypedArray</h3>\n    \n    <blockquote>\n        <p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\">TypedArray - JavaScript | MDN</a></p>\n\n    </blockquote>\n<p>いわゆる型付き配列。<br />\n通常の配列と違って型が固定できる分、内部的に最適化がしやすいとか諸々で住み分けられてる。</p><p>そういう意味で一般的なフロントエンドの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>コードで出てくることはそうそうない。</p><p>たとえばWebAudioとか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Canvas\">Canvas</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WebGL\">WebGL</a>とか、いわゆるバイナリに近い処理をブラウザでやる場合に必要になる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>たち。<br />\nNode.jsだと、`Buffer`っていうそれ用のクラスがあったりする。</p>\n\n</div>\n<div class=\"section\">\n    <h3>種類</h3>\n    \n<ul>\n<li>Int8Array</li>\n<li>Uint8Array</li>\n<li>Uint8ClampedArray</li>\n<li>Int16Array</li>\n<li>Uint16Array</li>\n<li>Int32Array</li>\n<li>Uint32Array</li>\n<li>Float32Array</li>\n<li>Float64Array</li>\n<li>BigInt64Array</li>\n<li>BigUint64Array</li>\n</ul><p>というように、並ぶアイテムの型によって名前が決まる。</p><p>Uint8の場合、符号なし8bit(1byte)なので、0から255までしか扱えない。<br />\n格納したいアイテムによって、使う種類を選ぶもの。</p><p>`Uint8ClampedArray`は特別なやつで、`255`より大きい値をいれると`255`に、`0`未満は`0`にしてくれるやつ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ArrayBuffer</h3>\n    <p>で、この`TypedArray`たちは、内部的なデータ構造としてそれぞれ`ArrayBuffer`を持つ。</p><p>というかデータの実態はこの`ArrayBuffer`であり、その見てくれ表現として各`TypedArray`がいる感じ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> f32 = <span class=\"synStatement\">new</span> Float32Array(<span class=\"synIdentifier\">[</span>0, 1, 2, 3, 4, 5, 6, 7<span class=\"synIdentifier\">]</span>);\nf32.length; <span class=\"synComment\">// 8</span>\n\nf32.buffer; <span class=\"synComment\">// ArrayBuffer(32)</span>\nf32.byteLength; <span class=\"synComment\">// 32</span>\n</pre><p>で、共通した`ArrayBuffer`を持つということで、各`TypedArray`は実は相互変換ができる。<br />\nつまり`Uint8Array([0, 1])`と`new Uint16Array([256])`は同等の`ArrayBuffer`を持つということ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> uint8 = <span class=\"synStatement\">new</span> Uint8Array(<span class=\"synIdentifier\">[</span>0, 1<span class=\"synIdentifier\">]</span>);\n<span class=\"synStatement\">const</span> uint16 = <span class=\"synStatement\">new</span> Uint16Array(uint8.buffer);\n<span class=\"synStatement\">new</span> Uint8Array(uint16.buffer); <span class=\"synComment\">// Uint8Array([0, 1]);</span>\n</pre><p>符号とかレンジとかはよしなになるっぽい。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Uint8Array(7) [0, 6, 255, 0, 1, 255, 2]</span>\n<span class=\"synStatement\">new</span> Uint8Array(\n  <span class=\"synStatement\">new</span> Int8Array(<span class=\"synIdentifier\">[</span>-256, -250, -1, 0, 1, 255, 258<span class=\"synIdentifier\">]</span>).buffer\n);\n</pre><p>ただし要<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%C7%BF%F4\">素数</a>が足りない場合はエラーになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Uncaught RangeError: byte length of Int16Array should be a multiple of 2</span>\n<span class=\"synStatement\">new</span> Int16Array(<span class=\"synStatement\">new</span> Int8Array(<span class=\"synIdentifier\">[</span>0, 1, 2<span class=\"synIdentifier\">]</span>).buffer);\n</pre>\n</div>\n<div class=\"section\">\n    <h3>その裏側が知りたい</h3>\n    <p>`Uint8Array([0, 1])`が`Int16Array([256])`と相互変換できるのは良いとして、この`256`ってどこから来た？って思ったので調べた。</p>\n\n<ul>\n<li>`256`を2進数に\n<ul>\n<li>`(256).toString(2)`は、`100000000`</li>\n</ul></li>\n<li>`100000000`は、バイト列にすると`00000001|00000000`</li>\n<li>それが`00000000|00000001`となって（順序が逆になる）</li>\n<li>つまり`0`と`1`に</li>\n</ul><p>で、このバイト列がメモリ上で、CPU上で、どう扱われてるかにトリックがある。</p><p>この例でしれっと順序が逆になるって書いたのは、リ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%EB%A5%A8%A5%F3\">トルエン</a>ディアン（LE）という方式を採用してバイトを並べるから。<br />\nいまこのコードを実行してるこのマシンが、そうなってるから。</p>\n\n    <blockquote>\n        <p><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Endianness\">Endianness - MDN Web Docs Glossary: Definitions of Web-related terms | MDN</a></p>\n\n    </blockquote>\n<p>ビッグ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%C7%A5%A3%A5%A2%A5%F3\">エンディアン</a>（BE）を採用してる環境だと、見た通りの順序で読み出される。</p><p>いや、そっちのほうがわかりやすいやん！って思ったけど、CPUの処理的な都合では、LEのほうに分があったりするらしい。<br />\nただわかりやすいのも確かなので、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>などによっては絶対BEでやりとりすると決まってたりするらしい。</p><p>もう1つ例として、`Int32Array([50462976])`が`Int8Array`になる場合を見ておく。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 10進数から2進数にしてみる</span>\n<span class=\"synType\">Number</span>(50462976).toString(2); <span class=\"synComment\">// 11000000100000000100000000</span>\n\n<span class=\"synComment\">// バイト区切り（0埋め）</span>\n00000011|00000010|00000001|00000000\n\n<span class=\"synComment\">// LEなので</span>\n00000000|00000001|00000010|00000011\n\n<span class=\"synComment\">// 10進数</span>\n0, 1, 2, 3\n</pre><p>というわけで、`Int8Array([0, 1, 2, 3])`になる。</p><p>どっちの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%C7%A5%A3%A5%A2%A5%F3\">エンディアン</a>を採用してるかはこういうコードでも調べられる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> isBE = <span class=\"synStatement\">new</span> Uint8Array(<span class=\"synStatement\">new</span> Uint32Array(<span class=\"synIdentifier\">[</span>0x12345678<span class=\"synIdentifier\">]</span>).buffer)<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span> === 0x12;\n<span class=\"synStatement\">const</span> isLE = <span class=\"synStatement\">new</span> Uint8Array(<span class=\"synStatement\">new</span> Uint32Array(<span class=\"synIdentifier\">[</span>0x12345678<span class=\"synIdentifier\">]</span>).buffer)<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span> === 0x78;\n</pre>\n</div>\n<div class=\"section\">\n    <h3>DataView</h3>\n    \n    <blockquote>\n        <p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView\">DataView - JavaScript | MDN</a></p>\n\n    </blockquote>\n\n<ul>\n<li>配列のインデックスで読み書きするの大変</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%C7%A5%A3%A5%A2%A5%F3\">エンディアン</a>を考慮しつつ読み書きするのも大変</li>\n</ul><p>・・ということで存在するクラス。</p><p>`getInt8()`とか`setFloat32()`とか任意の単位で`ArrayBuffer`を操作できるやつ。</p><p>デフォルトでBEを採用してて、各メソッドの引数でLEを指定できるようになってる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> buffer = <span class=\"synStatement\">new</span> ArrayBuffer(2);\n<span class=\"synStatement\">new</span> DataView(buffer).setInt16(0, 256, <span class=\"synConstant\">true</span> <span class=\"synComment\">/* littleEndian */</span>);\n</pre><p>Node.jsでいうところの`Buffer`みたいな存在。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/03/05/125001\">NodeJS&#x3067;Buffer&#x3092;&#x8AAD;&#x307F;&#x53D6;&#x308B; - console.lealog();</a></p>\n\n    </blockquote>\n<p>まぁNode.jsだと`Buffer`も`DataView`もどっちも生えてるけど・・。</p>\n\n</div>"
}
