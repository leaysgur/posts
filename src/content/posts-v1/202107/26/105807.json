{
  "title": "miniflare のコードを読む",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/mrbbot/miniflare\">https://github.com/mrbbot/miniflare</a></p>\n\n    </blockquote>\n<p>Cloudflare Workers（以下、CFW）相当の実行環境をローカルで再現できるアレです。</p><p>そんなんは公式が出してほしいな〜と思い続けてはや1年弱、いつまで経っても出てこない！<br />\nというわけで、コード読んでみたシリーズです。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>そもそも、なぜローカルで動かしたいのか</h3>\n    <p>これはひとえに、現状のCFWはローカルで開発できないから。</p><p>いちおう本家の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>に`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev`という開発用のコマンドはあるけど、インターネットにプライベートなやつがデプロイされてそれを`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`にトンネルするだけで、実質ローカルではない。</p><p>そのうえ、</p>\n\n<ul>\n<li>（インターネットに上げるからか）動作も速くない</li>\n<li>そしてとにかくクラッシュする</li>\n<li>変更も反映されたりされなかったり謎</li>\n<li>そのくせしっかり課金対象（無料枠の圧迫）</li>\n</ul><p>という感じで、あまり快適な開発体験とは言えないかなーというのが正直なところ。<br />\nもちろんあらゆるものが本番想定のインフラで動かせるというところにやや便利さはあるけど・・。</p><p>で、なんとかしたいなーとは思うものの、CFWの実行環境は「V8 Isolate + Cloudflare独自<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>」というちょっと特殊な感じになっていて、もちろんNodeでそのまま動くわけもなく。<br />\nってなところで、力ずくでそれをやり遂げてNodeで動いちゃってるこの`miniflare`はすごいのである！</p><p>というわけで、読んでいきます。<br />\nコードはTypeScriptで書かれてるので、気合さえあれば読めるやつ。</p><p>この記事を書いた時点のバージョンは`1.3.2`でした。</p>\n\n</div>\n<div class=\"section\">\n    <h3>外観</h3>\n    <p>`miniflare`は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>としても使えるほか、プログラムからも利用できる。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>なら`miniflare worker.js`のようにするし、プログラムからならこのように。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> Miniflare <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;miniflare&quot;</span>;\n\n<span class=\"synStatement\">const</span> mf = <span class=\"synStatement\">new</span> Miniflare(<span class=\"synIdentifier\">{</span>\n  script: `\n  addEventListener(<span class=\"synConstant\">&quot;fetch&quot;</span>, (<span class=\"synStatement\">event</span>) =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">event</span>.respondWith(<span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Hello Miniflare!&quot;</span>));\n  <span class=\"synIdentifier\">}</span>);\n  `,\n<span class=\"synIdentifier\">}</span>);\n<span class=\"synStatement\">const</span> res = await mf.dispatchFetch(<span class=\"synConstant\">&quot;http://localhost:8787/&quot;</span>);\nconsole.log(await res.text()); <span class=\"synComment\">// Hello Miniflare!</span>\n</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>は結局ラッパーなはずで、`Miniflare`クラスのために便利な初期設定をしてるだけと予想。</p>\n\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a></h3>\n    <p>まず、`package.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/json\">json</a>`の`bin`に、`src/bootstrap`へのrefがあった。</p>\n\n<div class=\"section\">\n    <h4>bootstrap.ts</h4>\n    <p>`--experimental-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>-modules`をつけて、`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>.ts`をキックしてるだけ。</p><p>このフラグを有効にすると、Nodeの`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>`モジュールから、</p>\n\n<ul>\n<li>`Module`</li>\n<li>`SourceTextModule`</li>\n<li>`SyntheticModule`</li>\n</ul><p>この3つがさらに使えるようになるとのこと。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodejs.org/api/vm.html#vm_class_vm_module\">VM (executing JavaScript) | Node.js v16.5.0 Documentation</a></p>\n\n    </blockquote>\n<p>これらは、CFWのコードをES Modulesの形式で書くスタイルの場合に必要らしい。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>.ts</h4>\n    \n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>としてのI/Oは、`yargs`を使ってる\n<ul>\n<li>特別な処理はなく、引数パースしてるだけ</li>\n</ul></li>\n<li>`export default`はおそらくテスト用</li>\n<li>`if (module === require.main)`のブロックが本題\n<ul>\n<li>`Miniflare`クラスを、パースしたオプションで初期化</li>\n<li>リク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トを処理するHTTP(S)のサーバーを立てる</li>\n<li>実行時に最新バージョンをnpmに確認して、アップデートあるよって知らせる</li>\n</ul></li>\n</ul><p>というわけで、想定どおり。メインはやはり本体の`index.ts`へ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>本体</h3>\n    \n<ul>\n<li>`Miniflare`クラスがいるところ\n<ul>\n<li>それ以外にも`export`されてるけどとりあえず無視</li>\n</ul></li>\n<li>主要そうなプロパティ\n<ul>\n<li>`#modules`</li>\n<li>`#watcher`</li>\n<li>`#sandbox`</li>\n<li>`#environment`</li>\n</ul></li>\n<li>`#httpRequestListener()`\n<ul>\n<li>ローカルに立てるサーバーのハンドラ</li>\n<li>CFW独自の`Request`オブジェクトも、`@mrbbot/node-fetch`で用意されててさすがだった</li>\n<li>ScheduledEventか、FetchEventかを判定</li>\n<li>前者の場合は、`dispatchScheduled()`で処理</li>\n<li>後者の場合は、`dispatchFetch()`で処理</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>Modules, Sandbox, Environment</h4>\n    \n<ul>\n<li>Moduleは、`Miniflare`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タで`#modules`に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A5%A4\">アサイ</a>ンされるものたち</li>\n<li>CFWの実行環境を構成する要素を、モジュールという名で関心ごとに実装してある</li>\n<li>たとえば、\n<ul>\n<li>`EventsModule`の場合、グローバルな`addEventListener()`とか、`FetchEvent`とか</li>\n<li>`StandardsModule`の場合、`fetch()`とか`crypto`とか</li>\n</ul></li>\n<li>Moduleごとに、SandboxとEnvironmentを用意するようになってる</li>\n<li>Sandboxは、Workerのグロー<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%EB%A5%B9\">バルス</a>コープそのもの\n<ul>\n<li>どこのWorkerでもすべからく同じもの</li>\n</ul></li>\n<li>Environmentは、シークレットや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a>など\n<ul>\n<li>人それぞれで違うかもしれないもの</li>\n<li>KVなどもこっち扱い</li>\n</ul></li>\n<li>Nodeの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>とnpm資産によって、CFWの独自<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>までぜんぶ実装してある・・・\n<ul>\n<li>しゅごい</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>OptionsWatcher</h4>\n    \n<ul>\n<li>`Miniflare`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タで`#watcher`に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A5%B5%A5%A4\">アサイ</a>ンされるやつ</li>\n<li>実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>や、設定ファイルなどの変更を監視する役割\n<ul>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/wrangler\">wrangler</a>.toml`とかも</li>\n<li>監視自体は`chokidar`がやってる</li>\n</ul></li>\n<li>変更があったら、`#watchCallback()`が呼ばれる\n<ul>\n<li>コール結果としての`await #watcher.initPromise`が、各所でチェックされる仕組み</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>#watchCallback()</h4>\n    \n<ul>\n<li>初回起動時および、上述のファイル変更が検知されたら動く</li>\n<li>初期化された`#modules`を使って、`#sandbox`と`#environment`を構築する\n<ul>\n<li>つまり実行コンテキストはココで決まる</li>\n</ul></li>\n<li>その後、`#reloadScheduled()`と`#reloadWorker()`が呼ばれる</li>\n<li>コールバックを呼ぶときは、パース済のオプションで呼び出す\n<ul>\n<li>その中には、実行指定された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>本体も含まれる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>#reloadWorker()</h4>\n    \n<ul>\n<li>`ScriptLinker`の初期化\n<ul>\n<li>モジュールWorker用の依存関係のト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%C3%A5%AD%A5%F3%A5%B0\">ラッキング</a></li>\n</ul></li>\n<li>各モジュールのリセット</li>\n<li>さっき用意した実行コンテキストを使って、実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化\n<ul>\n<li>`buildModule()` or `buildScript()`</li>\n</ul></li>\n<li>そして<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>の実行\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>の`run()`</li>\n<li>たいていのWorkerは、これで`fetch`イベントを待ち受けるようになる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>scripts.ts</h4>\n    \n<ul>\n<li>`ScriptBlueprint`クラス\n<ul>\n<li>実行対象の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>の入れ物でありその<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a></li>\n</ul></li>\n<li>`_createContext()`\n<ul>\n<li>用意したコンテキストのsandboxを使って、`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>.createContext()`</li>\n<li><a href=\"https://nodejs.org/api/vm.html#vm_vm_createcontext_contextobject_options\">https://nodejs.org/api/vm.html#vm_vm_createcontext_contextobject_options</a></li>\n</ul></li>\n<li>`buildScript()`\n<ul>\n<li>実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>を`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>.Script`クラスにして、`runInContext()`できるようにする</li>\n<li><a href=\"https://nodejs.org/api/vm.html#vm_script_runincontext_contextifiedobject_options\">https://nodejs.org/api/vm.html#vm_script_runincontext_contextifiedobject_options</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>`dispatchFetch()`</h4>\n    \n<ul>\n<li>上述のくだりで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>が実行されて、イベントを待ち受けてる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>があるはず</li>\n<li>そこに`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`で受けたHTTPを、イベントとして<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B2%A3%CE%AE%A4%B7\">横流し</a>する</li>\n<li>さっきの`EventsModule`の`dispatchFetch()`を呼ぶ\n<ul>\n<li>実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>側で呼んだはずの`addEventListener()`で対応</li>\n</ul></li>\n</ul><p>というのが一連の流れ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>`modules/*`の各モジュールが、NodeでCFW相当の環境を実装してる要たち\n<ul>\n<li>WorkerGlobalScopeをNodeで実装してるだけですごいのに</li>\n<li>KVとかDOとかのCFW独自<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>まで全てが再実装されてる</li>\n</ul></li>\n<li>実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>は、Nodeの`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>`モジュールでV8 Isolate相当を再現\n<ul>\n<li>というか独自コンテキストでコード実行するならこうするしかない？</li>\n</ul></li>\n<li>初回起動時、依存ファイルの更新時に、コンテキストを再生成</li>\n<li>あとは任意のリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トを`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`で受けて、実行<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AF%A5%EA%A5%D7%A5%C8\">スクリプト</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>で実行</li>\n</ul><p>という感じ。うーむ、わかりやすい！</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    \n<ul>\n<li>コードがすごく読みやすくて感動した\n<ul>\n<li>`#sandbox`みたいなプライベートプロパティも使われてるモダンなコード</li>\n</ul></li>\n<li>間違いなくプロの犯行\n<ul>\n<li>というか精錬されすぎててもしや2周目ですか？ってなった</li>\n</ul></li>\n<li>モジュールWorkerのためのコードが結構行数を取ってるのが少し気になる\n<ul>\n<li>けど、これから先の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D5%A5%A1%A5%AF%A5%C8\">デファクト</a>になるならまあ・・</li>\n</ul></li>\n</ul><p>存在は知っててもNodeの`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/vm\">vm</a>`モジュールとか使ったこともなかったし、とっても勉強になった。</p><p>その恩返しも兼ねて、めちゃめちゃ小さいPRを出したら無事にマージされた 😆</p><p>ただもちろんCFW本家と100%同等ではないし、微妙な違いはあるっぽいけど、まあローカルで開発するだけなら便利に使えるやつなのかなーと。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/mrbbot/miniflare/issues/18#issuecomment-886252773\">Missing EventTarget and Event &middot; Issue #18 &middot; mrbbot/miniflare &middot; GitHub</a></p>\n\n    </blockquote>\n\n</div>"
}
