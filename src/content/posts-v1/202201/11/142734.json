{
  "title": "Qwikというフレームワークについて",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik\">GitHub - BuilderIO/qwik: An Open-Source framework designed for best possible time to interactive, by focusing on resumability of server-side-rendering of HTML, and fine-grained lazy-loading of code.</a></p>\n\n    </blockquote>\n<p>去年から気になってて、調べたいなーと思ってたやつ。</p><p>昨今の覇権を握ってる系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>-firstな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>たちとは違い、HTML-firstを謳うユニークなアプローチをしてるのが一番の特徴。</p><p>中の人による一連のシリーズもあって、そこも読んでまとめてみた記事です。</p>\n\n    <blockquote>\n        <p><a href=\"https://dev.to/mhevery/series/13467\">Qwik Series&#39; Articles - DEV Community</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Qwikの特徴</h3>\n    \n<ul>\n<li>遅いモバイル環境だとしても、TTIを爆速にすることを目的とした<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>\n<ul>\n<li>TTI: Time To Interactive</li>\n<li>ページが読み込まれて、UIが表示され、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>がアタッチされ、操作可能になるまでの時間</li>\n</ul></li>\n<li>Resumableをテーマに作られている\n<ul>\n<li>詳細は後述</li>\n<li>現状の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>たちはどれもResumableではなく、強いて言うならReplayable</li>\n</ul></li>\n<li>JSではなく、HTML(DOM)を中心とした設計になってる\n<ul>\n<li>内部状態の管理などに、JSのヒープではなくDOM属性の文字列を使う</li>\n<li>JSが不要というわけではない</li>\n</ul></li>\n</ul><p>という具合で、これまでのものとは一線を画する感じ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>現状の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>とTTIの問題</h3>\n    <p>TTIまでに必要なステップは、ざっくり次のとおり。</p>\n\n<ul>\n<li>クライアントがページをリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>ト</li>\n<li>サーバーがそれを受けて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CDN\">CDN</a>などから返すでもいいけど、それだと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSR\">CSR</a>が必須になってしまう</li>\n<li>遅いモバイル環境でも最速を目指すなら、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>しかない</li>\n</ul></li>\n<li>HTMLとJSのダウンロード\n<ul>\n<li>HTMLはたいていすぐ取得できるけど、問題はJS</li>\n</ul></li>\n<li>ダウンロードしたJSの実行\n<ul>\n<li>テンプレの構築や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>のアタッチなど</li>\n<li>いわゆるハイドレーション</li>\n</ul></li>\n</ul><p>Nextなど現状の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>を使う場合、この後半のステップが重くなりがちで、どうしてもTTIが遅くなる傾向にある、と。</p><p>ほとんど静的なページだったとしても、デカいランタイムが必要（Svelteみたいにそこが小さいのもあるけど）になるし、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>をアタッチするためにVDOMを全走査したりしないといけない。</p><p>そうやってJSをロードしてすべてのUIにハンドラをアタッチしても、ユーザーがそれらを必ず使う保証はないという別の問題もある。もしそれらが使われなかったら？その部分の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>（およびその裏側の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%ED%A1%BC%A5%B8%A5%E3\">クロージャ</a>に連なる多数の依存コード）や、テンプレですらも無駄になる。</p><p>ただこれはそういうデザインになってるからであって、それが必ずしも悪いというわけではない。そのおかげで以降のランタイムのパフォーマンスは良くなるので、何事も<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%EC%A1%BC%A5%C9%A5%AA%A5%D5\">トレードオフ</a>。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Qwikのデザイン</h3>\n    <p>TTIを速くするには、そういう初期ロードでのJSのダウンロードや実行をやめる、もしくは遅延させる必要がある。</p><p>Qwikでも初期ロードでJSを利用するけど、それは1KB足らずで実行も1ms以内に終わる。あとの全て（UIも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>も何もかも）は、非同期で遅延ロードされる。</p><p>もちろん他の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>でも、遅延ロードするように手書きすることはできる。けど、それは付け足しであって、コードは確実に煩雑になるはず。</p><p>Qwikの場合、遅延ロードするのがデフォルトなので、そのための特別なコードは必要ない。単にQwik-wayにコードを書けば、それだけで遅延ロードされる。そんなすべてを遅延ロードするデザインを可能にしてるのが、最初に言ってたResumableという概念。</p>\n\n<div class=\"section\">\n    <h4>Resumableな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a></h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/RESUMABLE.md\">qwik/RESUMABLE.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>現状の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>たちはResumableではなく、Replayableと言ってたけどそれは、</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>の内部状態が、JSのヒープで管理されてる\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>がどこにアタッチされるか</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の構造</li>\n<li>状態の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%F3%A5%C7%A5%A3%A5%F3%A5%B0\">バインディング</a></li>\n</ul></li>\n<li>その解釈や評価がロード時に行われる\n<ul>\n<li>そのために、大量のJSが必要になるわけではある</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>時にやったはずのことを、\"リプレイ\"する必要がある</li>\n<li>途中でやめることも、一部だけをハイドレーションすることもできない\n<ul>\n<li>いわゆるパーシャルハイドレーションができない</li>\n</ul></li>\n</ul><p>という特徴があるから。</p><p>このデザインだと、どうしてもTTIに不利であり、アプリのサイズが大きくなればなるほど、もっと不利になる。</p><p>それに対してQwikでは、</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>でやったことを、クライアントで引き継げる\n<ul>\n<li>つまり\"レジューム\"できる</li>\n</ul></li>\n<li>そのためには、引き継ぎ情報をサーバーからクライアントに渡す必要がある</li>\n<li>それに使われるのが、DOMの属性(= Attributes)\n<ul>\n<li>ありとあらゆるものが、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%EA%A5%A2%A5%E9%A5%A4%A5%BA\">シリアライズ</a>されて属性値に書かれる</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の状態、再描画が必要というマーキングなども</li>\n</ul></li>\n<li>レジュームできるということは、途中でやめることも容易\n<ul>\n<li>スクロールしないと表示されないようなUIは、後回しにできる</li>\n<li>いわゆるパーシャルハイドレーションができる</li>\n</ul></li>\n</ul><p>という風になってる。</p><p>たとえば、これはいわゆる`Counter`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>した結果のコード。（手動でこれを書くわけではない）</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink><span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">div</span>\n<span class=\"synIdentifier\">  on:q-mount=</span><span class=\"synConstant\">&quot;./q-fbbfca2f#Counter_onMount&quot;</span>\n<span class=\"synIdentifier\">  on:q-render=</span><span class=\"synConstant\">&quot;./q-35fc9755#Counter_onRender&quot;</span>\n<span class=\"synIdentifier\">  count-step=</span><span class=\"synConstant\">&quot;5&quot;</span>\n<span class=\"synIdentifier\">  q:obj=</span><span class=\"synConstant\">&quot;#2 !:22l6t4ye9i5&quot;</span>\n<span class=\"synIdentifier\">&gt;</span>\n  <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n    <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\"> on:click=</span><span class=\"synConstant\">&quot;./q-3f6b5546#Counter_onRender_on_click&quot;</span><span class=\"synIdentifier\">&gt;</span>-5<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\">&gt;</span>\n    1\n    <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\"> on:click=</span><span class=\"synConstant\">&quot;./q-4e593eee#Counter_onRender_on_click5&quot;</span><span class=\"synIdentifier\">&gt;</span>+5<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\">&gt;</span>\n  <span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n</pre><p>というように、内部状態がすべて属性で書かれてる。クリックのハンドラですら文字列。</p><p>属性で書かれてるがゆえに、特定の状態が更新されたときに再描画が必要な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>も、`querySelectorAll()`で一発で取ってきてマーキングできる。`requestAnimationFrame()`で間引きながら再描画していくときにも、Dirtyとマーキングがされてるものだけを逐次処理できる。変わってないかもしれない部分をわざわざ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>する必要もない。</p>\n\n</div>\n<div class=\"section\">\n    <h4>すべてを遅延ロードする</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/LAZY_LOADING.md\">qwik/LAZY_LOADING.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>さっきのコードにもあったけど、なんと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>ですら遅延ロードされる。実際にクリックされるまで、ハンドラで実行するコードをダウンロードすらしない！インクリメントのハンドラと、デクリメントのハンドラも別ファイルになる。クリックされたら、その当該のハンドラと、テンプレのためのコードがダウンロードされて実行される。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>は、もちろんそのイベントが実行されない限りは必要にならない。そして必要にならないかもしれないのに、実行コードとその依存を必ずダウンロードして、待ち受けるというコストを支払う必要がある。</p><p>これを回避するために、Qwikでは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>すらDOM属性に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%EA%A5%A2%A5%E9%A5%A4%A5%BA\">シリアライズ</a>してしまうことで、遅延ロードを可能にしてる、と。</p><p>ただ原初のクリックイベントを拾う必要はもちろんあって、それをやってるのが最初にロードする1KBに満たない`qwikloader.js`ってやつ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/src/bootloader-shared.ts\">https://github.com/BuilderIO/qwik/blob/main/src/bootloader-shared.ts</a></p>\n\n    </blockquote>\n<p>各イベントタイプごとに1つだけ、グローバルなハンドラをアタッチする。そして`ev.target.getAttribute()`で何をすべきか判断して、サーバーにリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トする。サーバーとのやりとりには、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/QRL\">QRL</a>っいう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>を使ってるけど、これはただの独自URL。</p><p>あとは、遅延ロードされた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>だとしても既存のグローバルな状態や親の状態などとやり取りできるように、`Entity`っていう仕組みがあったりする。</p><p>このあたりは、コードを書く我々としても考え方をQwik-wayにする必要があって、そこは少しとっつきにくいなーとは思った。最速のTTIを実現するために必要な代価ではあるけど。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/MENTAL_MODEL.md#component--entities\">qwik/MENTAL_MODEL.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>ともあれ、デザイン<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%AB%A4%E9%A4%B7\">からし</a>てすべてを遅延ロードするので、TTIは必然的に速くなるというわけ。遅いモバイル環境であっても、それがどれだけデカいアプリになったとしても、初期ロードが常に速いってのが、Qwikの特徴。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>コードを動かす、試す</h3>\n    <p>実際に動いてるものを見るなら、</p>\n\n<ul>\n<li>Qwikの中の人たちであるBuilder.ioのサイト\n<ul>\n<li><a href=\"https://www.builder.io/?render=qwik\">https://www.builder.io/?render=qwik</a></li>\n<li>パラメータに注目</li>\n</ul></li>\n<li>TODOのデモ\n<ul>\n<li><a href=\"https://stackblitz.com/edit/qwik-todo-demo\">https://stackblitz.com/edit/qwik-todo-demo</a></li>\n<li>ただし<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>系のブラウザでしか見れない</li>\n<li>そしてQwikのバージョンが古いので、コードは参考にならなそう</li>\n</ul></li>\n</ul><p>確かに、初期ロードは軽いしめっちゃ速い気がする・・！</p><p>さっきの`Counter`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>はこんな感じで書いてた。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> h <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@builder.io/qwik&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> qComponent<span class=\"synStatement\">,</span> qHook <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@builder.io/qwik&quot;</span><span class=\"synStatement\">;</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synType\">const</span> Counter <span class=\"synStatement\">=</span> qComponent<span class=\"synStatement\">&lt;</span><span class=\"synIdentifier\">{</span> countStep: <span class=\"synType\">number</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">,</span> <span class=\"synIdentifier\">{</span> count: <span class=\"synType\">number</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">&gt;(</span><span class=\"synIdentifier\">{</span>\n  onMount: qHook<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span> count: <span class=\"synConstant\">1</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)),</span>\n  onRender: qHook<span class=\"synStatement\">((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>div<span class=\"synStatement\">&gt;</span>\n      <span class=\"synStatement\">&lt;</span>button\n        on:click<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span>qHook<span class=\"synStatement\">&lt;typeof</span> Counter<span class=\"synStatement\">&gt;((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n          state.count <span class=\"synStatement\">-=</span> props.countStep<span class=\"synStatement\">;</span>\n        <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)</span><span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&gt;</span>\n        -<span class=\"synIdentifier\">{</span>props.countStep<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>/button<span class=\"synStatement\">&gt;</span>\n      <span class=\"synIdentifier\">{</span>state.count<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>button\n        on:click<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span>qHook<span class=\"synStatement\">&lt;typeof</span> Counter<span class=\"synStatement\">&gt;((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n          state.count <span class=\"synStatement\">+=</span> props.countStep<span class=\"synStatement\">;</span>\n        <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)</span><span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&gt;</span>\n        +<span class=\"synIdentifier\">{</span>props.countStep<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>/button<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">&lt;</span>/div<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">)),</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>という感じで、</p>\n\n<ul>\n<li>`class`ではなく、`qComponent()`にオブジェクトを渡して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を作る\n<ul>\n<li>`onMount()`で、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>に閉じた状態を返す</li>\n<li>`onRender()`で、おなじみのJSXを使ってテンプレを書く</li>\n</ul></li>\n<li>`qHook()`でラップすると、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>のPropsやStateにアクセスできる</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSS\">CSS</a>はクラスを振って書くしかなさそう\n<ul>\n<li>ただしオブジェクトを渡せば`true`のときに付加するみたいな仕組みはある</li>\n</ul></li>\n</ul><p>これはできる限り現状の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>っぽい書き方でComponentにすべてを詰め込んでるけど、Qwikの真髄的には、ViewとStateとHandlerはそれぞれバラして書くべきらしい。そのほうが、本当に必要なものだけを遅延ロードできるから。</p>\n\n    <blockquote>\n        <p><a href=\"https://dev.to/builderio/your-bundler-is-doing-it-wrong-ic0\">Your bundler is doing it wrong - DEV Community</a></p>\n\n    </blockquote>\n<p>ただこのへんは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>がいい感じにやってくれる？っぽい感もあって、まだよくわかってない。</p>\n\n    <blockquote>\n        <p><a href=\"https://qwik-playground.builder.io/\">Qwik compiler playground</a></p>\n\n    </blockquote>\n<p>Rollupの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>として動いてるであろうOptimizerでもその具合を調整してる風だった。推論できないときのためのマーキングなんだろうか・・？</p><p>ローカルで試したい場合は、スターターのコマンドを使う。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npm init qwik</pre><p>ってやると、いくつかテンプレを選ぶだけでコードを書き始められる。</p><p>現時点のデプロイ先の選択肢には、Node.js用の`express`のバージョンと、Cloudflare Workersへデプロイできるバージョンの2つがあった。たしかにコレはWorkerでやれると良さそうって思ってたんよね。</p><p>スターターを使って、</p>\n\n<ul>\n<li>もっともベーシックな`Starter`プロジェクトを</li>\n<li>Node.jsでデプロイする</li>\n</ul><p>とした場合に、生成されたコードはこのような感じ。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>├── README.md\n├── package.json\n├── rollup.config.js\n├── server\n│   └── index.js\n├── src\n│   ├── index.server.tsx\n│   └── my-app.tsx\n└── tsconfig.json</pre><p>`src`配下がアプリのコードで、この状態でビルドすると、こうなる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>├── README.md\n├── package.json\n├── public\n│   └── build\n│       ├── index.server.js\n│       ├── my-app.js\n│       ├── q-1612aa57.js\n│       ├── q-5404689f.js\n│       ├── q-6c8e2d16.js\n│       └── q-8b22cd88.js\n├── rollup.config.js\n├── server\n│   ├── build\n│   │   ├── core-3865dc2e.js\n│   │   ├── h_my-app_myapp_onmount-4f2b0222.js\n│   │   ├── h_my-app_myapp_onrender-e999a192.js\n│   │   ├── h_my-app_myapp_onrender_on_keyup-69b97bcc.js\n│   │   ├── index.server.js\n│   │   ├── my-app.js\n│   │   └── q-symbols.json\n│   └── index.js\n├── src\n│   ├── index.server.tsx\n│   └── my-app.tsx\n└── tsconfig.json</pre><p>`server/build`配下に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>のために必要なアプリのコードが出力されて、クライアントに返して使うための同様のものが、`public/build`配下にできるという感じ。とにかく細かいファイルが作られて、必要なときに必要なものだけが利用されるってのがよくわかるはず。</p><p>Cloudflare Workersにデプロイする方式を選んだ場合は、Workers Sitesを使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DB%A5%B9%A5%C6%A5%A3%A5%F3%A5%B0\">ホスティング</a>するようになってた。</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>というわけで、TTIが速いのは納得のデザインって感じでかなり好印象だった。TTIをKPIに据えてるなら、選択肢として考えられるようにしていきたい感じ。</p><p>ただ、UIイベントが発生してからハンドラのコードをリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トするので、UIとしてのレスポンスにはいくらか制限があるんでは？とも思った。キャッシュしたりWorker使ったり、ある程度はカバーできると思うけど。</p><p>まだ生まれて間もないし（というかドキュメントすらないし）、実用段階ではないにしても、これからも要チェックでいきたいところ。</p><p>JSの用法と用量を最適化しようとする昨今のトレンドは割といいなと思っていて、そういう意味ではAstroとかと出発点は同じなのかもなーと。<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>のQwikと、SSGのAstroみたいな。</p><p>ちなみにQwikの中の人、あのAngularの中の人でもあるそうな。ここでまたその名を聞くとはな・・どうりでそれらしいコードやらコメントやらがあるわけやって感じ。</p><p>ほかにもBuilder.io社の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\">OSS</a>は興味深いのが多くて、`partytown`とか`mitosis`とか、一度は話題になってたことがあるはず。</p>\n\n</div>"
}
