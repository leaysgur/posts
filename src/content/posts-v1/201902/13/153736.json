{
  "title": "RTCQuicTransportでチャットをつくる",
  "html": "<p>表題まま。</p><p>前回記事を書いたように、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のM73からM75までの間、`RTCQuicTransport`のOrigin Trialがはじまります。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/02/01/180529\">WebRTC QUIC&#x304C;Chrome&#x3067;Origin Trial&#x3067;&#x304D;&#x308B;&#x3088;&#x3046;&#x306B; - console.lealog();</a></p>\n\n    </blockquote>\n<p>というわけで、`RTCQuicTransport`を使ったなにかを作ろうと思ってやってみたという話です。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>成果物</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/rtcquic-chat-example\">GitHub - leader22/rtcquic-chat-example: Need to register Origin-Trial by yourself ;D</a></p>\n\n    </blockquote>\n<p><br />\nっても、挙動的になにかが大きく変わるのではないので、ほとんどの人は何の感動もないですｗ</p><p>とりあえず試す用なので雑に作ってあって、</p>\n\n<ul>\n<li>VanillaICEで手動<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>\n<ul>\n<li>2タブ（A, B）を開いて</li>\n<li>Aの上段でGETしてコピー</li>\n<li>Bの下段にペーストしてSET</li>\n<li>Bの上段に出たのをコピー</li>\n<li>Aの下段にペーストしてSET</li>\n</ul></li>\n<li>テキストしか送れません\n<ul>\n<li>詳細は後述</li>\n</ul></li>\n</ul><p>です。<br />\n<br />\n</p>\n\n</div>\n<div class=\"section\">\n    <h3>前提知識</h3>\n    <p>今回<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>に実装されたやつと、本家仕様には乖離があります・・。</p>\n\n<ul>\n<li>RTCQuicTransport\n<ul>\n<li><a href=\"https://w3c.github.io/webrtc-quic/\">https://w3c.github.io/webrtc-quic/</a></li>\n</ul></li>\n<li>RTCQuicStream\n<ul>\n<li><a href=\"https://w3c.github.io/webrtc-quic/cs.html\">https://w3c.github.io/webrtc-quic/cs.html</a></li>\n</ul></li>\n<li>RTCIceTransport\n<ul>\n<li><a href=\"https://w3c.github.io/webrtc-ice\">https://w3c.github.io/webrtc-ice</a></li>\n</ul></li>\n</ul><p>これらが本家の仕様ですが、今回実装されてるのはその一部分 + 微妙に違う<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>たち。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/shampson/RTCQuicTransport-Origin-Trial-Documentation#api-glossary\">GitHub - shampson/RTCQuicTransport-Origin-Trial-Documentation: Documentation and demos for developers using the RTCQuicTransport in Chrome&#39;s origin trial.</a></p>\n\n    </blockquote>\n<p>ここに載ってるのがすべてであり、それが`googRTCQuicTransport`では？とか揶揄される理由。</p><p>コード例も、OriginTrial開始の記事にさらっと書いてあるくらいで、全然ありません＼(^o^)／</p><p>WebRTCHacksのこの記事のほうが詳しいくらい。</p>\n\n    <blockquote>\n        <p><a href=\"https://webrtchacks.com/first-steps-with-quic-datachannel/\">First steps with QUIC DataChannels - webrtcHacks</a></p>\n\n    </blockquote>\n<p>まぁそんな中でとりあえず動くものを作ったので、とりあえず学びをブログにしとくかーというモチベーションです。</p><p>まずはそれぞれのクラスについて書いていきます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCIceTransport</h3>\n    <p>何より先にまずICE。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> ice = <span class=\"synStatement\">new</span> RTCIceTransport();\n\n<span class=\"synComment\">// 従来のWebRTCと同じ</span>\nice.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate === <span class=\"synStatement\">null</span>) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// gathering done</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n<span class=\"synComment\">// candidateを集める</span>\nice.gather(<span class=\"synIdentifier\">{</span>\n  gatherPolicy: <span class=\"synConstant\">'all'</span>,\n  iceServers: <span class=\"synIdentifier\">[{</span> urls: <span class=\"synConstant\">'stun:stun.l.google.com:19302'</span> <span class=\"synIdentifier\">}]</span>,\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// シグナリングで相手に渡したいものを互いに送りあう</span>\n<span class=\"synStatement\">const</span> candidates = ice.getLocalCandidates();\n<span class=\"synStatement\">const</span> params = ice.getLocalParameters();\n\n<span class=\"synComment\">// 相手から受け取ったやつを渡す</span>\n<span class=\"synStatement\">for</span> (<span class=\"synStatement\">const</span> candidate of candidates) <span class=\"synIdentifier\">{</span>\n  ice.addRemoteCandidate(candidate);\n<span class=\"synIdentifier\">}</span>\n<span class=\"synComment\">// type iceRole = 'controlling' | 'controlled';</span>\nice.start(params, iceRole);\n\n<span class=\"synComment\">// つながるのを待つ</span>\nice.addEventListener(<span class=\"synConstant\">'statechange'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.target.state === <span class=\"synConstant\">'connected'</span>) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// ...</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre>\n<ul>\n<li>紹介記事のコード例では`RTCQuicTransport`ごっちゃに扱われてるけど、独立して使える</li>\n<li>見つかった経路はその都度送って`addRemoteCandidate()`してもいいし</li>\n<li>上のコードにあるようにまとめてやってもいい</li>\n<li>`start()`と`addRemoteCandidate()`の順番もどっちが先でもいい</li>\n<li>`getLocalXxx()`があるように、`getRemoteXxx()`も生えてる</li>\n<li>経路が決まったら、`getSelectedCandidatePair()`で組み合わせが取れるようになる</li>\n</ul><p>さよならSDP。<br />\nORTCのソレとも違うけど、シンプルなので使い方にも特別迷うことはないはず。</p>\n\n</div>\n<div class=\"section\">\n    <h3>RTCQuicTransport</h3>\n    <p>ICEがつながったら次にQUICをつなげる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 独立して使えるけど、引数で渡す必要がある</span>\n<span class=\"synStatement\">const</span> quic = <span class=\"synStatement\">new</span> RTCQuicTransport(ice);\n\n<span class=\"synComment\">// これを相手に渡して待つ</span>\n<span class=\"synStatement\">const</span> key = quic.getKey();\nquic.connect();\n\n<span class=\"synComment\">// 受け取った側</span>\nquic.listen(key);\n\n<span class=\"synComment\">// つながるのを待つ</span>\nquic.addEventListener(<span class=\"synConstant\">'statechange'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.target.state === <span class=\"synConstant\">'connected'</span>) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// ...</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre>\n<ul>\n<li>QUIC用語では、クライアントとサーバーに概念が分かれるらしい\n<ul>\n<li>`connect()`する側がクライアント</li>\n<li>`listen(key)`する側がサーバー</li>\n</ul></li>\n<li>使ったことないけど、`getStats()`も生えてる</li>\n<li>QUICのコネクションを張れば、その中でストリームがN本作れる</li>\n</ul>\n<div class=\"section\">\n    <h4>getKey()</h4>\n    <p>16byteの`ArrayBuffer`が取れる。</p><p>なので、これをそのまま送れる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>方法じゃない場合は、ひと手間必要。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// from https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String</span>\n<span class=\"synStatement\">export</span> <span class=\"synIdentifier\">function</span> ab2str(buf) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synType\">String</span>.fromCharCode.apply(<span class=\"synStatement\">null</span>, <span class=\"synStatement\">new</span> Uint16Array(buf));\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synIdentifier\">function</span> str2ab(str) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> buf = <span class=\"synStatement\">new</span> ArrayBuffer(str.length * 2); <span class=\"synComment\">// 2 bytes for each char</span>\n  <span class=\"synStatement\">const</span> bufView = <span class=\"synStatement\">new</span> Uint16Array(buf);\n  <span class=\"synStatement\">for</span> (<span class=\"synIdentifier\">let</span> i = 0, strLen = str.length; i &lt; strLen; i++) <span class=\"synIdentifier\">{</span>\n    bufView<span class=\"synIdentifier\">[</span>i<span class=\"synIdentifier\">]</span> = str.charCodeAt(i);\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synStatement\">return</span> buf;\n<span class=\"synIdentifier\">}</span>\n</pre><p>みたく、一旦`string`にして相手に送ればOK。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>これを踏まえて</h3>\n    <p>従来の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はこのへんの処理を`RTCPeerConnection`がやってくれてたけど、そのレイヤーはまだ実装されてない。</p><p>なので、自作したのがこのファイル。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/rtcquic-chat-example/blob/master/src/chat-app/quic-peer-connection.js\">https://github.com/leader22/rtcquic-chat-example/blob/master/src/chat-app/quic-peer-connection.js</a></p>\n\n    </blockquote>\n<p>という具合で、単にQUICをつなげるだけなら割と簡単にできる。</p><p>問題はここから・・・！</p>\n\n</div>\n<div class=\"section\">\n    <h3>QuicStream</h3>\n    <p>個人的に一番やりづらかったのがこいつ。</p><p>WriteとReadをそれぞれ細かく見ていく。</p>\n\n<div class=\"section\">\n    <h4>Write</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> quicStream = quic.createStream();\n\n<span class=\"synComment\">// 書き込み</span>\nquicStream.write(<span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// Uint8Arrayのみ</span>\n  data: <span class=\"synStatement\">new</span> TextEncoder().encode(<span class=\"synConstant\">'Hello, quic!'</span>),\n  finish: <span class=\"synConstant\">false</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre>\n<ul>\n<li>引数は`data`と`finish`の2つ</li>\n<li>`data`は`Uint8Array`のみ</li>\n<li>`finish`はそのストリームの終端を表す\n<ul>\n<li>一度`finish`すると、`write()`できなくなる</li>\n</ul></li>\n</ul><p>どれくらいバッファリングを真面目にやるかによって、コードが変わる。</p><p>いちおう`waitForWriteBufferedAmountBelow()`ってメソッドがあって、いわゆる書き込み待ちができる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Read</h4>\n    <p>`waitForReadable()`と`readInto()`がカギ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>quic.addEventListener(<span class=\"synConstant\">'quicstream'</span>, async ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> quicStream = ev.stream;\n\n  <span class=\"synComment\">// 最初に読み出し可能になるまで待つ</span>\n  await quicStream.waitForReadable(1);\n  _readData(quicStream);\n<span class=\"synIdentifier\">}</span>);\n\nasync <span class=\"synIdentifier\">function</span> _readData(quicStream) <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// 今読み出せる分だけ全部読む</span>\n  <span class=\"synStatement\">const</span> buffer = <span class=\"synStatement\">new</span> Uint8Array(quicStream.readBufferedAmount);\n  quicStream.readInto(buffer);\n\n  <span class=\"synComment\">// stringならデコードできる</span>\n  <span class=\"synStatement\">const</span> message = <span class=\"synIdentifier\">this</span>.decoder.decode(buffer);\n\n  <span class=\"synComment\">// ...</span>\n\n  <span class=\"synComment\">// 次の書き込みを待つ</span>\n  await quicStream.waitForReadable(1);\n  <span class=\"synIdentifier\">this</span>._readData(quicStream);\n<span class=\"synIdentifier\">}</span>\n</pre>\n<ul>\n<li>`quicstream`イベントは、最初に`write()`されるまで呼ばれない\n<ul>\n<li>これ仕様なんだろうか</li>\n</ul></li>\n<li>`waitForReadable()`は必須\n<ul>\n<li>とりあえず全受信したいなら、`1`とか渡せばいい</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>で`await`して置いておけば、そのストリームに対する書き込みは全部拾える</li>\n</ul><p>このあたりの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>の取り回しは、NodeJSのStreamとかと一緒なので、まあ慣れかなーと。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>ストリームをどう扱うか</h3>\n    <p>このコード例では、単一のQUICコネクションの上で単一のストリームを張って、その中で全部やってる。</p><p>ただやり方としては他にもあって、いわゆるUnreliableな使い方。</p><p>その場合は、1メッセージごとに1ストリームを作ればいいだけ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// write</span>\nquicStream.write(<span class=\"synIdentifier\">{</span>\n  data: <span class=\"synStatement\">new</span> TextEncoder().encode(<span class=\"synConstant\">'Hello, quic!'</span>),\n  finish: <span class=\"synConstant\">true</span>, <span class=\"synComment\">// 毎回終わらせる</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// read</span>\nquic.addEventListener(<span class=\"synConstant\">'quicstream'</span>, async ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> quicStream = ev.stream;\n\n  await quicStream.waitForReadable(1);\n  <span class=\"synStatement\">const</span> buffer = <span class=\"synStatement\">new</span> Uint8Array(quicStream.readBufferedAmount);\n  quicStream.readInto(buffer);\n\n  <span class=\"synStatement\">const</span> message = <span class=\"synIdentifier\">this</span>.decoder.decode(buffer);\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>どっちがいいとかではなく、どっちでもいい。</p><p>ただまあだいたいのケースではReliableに使いたいと思うので、1ストリームでやればいいのでは・・と思う。</p>\n\n<div class=\"section\">\n    <h4>デカファイルの送信</h4>\n    <p>これまで触れてなかったけど、ストリームを触る上で避けて通れないのがコレ。</p>\n\n<ul>\n<li>ブラウザがよしなにやってる送信量の調整<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%B7%A4%AD%A4%A4%C3%CD\">しきい値</a>がある\n<ul>\n<li>NodeJSでいう`highWaterMark`</li>\n</ul></li>\n<li>Readなら`maxReadBufferedAmount`</li>\n<li>Writeなら`maxWriteBufferedAmount`</li>\n<li>これを超えるものを`write()`すると、1度の`readInto()`では読みきれない</li>\n</ul><p>というわけで、デカファイルを送るにはこのあたりも調整しないといけなくて、`readInto()`で読み出した`Uint8Array`を、面倒くさいけど連結してから処理する必要がある。（雑につなぐとbyteの境目でデータが壊れたりする）</p><p>ただそもそもの話として、デカファイルをブラウザのメモリに載せるなとか、そもそも載せてどうするんだとかあるので、ファイル共有を作りたい時以外はお世話にならんのでは・・？</p>\n\n</div>\n<div class=\"section\">\n    <h4>テキストチャットでファイルも送信したい</h4>\n    <p>とはいってもあるよねこういう要件・・。</p><p>今回のサンプル実装でも最初はそれを実装しようとしてたけど、あまりに面倒だったのでやめました。<br />\nつまりは複数のフォーマットを送信する場合、受信側でそれをさばくのが大変ということ。</p><p>なので、そういう実装をする場合にはどういうことをすればいいかメモしておきます。</p>\n\n<ul>\n<li>単一ストリーム上でファイルを送るならまずその旨を通知しないといけない\n<ul>\n<li>`readInto()`したものは`Uint8Array`なので、中身がわからない</li>\n<li>= それがテキストなのか画像なのかなんなのかわからない</li>\n</ul></li>\n<li>なので明示的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BF%A5%C7%A1%BC%A5%BF\">メタデータ</a>を送って、受け側で受け入れ準備をする\n<ul>\n<li>あらかじめ知りたい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MIME\">MIME</a>-TYPEとかLengthとか</li>\n</ul></li>\n<li>もしくは異なるストリームにして、異なるハンドラを置いておく\n<ul>\n<li>でもストリームをまたぐとReliableではないし・・などなど悩ましい</li>\n</ul></li>\n</ul><p>的なことをまとめたものを一般的には<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>といって、そのうちどこかの誰かが仕様を作ったりするんかなーと思ったのでやめました。</p><p>そもそも`RTCQuicTransport`は、いわゆるDataChannelとイコールではないはずなので。</p><p>まあ面倒ではあるがやれないことはないよという話でした。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>その他のネタ</h3>\n    \n<ul>\n<li>UIは本旨ではないので雑にした</li>\n<li>ReactのHooks試そうかとも思ったけど、`lighterhtml`にした\n<ul>\n<li><a href=\"https://github.com/WebReflection/lighterhtml\">https://github.com/WebReflection/lighterhtml</a></li>\n<li>`hyperHTML`の後継で相変わらずシュッとしてる</li>\n</ul></li>\n<li>Materializeはまぁまぁ便利</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>でしか使わないのでES Modules\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CDN\">CDN</a>で公開されてるライブラリまだまだ少ないね</li>\n</ul></li>\n</ul><p>そもそもWebRTCがニッチすぎるのもあってリアクションは期待してないけど、同業の人とか試してみたとか何かあれば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Twitter\">Twitter</a>とかでリプください！</p>\n\n</div>"
}
