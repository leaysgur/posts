{
  "title": "ローカルでのフロントエンド開発時でも、実際のCloudflareスタックにアクセスする",
  "html": "<p>端的にいうと、</p>\n\n<ul>\n<li>フロントエンドはSvelteKitやらモダンなやつで組んで</li>\n<li>Cloudflare Pagesにデプロイしたい</li>\n<li>そしてKVやD1やらも使いたいし</li>\n<li>ローカルでも実際の値を参照して開発したい</li>\n</ul><p>つまり、サーバー<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>や<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>ルートを実装するときに、既存のスタックに保存してある値を使いたいという話。</p><p>個人的にはあるあるのケースで、あらゆるものをCloudflareのエッジで完結させる未来を待つなら、なおさら。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3 id=\"ローカルから実際のKVやD1にアクセスするには\">ローカルから実際のKVやD1にアクセスするには</h3>\n    <p>現状、これをやるには2通りの方法しかない。</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a></li>\n<li>`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev --remote`</li>\n</ul><p>まず前者。これはいわずもがな、HTTP経由でアクセスできる。<br />\nただ、Cloudflare Pagesにデプロイするなら、Workersで動作するコードからアクセスするなら、あえて1クッションはさむ理由はなさそう。</p><p>つぎに後者だが、これはPagesではなくWorkers単体の構成でしか使えない。</p><p>ならPagesやめてWorkers Sitesにするか？っていうと、そうはならない（なれない）ことのほうがおおいはず。<br />\n<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/GitHub\">GitHub</a>との連携も、CIでのビルドも、ブランチプレビューも、何もかも失っちゃう。なので、Workers Sitesのことはいったん忘れる。</p><p>Pagesにも、`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev pages`コマンドがある・・・が、これはローカルに閉じてる。`--remote`なオプションも現状は存在しない。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/blob/528cc0fc583e9672247d5934c8b33afebbb834e7/packages/wrangler/src/pages/dev.ts#L53\">https://github.com/cloudflare/workers-sdk/blob/528cc0fc583e9672247d5934c8b33afebbb834e7/packages/wrangler/src/pages/dev.ts#L53</a></p>\n\n    </blockquote>\n<p>（そしてこのコマンドの場合、`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> pages dev --kv=XXX -d=YYY`みたいな渡し方でしか動かなくて不便だったはず）</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"Viteベースのフレームワークの課題\">Viteベースの<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>の課題</h3>\n    <p>たとえば、SvelteKitの場合。</p><p>最近のメタ<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>は、Viteに乗っかる形で実装されてることが多いので、`vite dev`みたいなコマンドでローカルで動作させることがほとんど。</p><p>が、`vite dev`では、デプロイされるプラットフォーム固有のオブジェクト（SvelteKitでいう`platform.env`）に値が入らないので、ランタイムでKVなんかにアクセスできない。</p><p>`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> pages dev --kv=XXX -- npm run dev`は、一見惜しく感じるかもしれないが、同様に`undefined`なまま。それにできたとしてもローカル完結。</p><p>あれこれやってみた結果、</p>\n<pre class=\"code\" data-lang=\"\" data-unlink># これらを同時に\nvite build --watch\nwrangler pages dev .svelte-kit/cloudflare --kv=XXX --live-reload</pre><p>という合せ技で、とりあえずローカルで動く状態にはできる。が・・・、このパターンは、毎回`vite build`でフルビルドするので、とにかくDXが悪い。</p><p>コードを更新する度に3秒待つし、画面もフルリロードする。もっとも手数が少ないやり方ではあるものの、何年前なんだ・・ってなる。</p><p>SvelteKitの場合、Hooksという仕組みを使って、`platform`オブジェクトごと再実装するっていう荒業も見出されてた。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// hooks.server.js</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> dev <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;$app/environment&quot;</span>;\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> handle = async (<span class=\"synIdentifier\">{</span> <span class=\"synStatement\">event</span>, resolve <span class=\"synIdentifier\">}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (dev) <span class=\"synStatement\">event</span>.platform = <span class=\"synIdentifier\">{</span> <span class=\"synComment\">/* Mock here */</span> <span class=\"synIdentifier\">}</span>;\n\n  <span class=\"synStatement\">return</span> resolve(<span class=\"synStatement\">event</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>ここの実装をなんとかしてでっち上げれば、`vite dev`だけで動かせるようになって、DXが少しは改善される。</p><p>適当なモックの実装でローカル完結させるもよし、<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>につないで本番データにつなぐもよし。</p><p>がんばってモックしてる先人のコードはこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/kit/issues/4292#issuecomment-1550596497\">https://github.com/sveltejs/kit/issues/4292#issuecomment-1550596497</a></p>\n\n    </blockquote>\n<p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>を使う場合は、がんばって`fetch`ラッパーを書く必要がある。現状、D1の<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>はまだ公開されてなさそうではあるが、内部的には存在する気配を感じるので、そのうちできるようになりそう。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/blob/436f752d77b12b81d91341185fc9229f25571a69/packages/wrangler/src/d1/execute.tsx#L342\">https://github.com/cloudflare/workers-sdk/blob/436f752d77b12b81d91341185fc9229f25571a69/packages/wrangler/src/d1/execute.tsx#L342</a></p>\n\n    </blockquote>\n<p>がんばってモックするパターンは、KVのREADだけあればいいとか、接点が小さいならばありかもしれんけど、エッジに生きるものとしてはやっぱ使い倒したいよな〜って。</p>\n\n<div class=\"section\">\n    <h4 id=\"他のメタフレームワークは\">他のメタ<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>は</h4>\n    <p>SvelteKitでなくても、Viteベースのメタ<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>を使う場合、おそらく同じ結果になるはず。</p>\n\n<ul>\n<li>SolidStart</li>\n<li>Astro</li>\n<li>QwikCity</li>\n</ul><p>少なくともこのあたりは。</p><p>Next.jsは、そもそも`@cloudflare/next-on-pages`っていうそれ用のレイヤーがないとまともに立てもしない状態な上、READMEを見る限り`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> pages dev`を使うらしいので、実データは参照できなそう。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/next-on-pages/blob/b1c3a3389b64d6370136d3bff08991edc9de43c1/packages/next-on-pages/README.md?plain=1#L76\">https://github.com/cloudflare/next-on-pages/blob/b1c3a3389b64d6370136d3bff08991edc9de43c1/packages/next-on-pages/README.md?plain=1#L76</a></p>\n\n    </blockquote>\n<p>Remixは、たしかViteベースではなかったはずやけど、最新のテンプレを見る限り`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> pages dev`を使うようだった。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/remix-run/remix/blob/3f0ba3780c748782c31df2d19392909765a28f5d/templates/cloudflare-pages/package.json#L7\">https://github.com/remix-run/remix/blob/3f0ba3780c748782c31df2d19392909765a28f5d/templates/cloudflare-pages/package.json#L7</a></p>\n\n    </blockquote>\n<p>コード更新からの反映速度が気にならず、ローカル完結でよければ、React界隈のほうが幸せになれるんかね。（未検証）</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"いっそのこと別のWorkerを用意する\">いっそのこと、別のWorkerを用意する</h3>\n    <p>という割り切りもあるよって話。</p><p>これは単純で、</p>\n\n<ul>\n<li>そもそもPagesにデプロイするアプリ（今回ならSvelteKit）側で、KVに直アクセスするのをやめる</li>\n<li>Cloudflare Workersの別プロジェクトで<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>を作る\n<ul>\n<li>こっちでKVやD1にアクセスする</li>\n<li>こっちのプロジェクトで`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev --remote`</li>\n</ul></li>\n<li>SvelteKit側からは通常の`fetch`で読むようにする</li>\n</ul><p>とすれば、実データにもアクセスできるし、コードの反映もすぐのまま。</p><p>問題があるとすれば、</p>\n\n<ul>\n<li>PagesとWorkersの2つを別で管理することになる\n<ul>\n<li>デプロイも2倍</li>\n</ul></li>\n<li>SK側で<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>を作る手段があるのに、わざわざ1クッション\n<ul>\n<li>パフォーマンス的にもこの1RTTは余計</li>\n<li>コードの書き味としても直感的ではない</li>\n</ul></li>\n</ul><p>というあたり。</p><p>悩ましいが、債務分離という意味では妥当という見方もできなくはない。（世のトレンドがそうさせてくれんかもしれんけど）</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"そういうわけでライブラリ作った\">そういうわけでライブラリ作った</h3>\n    <p>前フリが長くなったけど、</p>\n\n<ul>\n<li>SvelteKitのような<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>を`vite dev`で快適にローカル開発しながらも</li>\n<li>実際のCloudflareスタックにアクセスしたい</li>\n</ul><p>場合は、モックの実装を自分で差し込むしかなさそう。</p><p>ならば、せめて、そのモックを楽に使えるようにしようと作ったのがコレ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/cfw-bindings-wrangler-bridge\">GitHub - leader22/cfw-bindings-wrangler-bridge: Bridge between local development code and Cloudflare bindings, via `wrangler dev --remote` command.</a></p>\n\n    </blockquote>\n<p>簡単にいうと、</p>\n\n<ul>\n<li>予めローカルで起動しておいた`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev --remote`のサーバーに</li>\n<li>実<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>と同じ<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>のモック実装からアクセスできる</li>\n</ul><p>というもの。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> createBridge <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;cfw-bindings-wrangler-bridge&quot;</span>;\n\n<span class=\"synComment\">/** @type {import(&quot;@cloduflare/workers-types&quot;).KVNamespace} */</span>\n<span class=\"synStatement\">const</span> MY_KV = createBridge(<span class=\"synConstant\">&quot;http://127.0.0.1:8787&quot;</span>).KV(<span class=\"synConstant\">&quot;MY_KV&quot;</span>);\n\n<span class=\"synComment\">// ✌️ This is real KV!</span>\nawait MY_KV.put(<span class=\"synConstant\">&quot;foo&quot;</span>, <span class=\"synConstant\">&quot;bar&quot;</span>);\nawait MY_KV.get(<span class=\"synConstant\">&quot;foo&quot;</span>); <span class=\"synComment\">// &quot;bar&quot;</span>\n</pre><p>アプリ側のコードとしてはこれだけでいい。</p>\n\n<ul>\n<li>アプリ: 実<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>と同じコードを呼ぶ</li>\n<li>🌉モジュール: HTTPリク<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トに変換して、ブリッジワーカーへ投げる</li>\n<li>🌉ワーカー: HTTPリク<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トを解釈して実<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>を呼んで、レスポンス</li>\n<li>🌉モジュール: レスポンスを実<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>の返り値に変換して返す</li>\n<li>アプリ: 実<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/API\">API</a>と同じ結果が取得できる！</li>\n</ul><p>`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> dev`をそのまま使ってるので、</p>\n\n<ul>\n<li>`--remote`を外せばそのままローカル環境も使える\n<ul>\n<li>`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a> pages dev`相当</li>\n</ul></li>\n<li>`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a>`自体がアップデートされても、それは使う側が選べる</li>\n<li>アプリ内のコードが汚れない\n<ul>\n<li>ローカルなURLだけ管理すればいい</li>\n</ul></li>\n</ul><p>というあたりがポイントかも。</p><p>最初は`miniflare`や`workerd`を使うことも考えたけど、結局それだとローカル完結になるし、<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>だと<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CD%A5%C1%A5%E3\">シグネチャ</a>通りに使えないのでやめた。</p><p><a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/CLI\">CLI</a>ではなくモジュールとしての`<a class=\"keyword\" href=\"https://d.hatena.ne.jp/keyword/wrangler\">wrangler</a>.unstable_dev()`はワンチャンあるかなと思ったけど、↑で書いたポイントが損なわれるし、そもそもunstableでうまく動かなかった。</p><p>個人的な需要にはドンピシャのライブラリなので、コレ相当のことが公式ツールセットでできるようになったらいいな〜（中の人見てる〜？）って思いながら、ほそぼそと育てていきたい気持ち。</p>\n\n</div>"
}
