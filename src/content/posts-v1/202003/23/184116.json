{
  "title": "NodeJSのStreamについておさらい",
  "html": "<p>とあるNodeJSのサーバー実装を読んでて、頻出するこいつらに目が慣れてなかったせいで、読み進めるのに時間がかかってた。</p><p>ので、思い出しながら、おさらいがてらメモを残してたので記事にしておく。</p><p>考え方やデザインがどうっていうよりも、コードを読む時に思い出せるようにって感じの切り口になってます。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodejs.org/api/stream.html\">Stream | Node.js v13.12.0 Documentation</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>よくみる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a></h3>\n    \n<ul>\n<li>Readable: ソース</li>\n<li>Writable: 目的地</li>\n<li>Duplex: ReadableでありWritable</li>\n<li>Transform: Duplexと同じだが、その名の通り加工してつなぐ用</li>\n<li>finished()</li>\n<li>pipeline()</li>\n</ul><p>すべてビルトインの`stream`から。</p><p>`finished`と`pipeline`はv10から追加されたもので、それまで同等のことをするには、`readable-stream`を別途インストールして、そこから使ってたぽい。</p><p>ちなみにTypeScriptの型はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/node/stream.d.ts\">DefinitelyTyped/stream.d.ts at master &middot; DefinitelyTyped/DefinitelyTyped &middot; GitHub</a></p>\n\n    </blockquote>\n<p>更新されてずれてそう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>使われ方の基本</h3>\n    <p>Streamはつなげてなんぼなので、まずそのあたりから。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> pipeline <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'stream'</span>);\n\n<span class=\"synComment\">// simple</span>\nreadable.pipe(writable);\n\n<span class=\"synComment\">// pipe chaining</span>\nreadable\n  .pipe(transform)\n  .pipe(writable);\n\n<span class=\"synComment\">// pipeline</span>\npipeline(readable, transform, writable, callback);\npipeline(readable, transform1, transform2, writable, callback);\n</pre><p>こうすると上流である`readable`からデータが流れてく。</p><p>`readable`は`implements Readable`な感じで、`Duplex`でもいい。`writable`も同じく。</p><p>なのでこういうコードもある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pipeline(readable, duplex, callback); <span class=\"synComment\">// duplex as writable</span>\npipeline(duplex, writable, callback); <span class=\"synComment\">// duplex as readable</span>\n</pre><p>readable → duplex → writableという流れ。</p>\n\n<div class=\"section\">\n    <h4>流れるきっかけ</h4>\n    <p>`Readable`なストリームも用意しただけじゃデータは流れない。</p>\n\n<ul>\n<li>`on('data')`する</li>\n<li>`pipe()`する\n<ul>\n<li>内部的に`on('data')`してる</li>\n<li>`pipeline()`も同じ</li>\n</ul></li>\n<li>`resume()`する</li>\n</ul><p>こうすることで流れ出す。</p><p>内部的にも`readableFlowing`というGetterから取れるフラグがある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> r = getReadableStreamSomehow();\nconsole.log(r.readableFlowing); <span class=\"synComment\">// null</span>\n\nr.on(<span class=\"synConstant\">'data'</span>, console.log);\nconsole.log(r.readableFlowing); <span class=\"synComment\">// true</span>\n\nr.pause();\nconsole.log(r.readableFlowing); <span class=\"synComment\">// false</span>\n\nr.resume();\nconsole.log(r.readableFlowing); <span class=\"synComment\">// true</span>\n</pre><p>基本的には`pipe()`だけ使ってれば良いはず。</p><p>ただし、流れるデータを特定の単位で扱いたいとかの要件があるなら、手動で`on('data')`したり`pause/resume()`したりする。</p><p>`on('readable')` / `readable.read()`についてはいったん割愛。</p><p>さて、接続はこれでできるけど、データを流すためにはそれぞれちゃんと実装されてる必要があり・・。<br />\nというわけで実装する側のポイントへ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Readable</h3>\n    <p>いわゆるデータのEmitter。</p><p>パターンに応じて、`_read()`もしくは`read()`を実装する必要がある。</p><p>実装のパターンはいくつかあるけど、結果的には同じ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> Readable <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'stream'</span>);\n\n<span class=\"synComment\">// new はあってもなくても</span>\n<span class=\"synStatement\">const</span> r1 = <span class=\"synStatement\">new</span> Readable(<span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// _read ではない</span>\n  read() <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.push(`$<span class=\"synIdentifier\">{</span><span class=\"synType\">Date</span>.now()<span class=\"synIdentifier\">}\\</span>n`);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>)\n\n<span class=\"synStatement\">const</span> r2 = <span class=\"synStatement\">new</span> Readable();\n<span class=\"synComment\">// read ではない</span>\nr2._read = () =&gt; <span class=\"synIdentifier\">{</span>\n  r2.push(`$<span class=\"synIdentifier\">{</span><span class=\"synType\">Date</span>.now()<span class=\"synIdentifier\">}\\</span>n`);\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synStatement\">const</span> r3 = <span class=\"synStatement\">new</span> <span class=\"synStatement\">class</span> <span class=\"synStatement\">extends</span> Readable <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// read ではない</span>\n  _read() <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.push(`$<span class=\"synIdentifier\">{</span><span class=\"synType\">Date</span>.now()<span class=\"synIdentifier\">}\\</span>n`);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>();\n</pre><p>`new Readable(options)`が一番シュッと書けるけど、`constructor()`でいろいろやりたいのでだいたい`class`で書くことになりそう。</p><p>`Readable`なストリームは、`push()`を使って任意のタイミングでバッファにデータを貯める。<br />\n`push(null)`は特別で、そのストリームのデータの終端を表す。</p><p>`read`と`_read`は空の関数を実装しておいて、任意のタイミングで`push()`する実装例もある。</p><p>この例だと、ものすごい勢いで`Date.now()`が流れるストリームができる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Writable</h3>\n    <p>いわゆるデータのReceiver。</p><p>パターンに応じて、`_write()`もしくは`write()`を実装する必要がある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> Writable <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'stream'</span>);\n\n<span class=\"synStatement\">const</span> w = <span class=\"synStatement\">new</span> Writable(<span class=\"synIdentifier\">{</span>\n  write(data, _encoding, callback) <span class=\"synIdentifier\">{</span>\n    console.log(data);\n    callback();\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>コードの構造は`Readable`と一緒。</p><p>上層からデータが流れてくると、`write()`（か`_write()`）が呼ばれるので、そこでやりたい処理を書く。</p><p>この例だとコンソールに出力するだけのストリーム。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Duplex</h3>\n    <p>`Readable`であり`Writable`でもある。</p><p>なのでパターンに応じて、`read()` or `_read()`および`write()` or `_write()`を実装しないといけない。</p><p>それぞれにバッファがあるのがポイント。<br />\nなのでオプションも`(readable|writable)ObjectMode`と2つあって、`(readable|writable)HighWaterMark`と2つある。</p><p>1人2役できるので便利やけど、コードを読むのがちょっと大変ではある・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Transform</h3>\n    <p>特殊な`Duplex`ストリーム。</p><p>パターンに応じて、`_transform()`か`transform()`を実装する必要がある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> <span class=\"synStatement\">extends</span> Transform <span class=\"synIdentifier\">{</span>\n  _transform(data, encoding, callback) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// transform w/ data</span>\n\n    <span class=\"synComment\">// そして次へ送る</span>\n    <span class=\"synIdentifier\">this</span>.push(transformedData);\n    callback();\n\n    <span class=\"synComment\">// こう書いても同じ</span>\n    <span class=\"synComment\">// callback(null, transformedData);</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>もちろん`push()`をサボってもいい。<br />\nただサボるなら`Transform`である必要はない・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>そのほか</h3>\n    \n<div class=\"section\">\n    <h4>実装すべきメソッド</h4>\n    <p>`_final()`とか`_flush()`とか、ストリームの種類によってはまだいろいろある。</p>\n\n</div>\n<div class=\"section\">\n    <h4>流れるデータの型</h4>\n    <p>基本的に`String`か`Buffer`だが、`{ objectMode: true }`をストリーム初期化時に渡すと、`null`以外の値はそのまま流せるようになる。</p><p>ただし`pipe()`または`pipeline()`でつなぐストリームが同じオプションになってないと、思わぬ挙動になるので注意とのこと。</p>\n\n</div>\n<div class=\"section\">\n    <h4>流れるデータの流量</h4>\n    <p>`highWaterMark`オプションで調整する。</p>\n\n    <blockquote>\n        <p><a href=\"https://techblog.yahoo.co.jp/advent-calendar-2016/node-stream-highwatermark/\">highWaterMark&#x304B;&#x3089;&#x63A2;&#x308B;Node.js&#x306E;Stream&#x306E;&#x4ED5;&#x7D44;&#x307F; - Yahoo! JAPAN Tech Blog</a></p>\n\n    </blockquote>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>finished() / pipeline()</h3>\n    <p>ストリームのエラー検知、後始末に使えるやつ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> finished <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">'stream'</span>);\n\n<span class=\"synStatement\">const</span> rs = getReadableStreamSomehow();\nfinished(rs, err =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (err) <span class=\"synIdentifier\">{</span>\n    console.error(<span class=\"synConstant\">'Stream failed.'</span>, err);\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'Stream is done reading.'</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>`util.promisify(finished)`すれば、PromiseなコードとStreamのコードを混ぜて使える。</p><p>`pipeline()`もそうで、最後に渡したコールバックでまとめてエラー処理ができる。</p><p>同じく`util.promisify(pipeline)`できる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>いざ自分が実装するとなると、もう少し知っておくべきメソッドやらイベントやらがある。</p><p>ただ、なんとなくコードを読むだけならコレで十分なのではないかなーと思う。</p><p>より詳しい記事みつけた。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodesource.com/blog/understanding-streams-in-nodejs\">Understanding Streams in Node.js - NodeSource</a></p>\n\n    </blockquote>\n\n</div>"
}
