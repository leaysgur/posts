{
  "title": "mediasoupの開発Tips",
  "html": "<p>`mediasoup`を使ったサービスを開発する上での役立ちTipsをメモっておきたいなと思ってたので。</p><p>（なんか思いついたらまた追記します。）<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>TransportListenIp</h3>\n    \n    <blockquote>\n        <p><a href=\"https://mediasoup.org/documentation/v3/mediasoup/api/#TransportListenIp\">https://mediasoup.org/documentation/v3/mediasoup/api/#TransportListenIp</a></p>\n\n    </blockquote>\n<p>`Router`の`createWebRtcTransport()`に渡す必須の引数に、`listenIps`というものがあります。</p><p>その名の通り、サーバー側でのWebRTC接続をどこでリスンするかという設定。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> transport = await router.createWebRtcTransport(<span class=\"synIdentifier\">{</span>\n  listenIps : <span class=\"synIdentifier\">[</span> <span class=\"synIdentifier\">{</span> ip: <span class=\"synConstant\">&quot;127.0.0.1&quot;</span>, announcedIp: <span class=\"synConstant\">&quot;88.12.10.41&quot;</span> <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>みたいな感じで指定する。</p><p>`ip`が必須の値で、`announcedIp`が指定されるとそっちがSDPに載る。</p><p>ユーザーから見てサーバーを特定できるIPをSDPに載せる必要があるので、実際にサーバーで動かす場合は必須の値。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a>で渡すなり、起動時に取得するなり、どうにかして自身のIPを知る処理が必要になる。</p><p>ローカルで開発する分には、`ip: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/127.0.0.1\">127.0.0.1</a>`だけ指定すれば一挙両得な感じなので、個人的にはこういう指定にすることが多いです。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> transport = await router.createWebRtcTransport(<span class=\"synIdentifier\">{</span>\n  listenIps : <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{</span> ip: <span class=\"synConstant\">&quot;127.0.0.1&quot;</span> <span class=\"synIdentifier\">}</span>,\n    <span class=\"synIdentifier\">{</span> ip: <span class=\"synConstant\">&quot;0.0.0.0&quot;</span>, announcedIp: process.env.PUBLIC_IP <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>複数の`candidate`がSDPに載ることになるけど、到達できないやつは無視されるだけなので。</p>\n\n</div>\n<div class=\"section\">\n    <h3>コーデック</h3>\n    <p>サーバー側で`Router`を作るときに指定する`mediaCodecs`という指定がすべて。</p><p>そこのリストにないものは、クライアント側で対応してても使えない。<br />\nで、そこで指定できるものの全欄はというと、実はコードで書かれてる。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/versatica/mediasoup/blob/v3/src/supportedRtpCapabilities.ts\">mediasoup/supportedRtpCapabilities.ts at v3 &middot; versatica/mediasoup &middot; GitHub</a></p>\n\n    </blockquote>\n<p>なのでこの全欄から、いくつか推しコーデックを選んで使う or 決め打ちで使うことになる。</p><p>決め打ちの場合はそれをクライアント側でも強制できるけど、そうでない場合で、より優先したいコーデックがあったらどうするか。</p><p>クライアント側で`Producer`をつくるときに、`codec`オプションを指定する。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> producer = await sendTransport.produce(<span class=\"synIdentifier\">{</span>\n  track,\n  codec : device.rtpCapabilities.codecs\n    .find(codec =&gt; codec.mimeType.toLowerCase() === <span class=\"synConstant\">&quot;video/h264&quot;</span>)\n<span class=\"synIdentifier\">}</span>);\n</pre><p>これができるようになったのは最近の`3.6.2`から。</p>\n\n    <blockquote>\n        <p><a href=\"https://mediasoup.org/documentation/v3/tricks/#using-a-different-video-codec-in-each-producer\">mediasoup :: Tricks</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>STUN/TURN</h3>\n    <p>もちろん使えます。<br />\nサーバー側で指定するもよし、クライアント側で指定するもよし。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>としては、`mediasoup-client`側で`Transport`を作るときに渡すようになってる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// サーバー側でWebRtcTransportを作って、そのプロパティを返す</span>\n<span class=\"synStatement\">const</span> transportOptions = await signaling.createTransport();\n\n<span class=\"synComment\">// createRecvTransport()も同様</span>\n<span class=\"synStatement\">const</span> transport = device.createSendTransport(<span class=\"synIdentifier\">{</span>\n  ...transportOptions,\n  iceServers,\n  iceTransportPolicy\n<span class=\"synIdentifier\">}</span>);\n</pre><p>なので、予め指定の設定をサーバー側から返すときに渡してしまってもいいし、クライアント側で指定してもよい。</p><p>クライアント側で動的にアップデートしたい場合、TURNのクレデンシャルを更新したい場合はこう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>transport.updateIceServers(<span class=\"synIdentifier\">{</span> iceServers <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// 必要ならICEをリスタート</span>\n</pre><p>ただし<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>は、現時点でも`RTCPeerConnection#setConfiguration()`が実装されてないので使えない！</p>\n\n</div>\n<div class=\"section\">\n    <h3>クライアントの切断検知</h3>\n    <p>サーバー側で、クライアント側が切断したいことを検知したい場合。<br />\n切断されたならリソース解放とかしたいし、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>としてはよくわかる。</p><p>ただ結論から書くと、`mediasoup`単体だとコレ！っていう解決策はありません。<br />\nWebSocketを貼るなり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ping\">ping</a>/pongする<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/REST%20API\">REST API</a>を作るなりするのが王道。</p><p>少しむずかしい解説すると、`mediasoup`の実装はICE-Liteなので、サーバー側からクライアント側に対して、その経路の死活監視はしてない。<br />\n`webRtcTransport.on(\"icestatechange\")`で状態変更は追えるけど、ちょっとネットワークが揺れて寸断したかの区別がつかない。</p><p>`webRtcTransport.on(\"dtlsstatechange\")`なら追えるか？と思ったけど、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>にバグ（仕様ともいえる）があってダメだった。</p>\n\n    <blockquote>\n        <p><a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=689017\">689017 - chromium - An open-source project to help move the web forward. - Monorail</a></p>\n\n    </blockquote>\n<p>これと似て非なるものかもしれないけど、ページ遷移は拾えるけど、タブ・ブラウザを閉じてしまうとアラートを投げる暇なくプロセスが終了してしまって、サーバー側で検知できない。</p><p>まあいつパケロスしてもおかしくない<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ランドで、こういうことするなという話ですね。</p>\n\n</div>\n<div class=\"section\">\n    <h3>スケーラビリティ</h3>\n    <p>過去にドキュメントの概要を記事にしてるので、まずはそちらを。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/08/16/085517\">mediasoup&#x306E;&#x30B9;&#x30B1;&#x30FC;&#x30E9;&#x30D3;&#x30EA;&#x30C6;&#x30A3;&#x306B;&#x3064;&#x3044;&#x3066; - console.lealog();</a></p>\n\n    </blockquote>\n<p>`mediasoup`を使うときは、あわせて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>用のWebSocketサーバーやWebサーバーを用意すると思うんですが、そうなるとつい手癖で`cluster.fork()`したくなってしまう。</p><p>ただ実際のところ、メディアサーバーとして運用する場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%D5%A5%A3%A5%C3%A5%AF\">トラフィック</a>より先にリソースが枯渇してくるので、マルチプロセス化する意義は薄いかなと。</p><p>Nodeのプロセス1つに対して、`mediasoup`の`Worker`も1つずつ使うようにしてもいいけど、それをやるかどうかは要件との相談になるはず。<br />\n1Workerでさばける接続数が決まってる + Workerをまたぐためにはそれ用のコードが必要になるので。</p><p>1プロセス内での`Worker`もとい`Router`の接続であれば、`mediasoup`が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>として用意してる`pipeToRouter()`が使える。</p>\n\n    <blockquote>\n        <p><a href=\"https://mediasoup.org/documentation/v3/mediasoup/api/#router-pipeToRouter\">https://mediasoup.org/documentation/v3/mediasoup/api/#router-pipeToRouter</a></p>\n\n    </blockquote>\n<p>ただプロセスをまたぐならば、その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>処理を自分で書かないといけなくなるので、そこが判断のポイント。</p><p>まあ、Nodeのプロセスは1つにしてしまって、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%D5%A5%A3%A5%C3%A5%AF\">トラフィック</a>を裁くことは別のサーバーでやるなり設計で回避するほうが筋が良いかなー。</p>\n\n</div>\n<div class=\"section\">\n    <h3>接続状況の可視化</h3>\n    <p>このサーバーで、いまどれだけの`Router`が用意されてて、それぞれにどれだけ`Transport`や`Consumer`がいるのかを知りたい場合。</p><p>それぞれを作る処理を書くときに、あわせてそれ用の状態を管理するのも手ではあるけど、`observer`という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>があるのでそっちを使うほうが便利です。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> resouceMap = <span class=\"synIdentifier\">{}</span>;\n\nmediasoup.observer.on(<span class=\"synConstant\">&quot;newworker&quot;</span>, worker =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> pid <span class=\"synIdentifier\">}</span> = worker;\n  resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span> = <span class=\"synIdentifier\">{</span>\n    router: 0,\n    transport: 0,\n    producer: 0,\n    consumer: 0\n  <span class=\"synIdentifier\">}</span>;\n\n  worker.observer.on(<span class=\"synConstant\">&quot;close&quot;</span>, () =&gt; <span class=\"synStatement\">delete</span> resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>);\n  worker.observer.on(<span class=\"synConstant\">&quot;newrouter&quot;</span>, router =&gt; <span class=\"synIdentifier\">{</span>\n    resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.router++;\n\n    router.observer.on(<span class=\"synConstant\">&quot;close&quot;</span>, () =&gt; resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.router--);\n    router.observer.on(<span class=\"synConstant\">&quot;newtransport&quot;</span>, transport =&gt; <span class=\"synIdentifier\">{</span>\n      resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.transport++;\n\n      transport.observer.on(\n        <span class=\"synConstant\">&quot;close&quot;</span>,\n        () =&gt; resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.transport--\n      );\n      transport.observer.on(<span class=\"synConstant\">&quot;newproducer&quot;</span>, producer =&gt; <span class=\"synIdentifier\">{</span>\n        resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.producer++;\n\n        producer.observer.on(\n          <span class=\"synConstant\">&quot;close&quot;</span>,\n          () =&gt; resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.producer--\n        );\n      <span class=\"synIdentifier\">}</span>);\n      transport.observer.on(<span class=\"synConstant\">&quot;newconsumer&quot;</span>, consumer =&gt; <span class=\"synIdentifier\">{</span>\n        resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.consumer++;\n\n        consumer.observer.on(\n          <span class=\"synConstant\">&quot;close&quot;</span>,\n          () =&gt; resouceMap<span class=\"synIdentifier\">[</span>pid<span class=\"synIdentifier\">]</span>.consumer--\n        );\n      <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>みたくどこかで定義しておくと便利。</p>\n\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    \n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>だとローカルで疎通できない</h4>\n    \n    <blockquote>\n        <p><a href=\"https://mediasoup.discourse.group/t/firefox-ice-failed-add-a-stun-server-and-see-about-webrtc-for-more-details/805\">Firefox: ICE failed, add a STUN server and see about:webrtc for more details - mediasoup-client - mediasoup</a></p>\n\n    </blockquote>\n<p>ローカルで開発してて`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`のIPを指定するのが面倒で`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/127.0.0.1\">127.0.0.1</a>`ってしてる場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>だけ通らない。（自分でIP調べて入れれば動く）</p>\n\n</div>\n</div>"
}
