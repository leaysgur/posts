{
  "title": "PhoenixのChannels/Presenceについて",
  "html": "<p>を、絶賛Elixirかじり中のフロントエンドなエンジニアが使ってみての学びや気付きなどのメモ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>まずは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Phoenix\">Phoenix</a>のアプリを</h3>\n    <p>星の数ほどある記事を参考にして作る。<br />\nただ純<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>・WebSocketサーバーとして<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Phoenix\">Phoenix</a>を使う場合は、`phx.new`する時にオプションでアレコレを捨てておく。</p>\n<pre class=\"code lang-sh\" data-lang=\"sh\" data-unlink>mix phx.new ch_example <span class=\"synSpecial\">--no-brunch</span> <span class=\"synSpecial\">--no-ecto</span> <span class=\"synSpecial\">--no-html</span>\n</pre>\n</div>\n<div class=\"section\">\n    <h3>Channels</h3>\n    <p>さてそんなElixirの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Rails\">Rails</a>的ポジションである<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Phoenix\">Phoenix</a>には、WebSocketをいい感じにラップしたサーバーサイド実装が機能として入ってて、それをChannelsっていう。</p>\n\n    <blockquote>\n        <p><a href=\"https://hexdocs.pm/phoenix/channels.html\">Channels &ndash; Phoenix v1.3.0</a></p>\n\n    </blockquote>\n<p>サーバーサイドでちょろっとコードを書くだけで、簡単にルームが作れてしまうという優れもの。</p><p>クライアントサイドの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>も用意があって、公式は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>のみやけど、3rdからSwiftとか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Java\">Java</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%23\">C#</a>とかのがあるっぽい。</p>\n\n<div class=\"section\">\n    <h4>サーバーでやること</h4>\n    \n<ul>\n<li>Endpointに`socket`のモジュールをリンク</li>\n<li>Socketでルームとしての`channel`やら`transport`をリンク</li>\n<li>Channelでやり取りするメッセージやらJOIN時のふるまいを定義</li>\n</ul><p>このあたりはサンプルも山ほどあるしすぐできる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>クライアントでやること</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>のたったこれだけでできちゃう！</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> Socket <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">'./phoenix.js'</span>;\n\n<span class=\"synComment\">// サーバー側で指定すればLongPollingにもできる</span>\n<span class=\"synStatement\">const</span> socket = <span class=\"synStatement\">new</span> Socket(<span class=\"synConstant\">'ws://localhost:4000/socket'</span>);\nsocket.connect();\n\n<span class=\"synComment\">// `room:`から始まる名前じゃないとダメらしい</span>\n<span class=\"synStatement\">const</span> channel = socket.channel(<span class=\"synConstant\">'room:xxx'</span>);\n\n<span class=\"synComment\">// 見ての通り受け</span>\nchannel.on(<span class=\"synConstant\">'msg'</span>, payload =&gt; <span class=\"synIdentifier\">{</span>\n  console.log(payload);\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// 送りたい時はこれ</span>\nchannel.push(<span class=\"synConstant\">'msg'</span>, <span class=\"synIdentifier\">{</span> body: msg <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// 何はともあれ部屋に入る</span>\nchannel.join()\n  .receive(<span class=\"synConstant\">'ok'</span>, resp =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'Joined successfully'</span>, resp);\n  <span class=\"synIdentifier\">}</span>)\n  .receive(<span class=\"synConstant\">'error'</span>, resp =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'Unable to join'</span>, resp);\n  <span class=\"synIdentifier\">}</span>);\n</pre><p>まあそうですよねという感じ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Presence</h3>\n    <p>日本語記事はまったく見つからなかったけども、Channelsと並んで使えそうなPresenceという機能もある。</p><p>これが何かというと、その名の通り接続中のクライアントの情報を取得するためのもの。オンラインなのは何人？とかそういう。</p>\n\n<div class=\"section\">\n    <h4>サーバーでやること</h4>\n    <pre class=\"code lang-sh\" data-lang=\"sh\" data-unlink>mix phx.gen.presence\n</pre><p>これで`/channels`の下にファイルができる。<br />\nそしてこれを、ApplicationのSupervisorにぶら下げて起動するように。</p><p>って、↑のコマンドを叩いたら標準出力で教えてくれる。</p><p>あとはさっきのChannelsのサンプルに少し足す。</p><p>誰が接続してるのかを識別しないといけないので、それを見るように。</p>\n<pre class=\"code lang-elixir\" data-lang=\"elixir\" data-unlink><span class=\"synComment\"># user_socket.ex</span>\n<span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">connect</span>(params, socket) <span class=\"synStatement\">do</span>\n  {<span class=\"synConstant\">:ok</span>, assign(socket, <span class=\"synConstant\">:user_id</span>, params[<span class=\"synSpecial\">&quot;</span><span class=\"synConstant\">user_id</span><span class=\"synSpecial\">&quot;</span>])}\n<span class=\"synStatement\">end</span>\n</pre><p>ちなみに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンで接続時に認証かけたいときとかもココに書く。</p><p>あとはルーム側。</p>\n<pre class=\"code lang-elixir\" data-lang=\"elixir\" data-unlink><span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">join</span>(<span class=\"synSpecial\">&quot;</span><span class=\"synConstant\">room:xxx</span><span class=\"synSpecial\">&quot;</span>, <span class=\"synComment\">_params</span>, socket) <span class=\"synStatement\">do</span>\n  <span class=\"synComment\"># これが↓のハンドラに飛ぶ</span>\n  <span class=\"synStatement\">send</span>(<span class=\"synIdentifier\">self</span>(), <span class=\"synConstant\">:after_join</span>)\n  {<span class=\"synConstant\">:ok</span>, socket}\n<span class=\"synStatement\">end</span>\n\n<span class=\"synComment\"># ルームに接続した！タイミングのフック</span>\n<span class=\"synPreProc\">def</span> <span class=\"synIdentifier\">handle_info</span>(<span class=\"synConstant\">:after_join</span>, socket) <span class=\"synStatement\">do</span>\n  push(socket, <span class=\"synSpecial\">&quot;</span><span class=\"synConstant\">presence_state</span><span class=\"synSpecial\">&quot;</span>, <span class=\"synType\">Presence</span><span class=\"synStatement\">.</span>list(socket))\n  {<span class=\"synConstant\">:ok</span>, _} <span class=\"synStatement\">=</span> <span class=\"synType\">Presence</span><span class=\"synStatement\">.</span>track(socket, socket<span class=\"synStatement\">.</span>assigns<span class=\"synStatement\">.</span>user_id, %{\n    <span class=\"synConstant\">online_at:</span> inspect(<span class=\"synType\">System</span><span class=\"synStatement\">.</span>system_time(<span class=\"synConstant\">:seconds</span>))\n  })\n  {<span class=\"synConstant\">:noreply</span>, socket}\n<span class=\"synStatement\">end</span>\n</pre><p>サーバーサイドはこれで以上。</p>\n\n</div>\n<div class=\"section\">\n    <h4>クライアントでやること</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> Socket, Presence <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">'./phoenix.js'</span>;\n\n<span class=\"synStatement\">const</span> socket = <span class=\"synStatement\">new</span> Socket(<span class=\"synConstant\">'ws://localhost:4000/socket'</span>, <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// 本来はちゃんとした一意に識別するなにか</span>\n  params: <span class=\"synIdentifier\">{</span> user_id: <span class=\"synStatement\">window</span>.<span class=\"synStatement\">location</span>.hash, <span class=\"synIdentifier\">}</span>,\n<span class=\"synIdentifier\">}</span>);\nsocket.connect();\n\n<span class=\"synStatement\">const</span> channel = socket.channel(<span class=\"synConstant\">'room:xxx'</span>);\n\n<span class=\"synComment\">// Elixirが関数型な影響で、JavaScriptでもそう書いちゃうらしい</span>\n<span class=\"synIdentifier\">let</span> presences = <span class=\"synIdentifier\">{}</span>;\n<span class=\"synComment\">// 初期の状態はこのイベント（一度きり）</span>\nchannel.on(<span class=\"synConstant\">'presence_state'</span>, state =&gt; <span class=\"synIdentifier\">{</span>\n  presences = Presence.syncState(presences, state);\n  console.log(<span class=\"synConstant\">'state'</span>, presences);\n<span class=\"synIdentifier\">}</span>);\n<span class=\"synComment\">// 以降、なにか差分が出たらこっちのイベント</span>\nchannel.on(<span class=\"synConstant\">'presence_diff'</span>, diff =&gt; <span class=\"synIdentifier\">{</span>\n  presences = Presence.syncDiff(presences, diff);\n  console.log(<span class=\"synConstant\">'diff'</span>, presences);\n<span class=\"synIdentifier\">}</span>);\n\nchannel.join()\n  .receive(<span class=\"synConstant\">'ok'</span>, resp =&gt; <span class=\"synIdentifier\">{</span> console.log(<span class=\"synConstant\">'Joined successfully'</span>, resp); <span class=\"synIdentifier\">}</span>)\n  .receive(<span class=\"synConstant\">'error'</span>, resp =&gt; <span class=\"synIdentifier\">{</span> console.log(<span class=\"synConstant\">'Unable to join'</span>, resp); <span class=\"synIdentifier\">}</span>);\n</pre><p>`presence_diff`では、差分が`{ leaves: {}, joins: {} }`ってな感じで送られてくる。<br />\nなので`syncDiff()`に現状とあわせて渡すことで、`presence_state`時と同じようにたたんでくれる。</p><p>ちなみに、`Presence.list()`なるメソッドも用意されてる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// ただfnでイテレートできるだけの関数</span>\nPresence.list(presences, fn);\n</pre><p>自分たちで差分を管理するぜ！って場合は、`Precense`自体必要ない。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>側のコードが別に関数型を指向してないときは、なんかココ気持ち悪いな・・ってなる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>フロントエンドとしては、別にElixirで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Phoenix\">Phoenix</a>だろうがNode.jsでSocket.IOだろうが、どちらにせよただのWebSocketなので大差ない感じ。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Phoenix\">Phoenix</a>のJSは大した長さじゃないので、自分で書いてもいいとは思う。<br />\nもうこのご時世なのでLongPollingは捨てる！って場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>のコードを半分くらい減らせる(˘ω˘ )</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/phoenixframework/phoenix/blob/master/assets/js/phoenix.js\">phoenix/phoenix.js at master &middot; phoenixframework/phoenix &middot; GitHub</a></p>\n\n    </blockquote>\n<p>なんでもいいけどこの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>のコード、ファイル分けてくれんかな・・。</p>\n\n</div>"
}
