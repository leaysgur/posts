{
  "title": "アクセストークンをWebWorkerで扱う",
  "html": "<p>というアプローチを紹介してる記事があって、なるほど？と思ったのでまとめてみる。</p><p>元記事はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://thenewstack.io/leveraging-web-workers-to-safely-store-access-tokens\">Leveraging Web Workers to Safely Store Access Tokens &ndash; The New Stack</a></p>\n\n    </blockquote>\n<p>毎度のことながら、今にはじまったことではない。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>元記事いわく</h3>\n    <p>WebWorkerであれば、メインスレッドで実行されるであろう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/XSS\">XSS</a>や3rdのコードから触れないので安全！</p><p>設計としては、</p>\n\n<ul>\n<li>メイン: まず`Worker`をロード</li>\n<li>メイン: 初期化のメッセージを`postMessage()`\n<ul>\n<li>クレデンシャルがあるならそれを渡す</li>\n</ul></li>\n<li>ワーカー: アクセス<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンの準備\n<ul>\n<li>受け取ったやつ or そこで`fetch()`して、オンメモリに保存</li>\n</ul></li>\n<li>（これで準備OK）</li>\n<li>メイン: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>にリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トしてほしいと`postMessage()`</li>\n<li>ワーカー: <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>に向けてアクセス<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンつけて`fetch()`</li>\n<li>ワーカー: レスポンスをメインスレッドに`postMessage()`</li>\n<li>メイン: それを受け取って使う！</li>\n</ul><p>大事なのは、アクセスできる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>のリストを、ワーカー内に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DB%A5%EF%A5%A4%A5%C8%A5%EA%A5%B9%A5%C8\">ホワイトリスト</a>として定義しておくこと。<br />\nそうすることで、メインスレッドから悪意のあるコードによって、意図しない<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C9%A5%E1%A5%A4%A5%F3\">ドメイン</a>に送信されることがない。</p><p>ただしWebWorker自体のライフサイクルはそのセッションと同じで、永続化ができるわけではない。<br />\nとはいえ、最近のAuthベンダーであれば、セキュアなセッション<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Cookie\">Cookie</a>を使ってユーザー入力なくアクセス<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンを更新できるはずなので、UXに影響はないであろう。</p><p>とのこと。</p>\n\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>この記事を読み始めたときは、「LocalStorageを使わなくても、WebWorkerならセキュアに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンを永続化できる・・？」って思ってたけど、まったく関係のない話だった。言われてみれば当然なんやけど、なぜか永続化の話だと思いこんでしまってた。</p><p>「大事な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンを一瞬たりともメインスレッドに置きたくない！」というのを実現する方法としては、実装<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%B9%A5%D1\">コスパ</a>としては妥当なのかな〜と思った。（ワーカー内にスコープが狭まっただけではあるけど）</p><p>あとは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ンそれ自体のIOだけを隠蔽するのでは不十分で、結局それがリク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トに載っていくならば、`fetch()`なんかも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/XSS\">XSS</a>の対象になることを忘れるなということかね。</p><p>Auth0のSPA用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>でも、オンメモリのStorage + FetcherとしてWebWorkerを使うようになってた。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/auth0/auth0-spa-js/pull/409\">[SDK-1516] Use Web Workers for token endpoint call for in-memory storage by adamjmcgrath &middot; Pull Request #409 &middot; auth0/auth0-spa-js &middot; GitHub</a></p>\n\n    </blockquote>\n<p>あとWebWorker使えっていう話は、Auth0のドキュメントにも書かれてた。</p>\n\n    <blockquote>\n        <p><a href=\"https://auth0.com/docs/security/data-security/token-storage\">Token Storage</a></p>\n\n    </blockquote>\n<p>ちなみに先行実装とかないかなーと思って探したけど、見つけられたのはこれだけだった。</p>\n\n<ul>\n<li><a href=\"https://gitlab.com/jimdigriz/oauth2-worker\">https://gitlab.com/jimdigriz/oauth2-worker</a></li>\n</ul><p>まあやるからには自作するか・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>永続化は結局どうする</h3>\n    <p>元記事は大丈夫って言ってるけど、実際には3rdの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Cookie\">Cookie</a>に対する風向きも微妙な昨今では、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Cookie\">Cookie</a>に頼る方法はぜんぜん大丈夫じゃないと思う。</p><p>となるとやはりリフレッシュ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%AF\">トーク</a>ン + ローテーションを必須にしつつ、LocalStorageに入れるしかないんやろうけど、なんかもっと画期的なソリューションは出てこないもんかね〜。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> auth0 = await createAuth0Client(<span class=\"synIdentifier\">{</span>\n    domain: <span class=\"synConstant\">'&lt;your Auth0 domain&gt;'</span>,\n    client_id: <span class=\"synConstant\">'&lt;your Auth0 client ID&gt;'</span>,\n    cacheLocation: <span class=\"synConstant\">'localstorage'</span>,\n    useRefreshTokens: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n    \n<span class=\"synComment\">// Logging-in will automatically request the offline_access scope</span>\n<span class=\"synComment\">// and store the resulting refresh token</span>\nauth0.loginWithRedirect();\n    \n<span class=\"synComment\">// Silently refreshing the access token will use the /token endpoint</span>\n<span class=\"synComment\">// with ‘refresh_token’ grant and the refresh token from the cache</span>\nawait auth0.getTokenSilently();\n</pre><p>`auth0-spa.js`だとこんな感じのコードになるらしい。</p>\n\n    <blockquote>\n        <p><a href=\"https://auth0.com/blog/secure-browser-storage-the-facts/\">Secure Browser Storage: The Facts</a></p>\n\n    </blockquote>\n<p>こっちの記事もブラウザのストレージまわりについてよくまとまってたのでおすすめ。</p>\n\n</div>"
}
