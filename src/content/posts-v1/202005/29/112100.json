{
  "title": "Svelte 3の仕組みとその手触り",
  "html": "<p>実は最近まとまった時間ができたので、フロントエンド勘を取り戻すためにも、ずっと気になってたSvelteを触ってみてる。</p><p>一通りDocsやTutorialに目を通しきったところで、備忘録も兼ねて記事を書いておこうかと思った次第。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/blog/svelte-3-rethinking-reactivity\">Svelte 3: Rethinking reactivity</a></p>\n\n    </blockquote>\n<p>Svelteは`3`が最新のメジャーバージョンで、これがリリースされたのは2019年の4月のこと。<br />\nなんと1年も前の話なのでぜんぜん今さらではあるけど、まだ1年しか経ってないとも取れる・・はず。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>モチベーション</h3>\n    <p>冒頭の記事の中にある、Rethinking reactivityっていう公演の動画を見てハッとしたから。</p><p>動画の説明文を引用するとこんな具合。</p>\n\n    <blockquote>\n        <p>Modern <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a> frameworks are all about reactivity. Change your application's state, and the view updates automatically. But there's a catch — tracking state changes at runtime adds overhead that eats into your bundle size and performance budgets. In this <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/talk\">talk</a>, we'll discover an <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/alternative\">alternative</a> approach: moving reactivity into the language itself. Your apps have never been smaller or faster than they're about to become.</p>\n\n    </blockquote>\n<p>これは・・気になる！</p><p>思えばまだ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Android\">Android</a> 2.3とかカクカクの端末と戦ってた頃、ある日突然「これからはReactだ！VirtualDOMだ！」とか言われて、全然納得できてなかったのを思い出した。</p><p>あとはMobX信者としても、単純にReactivityの実装も気になるし、ひとつ試してみるか！ということで。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Svelteの概要</h3>\n    \n<ul>\n<li>ReactなどのUIライブラリとは違い、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>（とそのランタイム）\n<ul>\n<li>もちろんVirtualDOMでもない</li>\n</ul></li>\n<li>いわばSvelte言語を書くと、いい感じに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>される\n<ul>\n<li>とはいってもHTML/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSS\">CSS</a>/JSがベース</li>\n<li>なのでランタイムが最低限に抑えられて、効率的であり軽くもなる</li>\n</ul></li>\n<li>Svelte言語は基本的に直感的でわかりやすい\n<ul>\n<li>`markup`部のディレクティブまわりとかは、Vue|Angularのそれに似ているといえば似ている</li>\n<li>むしろ既成概念がない方が扱いやすいかもしれない</li>\n<li>むしろ何も知らなくても扱えるというのはメリットかもしれない</li>\n</ul></li>\n</ul><p>とりあえず書けば動く！Write less code！を地で行く感じがあって、とっつきやすさもよいなと思った。</p><p>フロントエンド界隈にありがちな、また雨後の竹の子が・・っていうパターンではないってのがミソ。</p>\n\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>がやってること</h3>\n    <p>コントリビューターの人が書いてる記事があって、仕組みを知りたい人は必読。</p>\n\n    <blockquote>\n        <p><a href=\"https://lihautan.com/the-svelte-compiler-handbook\">The Svelte Compiler Handbook | Tan Li Hau</a></p>\n\n    </blockquote>\n<p>`*.svelte`なファイルは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時にまずASTにされて、そこからあれこれ処理されていくらしい。</p><p>そしてその詳細が、また別のシリーズになってる。</p>\n\n    <blockquote>\n        <p><a href=\"https://lihautan.com/compile-svelte-in-your-head-part-1\">Compile Svelte in your head (Part 1) | Tan Li Hau</a></p>\n\n    </blockquote>\n<p>Reactivityを実現してるところだけをすごい雑に説明すると、\"<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に\"こんな感じの変換が行われる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これが</span>\n<span class=\"synStatement\">const</span> update = () =&gt; count++;\n\n<span class=\"synComment\">// こうなる</span>\n<span class=\"synStatement\">const</span> update = () =&gt; $$invalidate(0, count++, count);\n</pre><p>こんな感じの変換が、値の再代入やアップデート、テンプレでの参照が行われてる箇所ぜんぶに対して行われる！<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>後のコードを見るとわかるけど、もし値が変更されていたら（dirtyだったら）みたいな`if`分が大量に生成される。</p><p>で、この`$$invalidate()`が、再描画が必要かどうかチェックしたりしてて、必要なら再描画がスケジュールされる。</p><p>というように、ここがMobXとかのライブラリとの違いで、\"Observableな値の更新があったら、それに関連付けられたこの関数を呼ぶみたいな機構そのもの\"が、ランタイムに落ちてこないのがSvelteの特徴的なところ。</p><p>↑の記事にもあるけど、dirtyかどうかのチェックにはビット演算が使われてて（`v3.16.0`から）、ランタイムの最適化の気概が感じられてよかった。<br />\nあと描画の処理も`Promise.then()`で投げられるので、MicrotaskになってUIをブロックしないとか。</p><p>この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は他にもなかなかに賢くて、Reactだと`onClick`にインライン関数書くと毎回無駄になるけど、それも最適化してくれたりする。</p><p>（「最小のコード片を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>したコード全部読む」記事、今度書こうかな・・・。）</p><p>ある程度以上の規模になってくると、ファイルサイズが実装よりも膨れてくるのでは？と思ったりもしたけど、そもそもそんな巨大コードつくるなCode Splittingしろって話か・・・！</p>\n\n</div>\n<div class=\"section\">\n    <h3>使い勝手</h3>\n    <p>本家サイトにある、Tutorialがよくできてて、順にやっていくとすごいわかった気になれる。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/tutorial/basics\">Introduction / Basics &bull; Svelte Tutorial</a></p>\n\n    </blockquote>\n<p>そんな中からいくつか「これは！」ってなったやつをご紹介。</p>\n\n<div class=\"section\">\n    <h4>Reactive declarations / statements</h4>\n    <p>MobXでいう`computed`で、自動的に導出される値ってやつ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">let</span> count = 0;\n<span class=\"synComment\">// コレ</span>\n$: doubled = count * 2;\n</pre><p>なんじゃこりゃ！って最初は思ったけど、label文っていうちゃんとした<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の言語機能らしい。</p><p>Svelteでは`$:`で宣言すると、その中で依存している値の更新にあわせてReactiveに機能するようになる。</p><p>そこにはフックされる関数も何もなく、正にReactivityを宣言的に記述できる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// ブロックもおけるので関数も書ける</span>\n$: <span class=\"synIdentifier\">{</span>\n  console.log(count);\n<span class=\"synIdentifier\">}</span>\n<span class=\"synComment\">// まさかのロジックまで</span>\n$: <span class=\"synStatement\">if</span> (count &gt;= 10) <span class=\"synIdentifier\">{</span>\n  console.log(`count: $<span class=\"synIdentifier\">{</span>count<span class=\"synIdentifier\">}</span> is dangerously high!`);\n  count = 9;\n<span class=\"synIdentifier\">}</span>\n</pre><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>だからこそ為せるワザ・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Await blocks</h4>\n    <p>`markup`部で、`Promise`の解決を待てちゃう。</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink>{#await promise}\n  <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>...waiting<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>\n{:then number}\n  <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>The number is {number}<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>\n{:catch error}\n  <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>{error.message}<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">p</span><span class=\"synIdentifier\">&gt;</span>\n{/await}\n</pre><p>お手軽さがすごい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Binding this</h4>\n    <p>いわゆるReactでいう`ref`のこと。</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink><span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\">&gt;</span>\n<span class=\"synSpecial\">  </span><span class=\"synStatement\">import</span><span class=\"synSpecial\"> </span><span class=\"synIdentifier\">{</span><span class=\"synSpecial\"> onMount </span><span class=\"synIdentifier\">}</span><span class=\"synSpecial\"> from </span><span class=\"synConstant\">&quot;svelte&quot;</span><span class=\"synSpecial\">;</span>\n\n<span class=\"synSpecial\">  </span><span class=\"synIdentifier\">let</span><span class=\"synSpecial\"> canvas;</span>\n<span class=\"synSpecial\">  onMount</span>(()<span class=\"synSpecial\"> =&gt; </span><span class=\"synIdentifier\">{</span>\n<span class=\"synSpecial\">    </span><span class=\"synStatement\">const</span><span class=\"synSpecial\"> ctx = canvas.getContext</span>(<span class=\"synConstant\">&quot;2d&quot;</span>)<span class=\"synSpecial\">;</span>\n<span class=\"synSpecial\">  </span><span class=\"synIdentifier\">}</span>)<span class=\"synSpecial\">;</span>\n<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\">&gt;</span>\n\n<span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">canvas</span><span class=\"synIdentifier\"> bind:this=</span><span class=\"synConstant\">{canvas}</span><span class=\"synIdentifier\">&gt;&lt;/</span><span class=\"synStatement\">canvas</span><span class=\"synIdentifier\">&gt;</span>\n</pre><p>`onMount()`を待たないと、`undefined`になってしまうので注意。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Builtin store module</h4>\n    <p>`script`部で宣言した変数は、自動的に`markup`部で参照して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%F3%A5%C7%A5%A3%A5%F3%A5%B0\">バインディング</a>される。</p><p>けど、それ以外に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>のスコープをまたいだ状態を管理するための変数が欲しくなるはず・・。</p><p>で、なんとそれ用の仕組みもSvelteには用意されてて、それらは`svelte/store`で`import`できる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> writable <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;svelte/store&quot;</span>;\n\n<span class=\"synStatement\">const</span> count = writable(0);\n\n<span class=\"synStatement\">const</span> unsubscribe = count.subscribe(value =&gt; <span class=\"synIdentifier\">{</span>\n\tconsole.log(value);\n<span class=\"synIdentifier\">}</span>); <span class=\"synComment\">// logs '0'</span>\n\ncount.set(1); <span class=\"synComment\">// logs '1'</span>\ncount.update(n =&gt; n + 1); <span class=\"synComment\">// logs '2'</span>\n</pre><p>手動で`subscribe()`する代わりに、`$count`という感じで自動で参照することもできて、`markup`部に埋めるときはこっちが便利。</p><p>あとは、</p>\n\n<ul>\n<li>`writable()`な値以外に、`readable()`な値も定義できる</li>\n<li>storeの値からさらに導出する`derived()`というヘルパーもある</li>\n<li>`subscribe()`と`set()`メソッドさえ実装すれば、それを独自のstoreとして扱える\n<ul>\n<li><a href=\"https://svelte.dev/docs#Store_contract\">https://svelte.dev/docs#Store_contract</a></li>\n</ul></li>\n</ul><p>なかなかかゆいところに手が届く・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Builtin motion/transition/animation</h4>\n    <p>storeだけでなく、こんなものまである。</p><p>`writable()`の代わりに、`svelte/motion`から`tweened()`を使うだけで、それだけTweeningして値を設定できるようになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> tweened <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">'svelte/motion'</span>;\n<span class=\"synStatement\">const</span> progress = tweened(0);\n</pre><p>モーションの微調整もできるし、イージング関数も`svelte/easing`にあるものが標準で使える。</p><p>また、`markup`にちょろっと書くだけでフェードインやブラーのエフェクトがつけられる・・・。</p><p>楽ちん。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Module context</h4>\n    <p>普通の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>は`script`要素の中に書ける + 通常は`*.svelte`ファイル内に1つしか置けない。</p><p>ただし、`context=\"module\"`を指定したものは、複数の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>からまたいで参照できる。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/tutorial/module-exports\">Module context / Exports &bull; Svelte Tutorial</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>そのほか</h4>\n    \n<ul>\n<li>Context <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>\n<ul>\n<li>上層の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>で`setContext(key, context)`したものを、下層の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>で`getContext(key)`できる</li>\n</ul></li>\n<li>`createEventDispatcher()`\n<ul>\n<li>その名の通り、独自のイベントを`dispatch()`できる</li>\n<li>中身はただのDOMの`CustomEvent`</li>\n</ul></li>\n<li>`svelte`要素\n<ul>\n<li>`:window bind:scrollY={y}`とかできる\n<ul>\n<li>ほかには`innerWidth`とかある</li>\n<li>雑な高頻度<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>が書かれることを事前に阻止してる・・！</li>\n</ul></li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>開発体験</h3>\n    <p>まだちゃんとしたアプリは書いてないけど、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Hello%20world\">Hello world</a>レベルでわかったこと。</p>\n\n<ul>\n<li>コードを書き始めるのにテンプレートが用意されてる\n<ul>\n<li><a href=\"https://github.com/sveltejs/template\">https://github.com/sveltejs/template</a></li>\n<li>アンチ`create-react-app`派閥としては悩ましいけど、むちゃくちゃ薄いので許す</li>\n</ul></li>\n<li>ESLintもPrettierも使える\n<ul>\n<li>それ用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>は必要\n<ul>\n<li><a href=\"https://github.com/sveltejs/eslint-plugin-svelte3\">https://github.com/sveltejs/eslint-plugin-svelte3</a></li>\n<li><a href=\"https://github.com/sveltejs/prettier-plugin-svelte\">https://github.com/sveltejs/prettier-plugin-svelte</a></li>\n</ul></li>\n</ul></li>\n<li>TypeScriptは、preprocessorを通して制限つきで使える\n<ul>\n<li>`script`部でだけ機能する（`markup`部とは連携しない）らしい</li>\n<li>LanguageServerはもっかWIPだそうな\n<ul>\n<li><a href=\"https://github.com/sveltejs/language-tools/issues/83\">https://github.com/sveltejs/language-tools/issues/83</a></li>\n</ul></li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSS\">CSS</a> in JSもできる\n<ul>\n<li><a href=\"https://svelte.dev/blog/svelte-css-in-js\">Using CSS-in-JS with Svelte</a></li>\n</ul></li>\n<li>エコシステムは当然まだまだこれから\n<ul>\n<li>npmのモジュールとかは普通に使えるので困ってないけど</li>\n</ul></li>\n<li>まだまだバグとかコーナーケースはありそう\n<ul>\n<li>そういうもんよね</li>\n</ul></li>\n</ul><p>パッと思い浮かんだ手の届かないところは、コミュニティとしても認識してるっぽく、だいたいFAQに書いてあった。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/faq\">Frequently Asked Questions &bull; Svelte</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D1%A5%E9%A5%C0%A5%A4%A5%E0\">パラダイム</a>がそもそも違うので、よしあしの判断は前提条件に依りそうかなーと思った。<br />\n（なので「XXXより良い！」とか簡単に言えない）</p>\n\n    <blockquote>\n        <p><a href=\"https://gist.github.com/Rich-Harris/0f910048478c2a6505d1c32185b61934\">https://gist.github.com/Rich-Harris/0f910048478c2a6505d1c32185b61934</a></p>\n\n    </blockquote>\n<p>Svelte is a language.</p><p>ほんとその一言に尽きるというところで、人は選びそう。<br />\n個人的にはバランスがとてもいいなと思ったし、便利ながらも遊びが残された<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>たちにはとても好感が持てた。（使い手の練度を要求するあたり）</p><p>あとはなにより\"早くて軽い\"は正義。</p>\n\n    <blockquote>\n        <p><a href=\"https://twitter.com/sveltejs/status/1088500539640418304\">Svelte on Twitter: &quot;Svelte gets to those hard-to-reach places other frameworks can&#39;t.&hellip; &quot;</a></p>\n\n    </blockquote>\n<p>非力な端末でいい感じに動くというだけでも採用する理由になるなとも。</p><p>まあまだまだこれから感は否めず、バグもそれなりにありそうなので、地雷を踏み抜きながら見守っていこうかと。<br />\nとりあえず手元にあるちょうどいいプロジェクトを書き直してみようと思ってます。</p><p>そういえばReactでいうNext.jsの立ち位置で、SvelteにもSapperというのがあるらしいけど、それはまた追々。</p>\n\n</div>"
}
