{
  "title": "JavaScriptでWebRTCやるための基礎知識",
  "html": "<p>未来の自分のためのメモです。<br />\n仕事でやってないせいですぐ忘れるし、都度思い出すの大変なので・・。</p><p>ただまぁだいたいの人はSkyWayとかEasyRTCとか何かしらのライブラリを使うはずで、そういう人たちにはあまり関係ない内容かも。<br />\n生のjsでWebRTCを書くときに、先に知っておきたかった系のメモです。</p><p>素人ではないがベテランでもない、そんな微妙な知識レベルだと思います。</p>\n\n    <blockquote>\n        <p>まだ枯れた仕様ではないので、記事を読む時は日付に注意してください...</p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>WebRTC is 何</h3>\n    \n<ul>\n<li>WebでRealTimeCommunicationできる仕様\n<ul>\n<li>もといクライアントどうしで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>で通信できる仕様やその<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>群</li>\n<li>See <a href=\"https://webrtc.org/\">WebRTC Home | WebRTC</a></li>\n</ul></li>\n<li>仕様まわり\n<ul>\n<li><a href=\"https://w3c.github.io/webrtc-pc/\">WebRTC 1.0: Real-time Communication Between Browsers</a></li>\n<li><a href=\"https://w3c.github.io/webrtc-stats/\">Identifiers for WebRTC&#39;s Statistics API</a></li>\n<li><a href=\"https://w3c.github.io/mediacapture-main/\">Media Capture and Streams</a></li>\n<li>などなど</li>\n</ul></li>\n</ul><p>リアルタイムっても既にWebSocketとかあるやんとかいう気持ちはあるやろうけどそれはそれ、これはこれ。</p>\n\n<ul>\n<li>ブラウザのカメラやマイクなどをストリームとして拾う・拾われたストリームを再生する</li>\n<li>実際に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>で通信する</li>\n</ul><p>この2つが大きな概念で、これらを組み合わせて使う。<br />\n簡単にいうと、いわゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>のビデオ・音声チャットがブラウザだけで作れるぜ！っていうやつ。</p><p>というわけでこの2本柱についてそれぞれ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>MediaStream</h3>\n    <p>`DataChannel`（少しだけ後述）みたいなものもあるけど、基本的にWebRTCでやりたいのは互いのストリームを送り合うこと。<br />\nなので送るために取得するし、送られてきたのを取り扱う必要がある。</p>\n\n<div class=\"section\">\n    <h4>ストリームの取得</h4>\n    <p>まず取得。</p>\n\n<ul>\n<li>`navigator.mediaDevices.getUserMedia()` <- パソコンのカメラやマイクから</li>\n<li>`$<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/canvas\">canvas</a>.captureStream()` <- <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/canvas\">canvas</a>要素から</li>\n<li>`($audio|$video).captureStream()` <- 将来的にはaudio要素やvideo要素からも</li>\n</ul><p>などなど取得する方法はいろいろある。<br />\nWebRTCなら`getUserMedia()`っしょ！みたいなところもあるかもしれないが、それだけではないということ。<br />\nたとえばお絵かきアプリの`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/canvas\">canvas</a>`の様子もストリームとして送れる。</p><p>ちなみにこれらストリームは仕様的には`MediaStream`って呼んだりする。<br />\n`MediaStream`はいくつかの`MediaStreamTrack`から成るもので、音声つきの映像ストリームの場合、</p>\n\n<ul>\n<li>`audio`のTrack</li>\n<li>`video`のTrack</li>\n</ul><p>ってな感じになってる。<br />\n音声がないならVideoTrackがひとつだけ。</p><p>このTrackとStreamの関係を知っておくべし。</p>\n\n</div>\n<div class=\"section\">\n    <h4>getUserMedia <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/a.k.a.\">a.k.a.</a> gUM</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>navigator.mediaDevices.getUserMedia(options)\n  .then(successCallback)\n  .<span class=\"synStatement\">catch</span>(errorCallback);\n\n<span class=\"synIdentifier\">function</span> successCallback(stream) <span class=\"synIdentifier\">{}</span>\n<span class=\"synIdentifier\">function</span> errorCallback(err) <span class=\"synIdentifier\">{}</span>\n</pre>\n<ul>\n<li>昔は`navigator.getUserMedia()`でアクセスしてた</li>\n<li>最近はPromiseが返ってくるけど、以前はコールバックをそれぞれ渡してた</li>\n</ul><p>`options`で指定してるところは`MediaStreamConstraints`なるもので、IDL的には、</p>\n<pre class=\"code lang-java\" data-lang=\"java\" data-unlink>dictionary MediaStreamConstraints {\n    (<span class=\"synType\">boolean</span> or MediaTrackConstraints) video = <span class=\"synConstant\">false</span>;\n    (<span class=\"synType\">boolean</span> or MediaTrackConstraints) audio = <span class=\"synConstant\">false</span>;\n};\n</pre><p>という感じに`video`と`audio`をそれぞれオブジェクト（`MediaTrackConstraints`） or Boolで指定する。</p>\n\n<ul>\n<li>キャプチャするサイズとか</li>\n<li>解像度とか</li>\n<li>モバイルだとフロントカメラ or リアカメラ</li>\n</ul><p>仕様的には`MediaTrackConstraints`で色々指定できるようにはなってるけど、それがきっちりどの環境でも反映されるかというと、そうではなさ気。<br />\nてか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>でだけ使える設定とかもあった気がする。</p>\n\n    <blockquote>\n        <p><a href=\"https://w3c.github.io/mediacapture-main/#idl-def-mediatrackconstraints\">Media Capture and Streams</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>ストリームの再生</h4>\n    <p>`audio`や`video`から取れるってことは、それで再生もできるってこと。<br />\n`autoPlay`が効かなくてハマるとかそういうのはWebRTCに関係なくあるのでよしなに。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> $video = <span class=\"synStatement\">document</span>.createElement(<span class=\"synConstant\">'video'</span>);\n$video.autoPlay = <span class=\"synConstant\">true</span>;\n\n<span class=\"synComment\">// 自身のストリーム or</span>\n<span class=\"synComment\">// なんらかの手段で取得したP2P相手のストリーム</span>\n$video.srcObject = stream;\n<span class=\"synComment\">// or</span>\n$video.src = URL.createObjectURL(stream);\n</pre><p>`audio`要素にもそのままストリームをつっこんで良くて、AudioTrackがあれば音が流れる。<br />\nもちろん、WebAudioAPIの`MediaStreamAudioSourceNode`も使える。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> ctx = <span class=\"synStatement\">new</span> AudioContext();\n<span class=\"synStatement\">const</span> source = ctx.createMediaStreamSource(stream);\nsource.connect(ctx.destination);\n</pre><p>こうすると音声レベルとかも取れるので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>にも便利。</p><p>ちなみにこの`MediaStream`には`stop()`的なメソッドは存在せず、各Track側に`stop()`があるので、根本から再生停止したい時にはご注意。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 全部止める</span>\nstream.getTracks().forEach(track =&gt; track.stop());\n</pre><p>さて、ストリームの扱いはわかったが、それをどうやって取得してくるか。<br />\nつまりは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>通信する本丸を。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>RTCPeerConnection</h3>\n    <p>そんなストリームを使って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>、つまりPeerToPeerで通信するためのオブジェクト。<br />\nこれを把握すること = 素の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>でWebRTCすることに等しい。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> peer = <span class=\"synStatement\">new</span> RTCPeerConnection(options);\n</pre><p>これが、通信したい相手「ごと」に必要になる。<br />\nつまりブラウザAがブラウザBと通信するために1つ、新たにブラウザCと通信するならもう1つ必要。</p><p>単一のPeerConnectionでもって複数人と通信・・はできない仕様なので、相手ごとにこのPeerConnectionとさっきのMediaStreamを良い感じに取り回すのがjs実装のキモ。</p><p>後々でさっき手に入れておいた自身のストリームをセットして使うことになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>peer.addStream(stream);\n</pre>\n<div class=\"section\">\n    <h4>Offer / Answerモデル</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>で通信するためには、</p>\n\n<ul>\n<li>ピアAがOfferを作って出す</li>\n<li>ピアBはそれを受けてAnswerを作って出す</li>\n<li>ピアAがそのAnswerを受け取る</li>\n</ul><p>このSYN-ACK的なやり取りがあってはじめてつながる。</p><p>なので、複数人とつながる場合には各ピアがそれぞれ各ピアとコレをやる必要がある。<br />\n正直面倒くさいけどそういう仕様。</p>\n\n<div class=\"section\">\n    <h5>どういうコードでやるか</h5>\n    <p>`RTCPeerConnection`に生えてる各メソッドを使う。</p>\n\n<ul>\n<li>`createOffer()`</li>\n<li>`createAnswer()`</li>\n<li>`setLocalDescription()`</li>\n<li>`setRemoteDiscripution()`</li>\n</ul><p>その際にやり取りされるものが、SDPと呼ばれるもの。</p><p>すごいざっくりしたコードを書くと、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// [1] A -&gt; BのOffer</span>\npeerA.createOffer()\n  .then(sdp =&gt; peerA.setLocalDescription(sdp))\n  .then(() =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// これをなんとかして送る</span>\n    <span class=\"synStatement\">const</span> sdpOfA = peerA.localDescription;\n  <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// [2] B -&gt; AのAnswer</span>\npeerB.setRemoteDescription(sdpOfA)\n  .then(() =&gt; peerB.createAnswer())\n  .then(sdp =&gt; peerB.setLocalDescription())\n  .then(() =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// これをなんとかして送り返す</span>\n    <span class=\"synStatement\">const</span> sdpOfB = peerB.localDescription;\n  <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// [3] A &lt;-&gt; Bの接続が確立</span>\npeerA.setRemoteDescription(sdpOfB)\n</pre><p>という感じ。<br />\nこれも昔はPromiseですらなく普通のコールバックを指定する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>でした。<br />\nPromiseが返ってくる = モッダーンな環境では`async/await`で書けることになるけどまあお好きに。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>だと`new RTCSessionDescription(sdp)`しないと`setRemoteDescription()`できなくて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>だと`type` / `sdp` のあるオブジェクト（仕様でいう`RTCSessionDescriptionInit `）でもいけるとか罠。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>SDP</h4>\n    <p>Session Description Protocolのこと。</p><p>Offer/Answerする際に生成し、やり取りするもので、</p>\n\n<ul>\n<li>自分のIP、ポート</li>\n<li>通信経路の候補</li>\n<li>こういう映像・音声に対応してます</li>\n<li>etc...</li>\n</ul><p>などなど書かれたただの巨大な文字列。</p>\n<pre class=\"code sdp\" data-lang=\"sdp\" data-unlink>v=0\no=- 2776741559184865868 2 IN IP4 127.0.0.1\ns=\nc=IN IP4 192.168.0.4\nt=0 0\nm=audio 49170 RTP/AVP 0 8 97\na=rtpmap:0 PCMU/8000\na=rtpmap:8 PCMA/8000\na=rtpmap:97 iLBC/8000\nm=video 51372 RTP/AVP 31 32\na=rtpmap:31 H261/90000\na=rtpmap:32 MPV/90000</pre><p>こういうやつ。<br />\nWebRTC力が一定のレベルを超えてると、この状態でも解読できるらしい。</p><p>このSDPをお互い知ることができれば、晴れて<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>で通信できるというわけ。</p><p>ただしどうやってお互いを知ればいいんだという話がもちろんあって、往々にしてお互いのことを知ってる第<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BB%B0%BC%D4\">三者</a>のサーバーを介して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>（SDPをやり取り）するのが基本の流れになる。</p><p>もちろん単一のPC内で別々のブラウザで・・とかの場合は、愚直にコピペでもいい。</p><p>ちなみにこのSDPを手動で書き換えることで、通信するやり方を調整できたりもする。</p>\n\n<ul>\n<li>帯域を絞ったり</li>\n<li>コーデックの優先順位を変えたり</li>\n</ul><p>ただし文字列操作でやるしかないので、必要ならパーサーとかを。npmでもちらほら見つかる。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a></h4>\n    <p>さてこんなSDPをお互いにどうやって知るかが次なる問題・・。<br />\nけど、決められた手段も<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>も仕様もない！</p><p>なので↑の文字列をなんとかして相手に伝えらればそれでいい。</p>\n\n<ul>\n<li>XHRしてサーバーから渡したり</li>\n<li>WebSocketで渡したり</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/QR%A5%B3%A1%BC%A5%C9\">QRコード</a>にして配布するとか</li>\n</ul><p>つまりなんでもいい。<br />\nけど、この後の続きを読めば、まあレイテンシの低いWebSocketとかが妥当かなーという気持ちになると思う。</p><p>なんしかこの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>のピア同士を結ぶお互いを知る第<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BB%B0%BC%D4\">三者</a>のサーバーを、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>サーバーと呼んだりして、基本的にWebRTCやるなら必須な存在。</p>\n\n    <blockquote>\n        <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>って言うからには何も仲介しなくていいと思ってた・・人もいるかもしらんけど、まあよくよく考えたらどうしようもないよなーという。</p>\n\n    </blockquote>\n<p>この仕事にかこつけて、ルーム管理とかユーザー認証とか他サービスとの連携とかあれこれやらされてるサーバーををよく見る。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ICE Candidate</h4>\n    <p>さて、↑のコードにあった時点で取得できる初期のSDPを送り合うだけでは情報が足りない。</p><p>というのも、このSDPに書かれたIPはグローバルなエンドポイントのIPではない（ことが多い）ため、いわゆるインターネット上ではどうなのよ、どういうネットワークを経由すればいいのよっていうレベルの情報も交換しないとつながらない。</p><p>この情報こそがICE（Interactive Connectivity Establishment）のCandidateと呼ばれるもので、SDPとあわせてお互いに知る必要がある。</p><p>そしてこの通信経路は非同期で取得されるので、それ用のハンドラがある。（`setLocalDescription()`されると、収拾が開始される）</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>peer.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 候補が見つかったとき</span>\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// 候補が出揃ったとき</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>このどっちのタイミングで処理をするかによって、2つの方式に分けられる。</p>\n\n<ul>\n<li>Trickle ICE</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vanilla%20ICE\">Vanilla ICE</a></li>\n</ul>\n<div class=\"section\">\n    <h5>Trickle ICE</h5>\n    <p>候補が見つかったタイミングで都度処理をするパターン。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 送る側</span>\npeer.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 候補が見つかったとき</span>\n    <span class=\"synComment\">// ev.candidate をシグナリングサーバー経由で送る</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// 受ける側</span>\npeer.addIceCandidate(<span class=\"synStatement\">new</span> RTCIceCandidate(candidate));\n</pre><p>ICEの名の通り、仕様的にはこっちが理想であり標準なんかね？<br />\n候補で揃ってなくとも、途中の段階でもつながるならつなげられるので効率的というメリットがある反面、それ用のハンドラを用意したり、SDPはSDPで前もって送っておく必要があったりとコードがやや煩雑になる。</p>\n\n</div>\n<div class=\"section\">\n    <h5><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vanilla%20ICE\">Vanilla ICE</a></h5>\n    <p>候補が全て出揃ったタイミングで一括処理をするパターン。</p><p>これは特に難しいことはなくて、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>peer.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (ev.candidate) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 候補が見つかったときは無視</span>\n    <span class=\"synStatement\">return</span>;\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// 候補が出揃ったときにはSDPに乗ってるので、そもそもこれだけを送る</span>\n  peer.localDescription;\n<span class=\"synIdentifier\">}</span>);\n</pre><p>ってだけ。<br />\n相手にSDPを送るのを、全てのICE Candidateが出揃ってからにするのが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vanilla%20ICE\">Vanilla ICE</a>方式。（特殊なことしないプレーンなやつ＝VanilaJS的な意味）</p><p>コードとしては圧倒的にすっきりするけど、デメリットとしては通信経路が全て出揃うまで待つ必要があるところ。<br />\n後述するSTUNサーバーとかに自分の居場所を確認するのもネットワークコストであり、待つのもタダではないということ。</p>\n\n</div>\n<div class=\"section\">\n    <h5>STUNサーバー</h5>\n    <p>ちなみにローカルなネットワーク内であれば何もしなくてもつながるけど、そんなケースはほとんどないはず。<br />\nほとんどの場合、インターネットを通してつなげたいはず。<br />\n（このインターネット上でつながりたい気持ちを「NAT越え」したいとか「壁を越えたい」とか表したりする。）</p><p>このグローバルなIPやら通信経路を知るためにSTUN（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>を理解する）サーバーというのがあり、`RTCPeerConnection`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タにオプションで指定する。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> peer = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  iceServers: <span class=\"synIdentifier\">[</span> <span class=\"synIdentifier\">{</span> urls: <span class=\"synConstant\">'stun:stun.skyway.io:3478'</span> <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>ここでは某社のサーバーを指定してるけど、他にも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Google\">Google</a>やらいろいろ各社が建ててくれてたりするし、自分で建ててもいい。<br />\nなんしかこれを指定することで、グローバルな経路・IPでIce Candidateを収拾できるようになる。</p>\n\n</div>\n<div class=\"section\">\n    <h5>TURNサーバー</h5>\n    <p>STUNサーバーを使ってグローバルなIPを手に入れても、以後それが継続的に使えるとは限らず・・。（ガチガチの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firewall\">Firewall</a>の中にいるとか）<br />\nというわけで、全ての通信を中継するサーバーを介することで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>とは言ってない）できるようにする手法もあって、その中継の仕組みをTURNとか言ったりする。</p><p>コードとしてはSTUNと同じく`RTCPeerConnection`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タで指定するだけ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> peer = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  iceServers: <span class=\"synIdentifier\">[</span> <span class=\"synIdentifier\">{</span>urls: <span class=\"synConstant\">&quot;turn:x.x.x.x&quot;</span>, credential: <span class=\"synConstant\">&quot;yoursecret&quot;</span>, username: <span class=\"synConstant\">&quot;yourname&quot;</span><span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">]</span>,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>コードを見てもわかる通り、ID/PWが必要になるので色々な意味でサーバーをちゃんと運用しないといけない。<br />\nSTUNと違ってTURNは全てのやり取りを中継するので、データ転送量とか気をつけないといけない。</p><p>ちなみにこのTURNなしでつながる率は70％くらいらしい。<br />\nこの数字を見て高いと取るか低いと取るかは、その作ろうとしてるサービス次第。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>おさらい</h4>\n    <p>だいぶ横道にそれた・・。</p><p>なにはともあれ無事に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>して、お互いに接続されたとすると、さっきのピアに相手のストリームがやってくる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>peer.addEventListener(<span class=\"synConstant\">'addstream'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// const stream = ev.stream;</span>\n<span class=\"synIdentifier\">}</span>, <span class=\"synConstant\">false</span>);\n\n<span class=\"synComment\">// or</span>\n\npeer.addEventListener(<span class=\"synConstant\">'track'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// const stream = ev.streams[0];</span>\n<span class=\"synIdentifier\">}</span>, <span class=\"synConstant\">false</span>);\n</pre><p>2パターン書いてるのは、ブラウザによって対応してるしてないがあるからで・・。<br />\n実際にはどっちかだけでよい。</p><p>これで何事もなければつながって、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D3%A5%C7%A5%AA%A5%C1%A5%E3%A5%C3%A5%C8\">ビデオチャット</a>ができるようになったはず！</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>送りたいストリームを用意</li>\n<li>通信相手ごとに`RTCPeerConnection`を用意</li>\n<li>`RTCPeerConnection`の各メソッド、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>を駆使して準備\n<ul>\n<li>そんなに多くないし、覚えられる</li>\n</ul></li>\n<li>自身のストリームをピアにつなぐ</li>\n<li>Offer / Answerの決まった手順でSDPをやり取り\n<ul>\n<li>`iceConnectionState`とか`signalingState`とかで進行状態も取れる</li>\n</ul></li>\n<li>加えて、ICE Candidateも必要に応じてやり取り\n<ul>\n<li>ICEをどのタイミングで送るかで処理の流れが変わる</li>\n</ul></li>\n<li>それができるとストリームが相互につながる\n<ul>\n<li>自身のストリームと同じく、相手のストリームも表示するなり</li>\n</ul></li>\n</ul><p>コードを書くだけならポイントってこんなもんかな・・？<br />\nPub側なのかSub側なのかを明確に分けてコードは書くときれいになる + 共通部分も多いのでそこをどうするかくらい。</p>\n\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    <p>こっからは輪をかけてメモ感が高まるので半目で。</p>\n\n<div class=\"section\">\n    <h4>関連トピック</h4>\n    \n<ul>\n<li>`MediaStream`を送るやつ以外にも`DataChannel`というのもある\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>としてはSCTP</li>\n<li>BlobとかArrayBufferが送れるのでファイル共有とかできる</li>\n<li>まずこれを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>でつなげてから、メディアの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>するとかも（非効率かもやけど</li>\n</ul></li>\n<li>`MediaRecorder`\n<ul>\n<li>なんとストリームを録画・録音できる・・！</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>ブラウザ差異</h4>\n    \n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>はいちおう使える\n<ul>\n<li>が、微妙に挙動が異なる + <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%F3%A5%BF%A5%C3%A5%AF%A5%B9\">シンタックス</a>・<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>に差異がある</li>\n</ul></li>\n<li>Edgeは最近対応したらしいが一手間必要\n<ul>\n<li>一手間じゃないくらいアレなニオイはする</li>\n<li>ORTCなにそれお</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/IE\">IE</a>、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>はお察し\n<ul>\n<li>かと思いきや<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a> 11で来るらしい</li>\n<li><a href=\"https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Safari_11_0/Safari_11_0.html?utm_content=buffer2df56&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer#//apple_ref/doc/uid/TP40014305-CH13-SW7\">https://developer.apple.com/library/content/releasenotes/General/WhatsNewInSafari/Safari_11_0/Safari_11_0.html?utm_content=buffer2df56&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer#//apple_ref/doc/uid/TP40014305-CH13-SW7</a></li>\n</ul></li>\n</ul><p>という具合で、踏み込めば踏み込むほど一筋縄ではいかない感じ。</p><p>最近Promiseが返ってくる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が増えたけど、EdgeとかだとPromiseで返ってこなくてハマったりする人とか出てくるんやろな・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a></h4>\n    \n<ul>\n<li>そもそもHTTPじゃないのでDevToolsがほぼ役に立たない</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a>://webrtc-internals/</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Wireshark\">Wireshark</a>とか？</li>\n</ul><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>しないといけない状況になったことないのでわからん。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MCU\">MCU</a></h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>とはいっても、相互接続（ = フルメッシュ）での接続は何かと負荷が高くて、数人の相互接続ですらカクつくしファンが回る。<br />\nネットワークの負荷もそこそこ + 動画の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>が特に辛い。音声だけなら十数人まではそれなりにいける感。</p><p>そこでのソリューションとして<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>やら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MCU\">MCU</a>というのがある。<br />\nどっちもつまりは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>をやめる。</p><p>ざっくりいうと、</p>\n\n<ul>\n<li>接続先全員に自分のストリームを送るのではなく（= <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>ではなく）</li>\n<li>サーバーにだけ送って</li>\n<li>そのサーバーが代わりにそれぞれ下りの接続先に配る</li>\n</ul><p>もしくは、上りだけではなく下りもサーバーが1本にまとめるようにしたり。<br />\nなんしか動画つきでN:Nを一定数以上でやりたいなら、視野に入れる必要がある。</p><p>1:Nとかならやろうと思えばHLSとかでもできる気がするので、何がしたいのかにあわせてそういう目線で技術を選べばよし。</p><p>ただWebRTCはリアルタイムを謳ってるだけあってHLSでリアルタイム（疑似）するより圧倒的にリアルタイムなので、その方面でもWebRTCに対する期待は高まってるはず・・？（と勝手に思ってる<br />\nHLSにすれば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iOS\">iOS</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>でも見れるし。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>ここに書いてあるのは氷山の一角であり、実運用にこぎつけるまでにはさらに広範囲の知識が必要。</p>\n\n<ul>\n<li>実際に通信される<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>のこと</li>\n<li>動画の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>とかコーデックとかそのへん</li>\n<li>実際のハードウェアに関する制約やらトラブルあれこれ</li>\n<li>パケロスとかなんかそういう高度な次元のあれやこれや</li>\n<li>なんか回線種別によって挙動が違うかもとかどうとか\n<ul>\n<li><a href=\"https://www.tcmobile.jp/dev_blog/programming/webrtc%E3%81%A7turn%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AB%E3%81%AA%E3%82%8B%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%E5%9B%9E%E7%B7%9A/\">WebRTC&#x3067;TURN&#x30B5;&#x30FC;&#x30D0;&#x30FC;&#x304C;&#x5FC5;&#x8981;&#x306B;&#x306A;&#x308B;&#x30E2;&#x30D0;&#x30A4;&#x30EB;&#x56DE;&#x7DDA; | GROUP DEV BLOG | TECHNO MOBILE</a></li>\n</ul></li>\n<li>etc..</li>\n</ul><p>そういうところを各社のWebRTCソリューションに丸投げして、ちょっとしたjs書くくらいなら、ちょっとやればデキるはず。<br />\nそれでもココに書いてる内容とかを広く浅く知ってる前提ではあるけど・・。</p>\n\n<div class=\"section\">\n    <h4>どこで情報を追うか</h4>\n    <p>狭いいんたーねっつを見てる感じ、国内だと詳しい人達は本当に限られてる。<br />\nので、ピンポイントでその人達をフォローしたりすればいいと思う。</p><p>ただしいわゆる低レイヤーなとこも把握していながら、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>でうまい感じにやる術も併せ持ってる人は本当に希少生物っぽい。</p>\n\n</div>\n</div>"
}
