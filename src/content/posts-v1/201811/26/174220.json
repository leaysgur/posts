{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.1",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/nodertc\">GitHub - nodertc/nodertc: [WIP] WebRTC Datachannels for Node.js</a></p>\n\n    </blockquote>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>で書かれたWebRTCの実装で、現時点ではDataChannelのみ実装されてます。</p><p>WebRTCスタックの実装、興味はあって前々から読んでみたいとは思ってたものの、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>の数も多いし高い壁よね・・。<br />\nというところで、DCだけやしコードもJSやし、これならなんとかなるんでは？という。<br />\nQUICがきても・・この経験は・・きっと無駄にはならな・・。</p><p>必要な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>をうまくたどって読むのが大変そうなので、実装を先に読めばそのへんの雰囲気がつかめるのでは？という主旨のシリーズです。</p><p>ちなみに読んだバージョンは、`0.1.0`です。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>まず試してみる</h3>\n    <p>サンプルが用意されてるのでそれで。</p>\n\n<ul>\n<li>`git clone`する</li>\n<li>`npm i`する</li>\n<li>`npm start`する</li>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>:7007`をひらく</li>\n<li>DevToolsから、`channel.send('hello')`とかしてみる\n<ul>\n<li>`npm start`したコンソールになんか出るのを確認する</li>\n</ul></li>\n<li>コンソールになんか入力してみる\n<ul>\n<li>ブラウザ側からなんか出るの確認する</li>\n</ul></li>\n</ul><p>ブラウザとサーバー間で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>してるだけなのでコードもシンプル。</p>\n\n    <blockquote>\n        <p>20181128追記:<br />\nコードを読み始めた時は送受信の機能はなかったけど、ついに実装されました！</p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h4>サーバー側</h4>\n    <p>`example-express.js`より。</p><p>`express`のサーバーのサンプルなので、使い方は見ればわかるはずやけど一応。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> nodertc = require(<span class=\"synConstant\">'nodertc'</span>);\n\n<span class=\"synComment\">// サーバーを立てて待機</span>\n<span class=\"synStatement\">const</span> rtc = nodertc();\nawait rtc.start();\n\n<span class=\"synComment\">// offerをもらったら新規セッションを作る</span>\n<span class=\"synStatement\">const</span> session = rtc.createSession();\n<span class=\"synComment\">// このanswerをクライアントに送り返す</span>\n<span class=\"synStatement\">const</span> answer = await session.createAnswer(offer);\n\nrtc.on(<span class=\"synConstant\">'session'</span>, session =&gt; <span class=\"synIdentifier\">{</span>\n  session.once(<span class=\"synConstant\">'channel'</span>, channel =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// 送信</span>\n    channel.write(line);\n\n    <span class=\"synComment\">// 受信</span>\n    channel.on(<span class=\"synConstant\">'data'</span>, data =&gt; <span class=\"synIdentifier\">{</span>\n      console.log(`$<span class=\"synIdentifier\">{</span>data.toString()<span class=\"synIdentifier\">}</span>`);\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>今のところは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vanilla%20ICE\">Vanilla ICE</a>専用っぽい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ブラウザ側</h4>\n    <p>`fixtures/client.js`より。</p>\n\n<ul>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>:7007`をひらく</li>\n<li>そこで`createDataChannel()`</li>\n<li>`negotiationneeded`で`createOffer()`と`setLocalDescription()`</li>\n<li>VanillaICEで収集待って、そのあとサーバーにOfferを送る</li>\n<li>サーバーはそれを受けてAnswerを返す</li>\n<li>`setRemoteDescription()`して<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>開始</li>\n</ul><p>最低限のコードしかないので何も言うことない。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>nodertc/nodertc</h3>\n    <p>さて本題。<br />\nまずは本丸であるこの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>から。</p>\n\n<ul>\n<li>index.js</li>\n<li>lib/candidates.js</li>\n<li>lib/fingerprint.js</li>\n<li>lib/grammar.js</li>\n<li>lib/ice-util.js</li>\n<li>lib/sdp.js</li>\n</ul><p>Organizationとしての`nodertc`配下にもたくさんのRepoがあって内部的に依存してる。<br />\n必要があればその`node_modules`も読む。</p>\n\n</div>\n<div class=\"section\">\n    <h3>lib/</h3>\n    <p>小さな関数がいくつかあるだけ。</p><p>`grammar.js`は、`ice-util.js`のために存在する。ICEのユーザー名とかパスワードとかの文字列を生成するやつ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>index.js</h3>\n    <p>大きく分けて2ついる。</p>\n\n<ul>\n<li>NodeRTC</li>\n<li>Session</li>\n</ul><p>こいつらは後述するとして、このパッケージとしては、`new NodeRTC(options)`する関数を返してるだけ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: NodeRTC</h3>\n    <p>100行弱。</p><p>主要なのはこの2つで、あとはGetterがついてるだけ。</p>\n\n<ul>\n<li>start(options)</li>\n<li>createSession()</li>\n</ul><p>つくったSessionを格納したり、オプションで`certificate`と`certificatePrivateKey`を受け取って、あとでSDPに載せる時に使ってる。</p>\n\n<div class=\"section\">\n    <h4>start(options)</h4>\n    <p>このサーバーのIPを決めてるだけ。</p>\n\n<ul>\n<li><a href=\"https://github.com/sindresorhus/public-ip\">GitHub - sindresorhus/public-ip: Get your public IP address - very fast!</a></li>\n<li><a href=\"https://github.com/sindresorhus/internal-ip\">GitHub - sindresorhus/internal-ip: Get your internal IP address</a></li>\n</ul><p>ここにも卿がいらっしゃった・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>createSession()</h4>\n    <p>セッションを作って返して、セッションが閉じたら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>を破棄。</p><p>特筆すべき点はなし。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>class: Session</h3>\n    <p>300行ちょい。</p><p>`createAnswer()`のほかにもいくつかメソッドがあるけど、全ての起点はコレ。</p><p>あとは`constructor()`で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>のソケットを用意したり、ICEのユーザー名・パスワードを用意したり。</p>\n\n<div class=\"section\">\n    <h4>createAnswer(offer)</h4>\n    \n<ul>\n<li>`offer`のSDPをパース</li>\n<li>`appendCandidate()`\n<ul>\n<li>受け取った`candidate`を保持しつつ</li>\n<li>`unicast`のソケットを用意\n<ul>\n<li><a href=\"https://github.com/reklatsmasters/unicast\">GitHub - reklatsmasters/unicast: Unicast implementation of UDP Datagram sockets.</a></li>\n</ul></li>\n<li>`unicast`のソケットのHostとPortは、`priority`が一番高い`candidate`の</li>\n</ul></li>\n<li>`listen()`で各種サーバーを立てる</li>\n<li>STUNサーバー\n<ul>\n<li>`constructor()`で用意してた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>のソケットを使って</li>\n<li><a href=\"https://github.com/nodertc/stun\">GitHub - nodertc/stun: Low-level Session Traversal Utilities for NAT (STUN) server</a></li>\n</ul></li>\n<li>DTLSサーバー\n<ul>\n<li>`unicast`のソケットを使って</li>\n<li><a href=\"https://github.com/nodertc/dtls\">GitHub - nodertc/dtls: Secure UDP communications using DTLS.</a></li>\n</ul></li>\n<li>最後にSCTPサーバー\n<ul>\n<li>さっきのDTLSをトランスポートに指定</li>\n<li><a href=\"https://github.com/nodertc/sctp\">GitHub - nodertc/sctp: [WIP] SCTP network protocol in plain js</a></li>\n<li>ポートは`5000`固定になってる</li>\n</ul></li>\n<li>`answer`のSDPを作ってクライアントに返す</li>\n</ul><p>これを接続してきたピアごとにやってる。</p><p>接続してきたピアごとに用意した`unicast`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットが全ての基盤で、その上でDTLS、SCTPという構造。</p>\n\n<div class=\"section\">\n    <h5>unicastとは</h5>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/reklatsmasters/unicast\">GitHub - reklatsmasters/unicast: Unicast implementation of UDP Datagram sockets.</a></p>\n\n    </blockquote>\n<p>`dgram.createSocket()`のラッパー。</p><p>まさにその名の通りで、最初に指定したHostとPortに合致した`message`だけ通すようになってる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> unicast = require(<span class=\"synConstant\">'unicast'</span>);\n\n<span class=\"synStatement\">const</span> socket = unicast.createSocket(<span class=\"synIdentifier\">{</span>\n  type: <span class=\"synConstant\">'udp4'</span>,\n  port: 2222,\n  remotePort: 1111,\n  remoteAddress: <span class=\"synConstant\">'127.0.0.1'</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>これで得られる`socket`は、`Duplex`のストリーム。<br />\nラップする前は`Duplex`じゃない。</p>\n\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    \n<ul>\n<li>コードは割ときれいで読みやすい\n<ul>\n<li>ただ`Symbol`で`private`っぽいコード書くならTypeScriptとかにしてほしい</li>\n</ul></li>\n<li>コードはわかりやすいが、なぜそうするのかを完全には理解できない\n<ul>\n<li>こういうところが結局<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>読め案件なんやろな・・</li>\n</ul></li>\n</ul><p>STUN, DTLS, SCTPの実装のほうが本体っぽい予感がしてるので、次回以降はそっちを読んでく。</p>\n\n</div>"
}
