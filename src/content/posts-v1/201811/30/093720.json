{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.3",
  "html": "<p>前回までのあらすじ。</p>\n\n<ul>\n<li>`nodertc/nodertc`を読んでた</li>\n<li>クライアントとSessionを確立する際に、内部的にいくつかサーバーを立ててた\n<ul>\n<li>STUN: 前回読んだ</li>\n<li>DTLS: 今回はコレ</li>\n<li>SCTP</li>\n</ul></li>\n<li>こいつらの詳細を読み進めているところ</li>\n</ul><p>というわけで、今回はDTLSの部分。<br />\n書いてみたら長くなったので、前後編になってます。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>使われ方</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// STUNの最初の検証が済んでから動く</span>\n<span class=\"synComment\">// this.stun.once(STUN_EVENT_BINDING_RESPONSE, () =&gt; this.startDTLS());</span>\n\nstartDTLS() <span class=\"synIdentifier\">{</span>\n  console.log(<span class=\"synConstant\">'[nodertc][dtls] start'</span>);\n\n  <span class=\"synStatement\">const</span> options = <span class=\"synIdentifier\">{</span>\n    socket: <span class=\"synIdentifier\">this[</span>_usocket<span class=\"synIdentifier\">]</span>,\n    certificate: <span class=\"synIdentifier\">this[</span>_certificate<span class=\"synIdentifier\">]</span>,\n    certificatePrivateKey: <span class=\"synIdentifier\">this[</span>_privateKey<span class=\"synIdentifier\">]</span>,\n    checkServerIdentity: certificate =&gt;\n      fingerprint(certificate.raw, <span class=\"synConstant\">'sha256'</span>) === <span class=\"synIdentifier\">this[</span>_peerFingerprint<span class=\"synIdentifier\">]</span>,\n  <span class=\"synIdentifier\">}</span>;\n\n  <span class=\"synIdentifier\">this[</span>_dtls<span class=\"synIdentifier\">]</span> = dtls.connect(options);\n\n  <span class=\"synIdentifier\">this</span>.dtls.once(<span class=\"synConstant\">'connect'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'[nodertc][dtls] successful connected!'</span>);\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.dtls.on(<span class=\"synConstant\">'error'</span>, err =&gt; <span class=\"synIdentifier\">{</span>\n    console.error(<span class=\"synConstant\">'[nodertc][dtls]'</span>, err);\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.startSCTP();\n<span class=\"synIdentifier\">}</span>\n</pre>\n<ul>\n<li>`unicast`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットで、接続してきたピアとつなぐ</li>\n<li>D\"<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TLS\">TLS</a>\"なのでもちろん暗号化に関する情報が必要</li>\n<li>次につなぐSCTPで`transport`として指定される</li>\n</ul><p>というわけで、特別なにかしてるわけではない。土管。</p>\n\n</div>\n<div class=\"section\">\n    <h3>nodertc/dtls</h3>\n    <p>読んだバージョンは`0.5.0`です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/dtls\">GitHub - nodertc/dtls: Secure UDP communications using DTLS.</a></p>\n\n    </blockquote>\n<p>`src/index.js`にはじまり、まあ本体はSTUNと同じで`node_modules`という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リの中にある・・。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>node_modules\n├── cipher\n│   ├── abstract.js\n│   ├── aead.js\n│   ├── defaults.js\n│   ├── key-exchange.js\n│   ├── null.js\n│   └── utils.js\n├── filter\n│   ├── decoder.js\n│   ├── defragmentation.js\n│   └── reordering.js\n├── fsm\n│   ├── protocol.js\n│   ├── retransmitter.js\n│   └── states.js\n├── lib\n│   ├── constants.js\n│   ├── protocol.js\n│   ├── sender.js\n│   ├── sliding-window.js\n│   └── socket.js\n├── session\n│   ├── abstract.js\n│   ├── client.js\n│   └── utils.js\n└── utils\n    └── debug.js</pre><p>さすが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TLS\">TLS</a>関連の実装だけあってファイルが多い！</p><p>取っ掛かりはモジュールとして、`lib/socket.js`からエクスポートしてる`connect()`関数。</p><p>ただ`connect()`では`new Socket(options).connect()`しかしてなかったのでそっちがメイン。<br />\n上のレイヤーから渡されてるのは、`unicast`のソケットなので、それも忘れずに追う。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: Socket</h3>\n    <p>`constructor()`でやってること。</p>\n\n<ul>\n<li>extends `Duplex`\n<ul>\n<li>つまり extends `EventEmitter`でもある</li>\n</ul></li>\n<li>`ClientSession`を`session`として初期化\n<ul>\n<li>`session.on('data', packet => this.push(packet)` = 自身の`Duplex.push()`</li>\n<li>'session.on('handshake:finish', () => this.emit('connect'))`</li>\n</ul></li>\n<li>各種`Stream`を`pipeline()`でつないでる\n<ul>\n<li>`pipeline(writer, socket, onerror);`</li>\n<li>`pipeline(socket, isdtls, decoder, reorder, defrag, protocol, onerror);`</li>\n</ul></li>\n</ul><p>というわけでこのクラスでは、</p>\n\n<ul>\n<li>`ClientSession`がやってること</li>\n<li>`Stream`の`pipeline()`群</li>\n<li>`connect()`の中身</li>\n</ul><p>この3つを追えばよさそう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: ClientSession</h3>\n    <p>その名の通り、DTLSのセッションの本体であり一番実装が重そうなところ。</p><p>`session/client.js`が実態、`session/abstract.js`を継承してて、`session/utils.js`が関数群。</p><p>`AbstractSession`と`ClientSession`からわかるのは、</p>\n\n<ul>\n<li>DTLSのバージョンは`1.2`</li>\n<li>DTLSなので暗号化まわりのコード\n<ul>\n<li>`NullCipher`</li>\n</ul></li>\n<li>`retransmitter`は再送制御\n<ul>\n<li>`SlidingWindow`とかも自前実装で持ってる</li>\n</ul></li>\n<li>etc...</li>\n</ul><p>このあたりはざっくりでもDTLSの実装フローを知ってないと読み解けなさそう。</p><p>今のところ、副作用のあるコードにはたどりつけてないので、`session`を引数にもらってる登場人物各種がどこかできっかけを作るはず。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`socket.connect()`</h3>\n    \n<ul>\n<li>`constructor()`で初期化した`ProtocolReader(session)`の`start()`を呼んでる\n<ul>\n<li>`fsm/protocol.js`</li>\n</ul></li>\n<li>この`start()`で、`session.startHandshake()`を呼んでた</li>\n</ul><p>`ProtocolReader`をみていく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: ProtocolReader</h3>\n    \n<ul>\n<li>DTLSのHandshakeを、内部的なStateを持ちながら順に処理していくクラス\n<ul>\n<li>`CLIENT_HELLO`やら`SERVER_HELLO`から`CLIENT_FINISHD`まで</li>\n<li>おそらくこれが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>に書いてある</li>\n<li>`FINISHED`に到達したら、さっきの`handshake:finish`が発火してつながる</li>\n</ul></li>\n<li>`next(state)`が<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%BA%C6%B5%A2\">再帰</a>で回ってStateを更新してくイメージ</li>\n<li>受け取った`session`のメソッドも逐次使ってる\n<ul>\n<li>上述のとおり最初に`startHandshake()`してる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>続 ClientSession</h3>\n    <p>`Socket`で初期化された`session`は、登場人物各種にも引数として渡されてる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>- Socket\n  - ClientSession\n    - ProtocolReader\n    - Sender\n    - Decoder\n    - Reordering\n  - Defragmentation</pre><p>`Socket`の`constructor()`で渡される依存関係はこんな感じ。<br />\n`Defragmentation`だけ`session`を受け取らない。</p><p>`ClientSession`内の目ぼしいクラスは以下。</p>\n\n<ul>\n<li>`RetransmitMachine`\n<ul>\n<li>`fsm/retransmitter.js`</li>\n</ul></li>\n<li>`SlidingWindow`\n<ul>\n<li>`lib/sliding-window.js`</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>class: RetransmitMachine</h4>\n    \n<ul>\n<li>これも内部的にStateとQueueを持って再送を制御してる</li>\n<li>基本的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>参照って書いてある\n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc6347\">RFC 6347 - Datagram Transport Layer Security Version 1.2</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>class: SlidingWindow</h4>\n    \n<ul>\n<li>Anti-Replayの仕組み</li>\n<li>逐次シーケンスNoを入れてあって、なんかのタイミングでチェックしてる\n<ul>\n<li>並び替えとか再送とか</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>後編へつづく</h3>\n    <p>長くなってきたのでこのへんで。</p><p>今回はDTLSソケットがつながる過程で用意される`ClientSession`でやってることの途中まで読んだ。</p><p>長くなりそうな`pipeline()`をつなげてるところは後編で。</p>\n\n</div>"
}
