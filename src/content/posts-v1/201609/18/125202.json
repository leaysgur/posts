{
  "title": "0からはじめる MobX Part.2",
  "html": "<p>第2回は、MobXのReact<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%F3%A5%C7%A5%A3%A5%F3%A5%B0\">バインディング</a>である`mobx-react`について。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/mobxjs/mobx-react\">GitHub - mobxjs/mobx-react: React bindings for MobX</a></p>\n\n    </blockquote>\n<p>ちなみに、React Native用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%F3%A5%C7%A5%A3%A5%F3%A5%B0\">バインディング</a>とかもあります。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>observer</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Decorators</span>\n@observer\n<span class=\"synStatement\">class</span> Foo <span class=\"synStatement\">extends</span> React.Component <span class=\"synIdentifier\">{}</span>\n\n<span class=\"synComment\">// Function</span>\nobserver(<span class=\"synStatement\">class</span> Foo <span class=\"synStatement\">extends</span> React.Component <span class=\"synIdentifier\">{}</span>)\n</pre><p>これさえ覚えればほぼなんとかなる！</p><p>Stateless Functional Componentの場合も同じく、包むだけ。<br />\nこうすると、Observableな値が更新された時に、必要ある<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>だけが自動的にRe-renderされるようになる。</p><p>基本的にObservableな値を表示する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>には、例外なく全てつける。<br />\n`shouldComponentUpdate()`なんか実装しなくとも、MobXが全部いい感じにしてくれる。</p><p>ちなみに`observer()`すると、`componentWillReact()`ってフックが使えるようになる。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>用途とかかな？</p>\n\n</div>\n<div class=\"section\">\n    <h3>PropTypes</h3>\n    <p>Observableなオブジェクトやら配列をそのまま渡すときがあるときに。<br />\n普通はプリミティブな値を渡すから使うことはそうそうないはずやけど。</p><p>`React.PropTypes`にはもちろんそんなのなくて怒られるので、代わりに`mobx-react`の`PropTypes`から使う。</p>\n\n<ul>\n<li>observableArray</li>\n<li>observableArrayOf(React.PropTypes.number)</li>\n<li>observableMap</li>\n<li>observableObject</li>\n<li>arrayOrObservableArray</li>\n<li>arrayOrObservableArrayOf(React.PropTypes.number)</li>\n<li>objectOrObservableObject</li>\n</ul><p>ちなみに、ついこの間までは`PropTypes`ではなく`propTypes`って名前でエクスポートされてました。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Provider / inject</h3>\n    <p>どっかで見たことある感じｗ<br />\nけど<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>のネストが深くなると、結局バケツリレーになるのは何使っても一緒です。</p><p>そういうときに、用法用量を守って正しく使いたいこの機能。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 根本</span>\n&lt;Provider\n  storeA=<span class=\"synIdentifier\">{</span>storeA<span class=\"synIdentifier\">}</span>\n  storeB=<span class=\"synIdentifier\">{</span>storeB<span class=\"synIdentifier\">}</span>\n&gt;\n  &lt;FooComponent /&gt;\n&lt;/Provider&gt;\n\n<span class=\"synComment\">// 使いたいところで</span>\n@inject(<span class=\"synConstant\">'storeA'</span>) @observer\n<span class=\"synStatement\">class</span> Bar <span class=\"synStatement\">extends</span> React.Component <span class=\"synIdentifier\">{}</span>\n\n<span class=\"synComment\">// Functionなら</span>\ninject(<span class=\"synConstant\">'storeA'</span>)(observer(<span class=\"synStatement\">class</span> Bar <span class=\"synStatement\">extends</span> React.Component <span class=\"synIdentifier\">{}</span>))\n\n<span class=\"synComment\">// 複数渡すなら</span>\ninject(<span class=\"synConstant\">'storeA'</span>, <span class=\"synConstant\">'storeB'</span>)(observer(<span class=\"synStatement\">class</span> Bar <span class=\"synStatement\">extends</span> React.Component <span class=\"synIdentifier\">{}</span>))\n</pre><p>`inject` -> `observer`の順番ってのが大事。</p><p>まあこの仕組をいかに小さく組み込んでいくかが、最近のReactアプリの設計のキモって感じですかね。</p><br />\n<p>Part.3に続きます。</p>\n\n</div>"
}
