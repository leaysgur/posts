---
title: "`useQuery({ initialData })`が指定されると、`query.data`の型は`TData | undefined`ではなく`TData`"
---

説明が難しいシリーズ。

```js
const query = useQuery({
  queryKey: ['todo', id],
  queryFn: () => fetchTodo(id),
  initialData: { id: 0, title: 'xxx' }, // <- コレ 
});
```

デバッグ用くらいにしか使ったことなくて気にしてなかったけど、場合によってはハマるなーと思ったので書いておく。

## いつものパターン

まずはおさらい。

```js
const query = useQuery({
  queryKey: ['todo', id],
  queryFn: () => fetchTodo(id),
});
```

この場合に、`query.data.xxx`を取得するためには、`query.isSuccess`であることを確認した上でアクセスするのが定石。

```js
// この時点ではまだローディング中で、`undefined`の可能性がある
query.data?.title;

// 成功してたら安全
if (query.isSuccess) {
  query.data.title;
}
```

これぞTanstack Queryって感じ。

## `initialData`があると

しかし。

```js
const query = useQuery({
  queryKey: ['todo', id],
  queryFn: () => fetchTodo(id),
  initialData: { id: 0, title: 'xxx' }, // <- コレ 
});
```

こうなってると、なんと最初から`undefined`は排除されてる。

```js
// この時点でも、キャッシュがあるので`undefined`の可能性はない
query.data.title;

// いつも通りにも書ける
if (query.isSuccess) {
  query.data.title;
}
```

ふむ。

> better type narrowing for initialData · Issue #3310 · TanStack/query
> https://github.com/TanStack/query/issues/3310

## 何がハマるかというと

コードベース全体で見たときに、この指定があるクエリとないクエリという2種類が生まれることになる。

`isSuccess`や`data`によって型ガードをやってるものと、そうでないものが生まれるってこと。

```jsx
<Dummy p={aQuery.data.xxx} />

{bQuery.isSuccess && (
  <Dummy p={bQuery.data.xxx} />
)}
```

個人的には型が変わると思ってなかったので、なんでこのクエリだけ型ガードなしで動いてんの？！TSの秘孔でもついた？ってなって混乱して時間を浪費した。

ちなみに、`queryFn`単体だと、データを同期で返してもそうはならない。

```js
const query = useQuery({
  queryKey: ['todo', id],
  queryFn: () => ({ id: 1, title: "Why?" })
});

query.data?.title;
```

`placeholderData`の場合も、当然そうはならない。

```js
const query = useQuery({
  queryKey: ['todo', id],
  queryFn: () => fetchTodo(id),
  placeholderData: { id: 0, title: 'xxx' },
});

query.data?.title;
```

キャッシュを前もって食わせるという意味で、`setQueryData()`を使ってた場合も、こうはならない。

## 何に使ってたか

今回のケースは、

- API経由ではなく、SSR時にページに直接埋め込まれるデータがある
- そのデータも、他と同じくTanstack Queryを介して画一的に利用したかった
- そして、`initialData`が指定されたカスタムクエリを使いまわしてた
  - そもそもコレもTanstack Query界では非推奨だったはず

という場面で、なんでこのクエリだけ・・・なんで・・・ってなってた。

そもそもインラインオプション指定したものを、グローバルに共有するなというのはさておき。

画一的にしたいのなら、やはり非同期側に揃っててほしい（多少の型ガード記述は冗長になるけど）な〜って思った日だった。
後からAPI化したときも直す必要ないし。
