{
  "title": "webrtc/adapterのコードを読んだメモ",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/webrtc/adapter/\">GitHub - webrtc/adapter: Shim to insulate apps from spec changes and prefix differences. Latest adapter.js release:</a></p>\n\n    </blockquote>\n\n<ul>\n<li>界隈で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C0%D4%BF%F1%C8%BF%BC%CD\">脊髄反射</a>的に必要って言われてる気がする</li>\n<li>個人的にはお世話になったことはない\n<ul>\n<li>SkyWayのJS-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>でもサンプルでも使ってないし（いちおうメンテナしてるけど）</li>\n<li>なので余計にフロントエンドでいう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/jQuery\">jQuery</a>と同じノリを感じる</li>\n</ul></li>\n<li>なので、実際に何やってるのか読んで調べてみて、その確証を得たい</li>\n</ul><p>ちなみに、2018/04/23時点での`master`ブランチの内容。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リ構造</h3>\n    <p>`/src/js`が本丸。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── adapter_core.js\n├── adapter_factory.js\n├── chrome\n│   ├── chrome_shim.js\n│   └── getusermedia.js\n├── common_shim.js\n├── edge\n│   ├── edge_shim.js\n│   └── getusermedia.js\n├── firefox\n│   ├── firefox_shim.js\n│   └── getusermedia.js\n├── safari\n│   └── safari_shim.js\n└── utils.js</pre><p>特に言うことなし。</p><p>ちなみに、行数はこんな感じ。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>$ wc -l src/js/**/*.js\n      13 src/js/adapter_core.js\n     149 src/js/adapter_factory.js\n     745 src/js/chrome/chrome_shim.js\n     244 src/js/chrome/getusermedia.js\n     283 src/js/common_shim.js\n      80 src/js/edge/edge_shim.js\n      34 src/js/edge/getusermedia.js\n     217 src/js/firefox/firefox_shim.js\n     209 src/js/firefox/getusermedia.js\n     308 src/js/safari/safari_shim.js\n     174 src/js/utils.js\n    2456 total</pre><p>依存抜きで2500行もあんのかよ・・重いな・・。</p><p>ちなみにコードは、ES2015ですらない懐かしい感じ。</p><p>以下詳細。</p>\n\n</div>\n<div class=\"section\">\n    <h3>adapter_core</h3>\n    <p>すべてのはじまり、エントリーポイント。</p><p>このプロジェクトはBrowserifyを使ってて、そのエントリーにもなってる。</p><p>`window`を引数に`adapter_factory`を呼んでるだけ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>adapter_factory</h3>\n    <p>やってることは、</p>\n\n<ul>\n<li>各ブラウザごとのアダプターのロード</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UA\">UA</a>のパースと、各アダプターの適用</li>\n</ul><p>各アダプターってのは、この5つ。</p>\n\n<ul>\n<li>共通のcommon</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/firefox\">firefox</a></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/safari\">safari</a></li>\n<li>edge</li>\n</ul><p>詳細は後述。</p><p>ちなみに`RTCXxx`だけではなく、`getUserMedia()`とか`srcObject`とか、いわゆる関連<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>ももれなく対象になってる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>utils</h3>\n    <p>各アダプターを読み進める前に、外堀を埋めておく。</p><p>その名の通り、汎用的なメソッドが諸々。</p>\n\n<ul>\n<li>ログを出す・出さないのフラグ管理</li>\n<li>ワーニング出す・出さないの管理</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UA\">UA</a>からブラウザ判定</li>\n<li>`RTCPeerConnection`でのイベントをラップするやつ</li>\n</ul><p>読んで気になった点は2つ。</p>\n\n<div class=\"section\">\n    <h4>wrapPeerConnectionEvent()</h4>\n    <p>`RTCPeerConnection`で起こるイベント（`icecandidate`とか）にフックして、得られるイベントオブジェクトを操作する、いわゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DF%A5%C9%A5%EB%A5%A6%A5%A7%A5%A2\">ミドルウェア</a>的な処理をしてるやつ。</p><p>使われ方としてはこんな感じ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>utils.wrapPeerConnectionEvent(<span class=\"synStatement\">window</span>, <span class=\"synConstant\">'icecandidate'</span>, <span class=\"synIdentifier\">function</span>(e) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (e.candidate) <span class=\"synIdentifier\">{</span>\n    <span class=\"synType\">Object</span>.defineProperty(e, <span class=\"synConstant\">'candidate'</span>, <span class=\"synIdentifier\">{</span>\n      value: <span class=\"synStatement\">new</span> <span class=\"synStatement\">window</span>.RTCIceCandidate(e.candidate),\n      writable: <span class=\"synConstant\">'false'</span>\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synStatement\">return</span> e;\n<span class=\"synIdentifier\">}</span>);\n</pre><p>つまり、何もしなくても以下と同じようになるようにしてる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.addEventListener(<span class=\"synConstant\">'icecandidate'</span>, ev =&gt; <span class=\"synIdentifier\">{</span>\n  ev.candidate = <span class=\"synStatement\">new</span> RTCIceCandidate(ev.candidate);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>この関数わざわざ必要か・・？<br />\nまあ確かに`RTCSessionDescription`とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>にしないと読んでくれないブラウザとかもあったけども。</p><p>きっとまた後で必要性がわかるんでしょう・・きっと・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>detectBrowser()</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UA\">UA</a>判定のロジック。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">if</span> (navigator.mozGetUserMedia) <span class=\"synIdentifier\">{</span> <span class=\"synComment\">// Firefox.</span>\n  result.browser = <span class=\"synConstant\">'firefox'</span>;\n  result.version = extractVersion(navigator.userAgent,\n      <span class=\"synConstant\">/Firefox\\/(\\d+)\\./</span>, 1);\n<span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (navigator.webkitGetUserMedia) <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// Chrome, Chromium, Webview, Opera.</span>\n  <span class=\"synComment\">// Version matches Chrome/WebRTC version.</span>\n  result.browser = <span class=\"synConstant\">'chrome'</span>;\n  result.version = extractVersion(navigator.userAgent,\n      <span class=\"synConstant\">/Chrom(e|ium)\\/(\\d+)\\./</span>, 2);\n<span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (navigator.mediaDevices &amp;&amp;\n    navigator.userAgent.match(<span class=\"synConstant\">/Edge\\/(\\d+).(\\d+)$/</span>)) <span class=\"synIdentifier\">{</span> <span class=\"synComment\">// Edge.</span>\n  result.browser = <span class=\"synConstant\">'edge'</span>;\n  result.version = extractVersion(navigator.userAgent,\n      <span class=\"synConstant\">/Edge\\/(\\d+).(\\d+)$/</span>, 2);\n<span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (<span class=\"synStatement\">window</span>.RTCPeerConnection &amp;&amp;\n    navigator.userAgent.match(<span class=\"synConstant\">/AppleWebKit\\/(\\d+)\\./</span>)) <span class=\"synIdentifier\">{</span> <span class=\"synComment\">// Safari.</span>\n  result.browser = <span class=\"synConstant\">'safari'</span>;\n  result.version = extractVersion(navigator.userAgent,\n      <span class=\"synConstant\">/AppleWebKit\\/(\\d+)\\./</span>, 1);\n<span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span> <span class=\"synComment\">// Default fallthrough: not supported.</span>\n  result.browser = <span class=\"synConstant\">'Not a supported browser.'</span>;\n  <span class=\"synStatement\">return</span> result;\n<span class=\"synIdentifier\">}</span>\n</pre><p>HIDOI。<br />\n機能で判別したいのか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UA\">UA</a>文字列で判別したいのか不明。</p><p>案の定、関連Issueもある。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/webrtc/adapter/issues/764\">Chrome will be identified as Safari if webkitGetUserMedia is removed &middot; Issue #764 &middot; webrtc/adapter &middot; GitHub</a></p>\n\n    </blockquote>\n<p>うーん、なんというか・・、うーん・・。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>common_shim</h3>\n    <p>最後にコレ。</p><p>こいつがパッチする対象となるものは以下。</p>\n\n<ul>\n<li>RTCIceCandidate</li>\n<li>URL.createObjectURL()</li>\n<li>RTCPeerConnection.prototype.sctp（と、maxMessageSize）</li>\n<li>RTCDataChannel.prototype.send</li>\n</ul>\n<div class=\"section\">\n    <h4>RTCIceCandidate</h4>\n    <p>`RTCIceCandidate.prototype.foundation`が生えた`RTCIceCandidate`にするためにパッチ。<br />\nあとは`toJSON()`時、`usernameFragment`も取れるようになる。</p><p>なんでこれはグローバルにパッチしないんだ・・。</p><p>ちなみにこれは、さっきの`utils.wrapPeerConnectionEvent()`で返すようにしてる。<br />\nというかふと思ったけど、`ev.candidate`でなんやかんやしたいケースってあんのかな？</p>\n\n</div>\n<div class=\"section\">\n    <h4>URL.createObjectURL()</h4>\n    <p>`createObjectURL()`した時に、URLとBlobへの`Map`を用意しておく。<br />\nそして`HTMLMediaElement.prototype.srcObject`が使える環境で、そのマップを見て同`.src`への代入を`.srcObject`への代入にすり替えてる。</p><p>いやいや余計なお世話じゃない？ブラウザに任せてエラーにすればよくない・・？</p>\n\n</div>\n<div class=\"section\">\n    <h4>RTCPeerConnection.prototype.sctp（と、maxMessageSize）</h4>\n    <p>なにやら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>に対して、DataChannelで送信できるデータ量に制限があるっぽい。</p><p>なので`setRemoteDescription()`をパッチして、相手のブラウザを判別し、後にあるかもしれないDataChannelの通信に備えて`maxMessageSize`を取得してる。</p><p>つまり、DataChannel使わないなら不要。</p>\n\n</div>\n<div class=\"section\">\n    <h4>RTCDataChannel.prototype.send()</h4>\n    <p>通常の`send()`に対して、さっきの`maxMessageSize`の制限を適用するだけ。<br />\nそのために、`createDataChannel()`をパッチしてる。</p><p>つまり、以下略。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a></h3>\n    <p>一番行数多い・・。</p>\n\n<div class=\"section\">\n    <h4>getusermedia</h4>\n    \n<ul>\n<li>各種エラーの`name`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%C3%A5%D4%A5%F3%A5%B0\">マッピング</a></li>\n<li>`mandatory`とか`advanced`とか色々ある`constraints`記法のコンバート</li>\n<li>`noiseSuppression`と`autoGainControl`に`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/webkit\">webkit</a>`プレフィックスをつけたり</li>\n<li>`navigator.getUserMedia()`を動くようにしたり</li>\n<li>`navigator.mediaDevices.xxx`がない場合に埋めたり</li>\n</ul><p>`constraints`まわりですごいごちゃごちゃやってるけど、今でも必要なんだろうか・・？いらんくね？</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a>_shim</h4>\n    \n<ul>\n<li>`RTCPeerConnection.prototype.ontrack`がない場合、Stream系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使ってイベントを再現</li>\n<li>`track`イベントで`RTCTrackEvent.prototype.receiver`が取れるように</li>\n<li>`getSenders()`および`createDTMFSender()`の補完\n<ul>\n<li>StreamやTrackの増減時に、`DTMFSender`も増減するように</li>\n</ul></li>\n<li>`srcObject`がない場合、`src`と`createObjectURL()`を使ってそれを使えるように</li>\n<li>v65以上で`addTrack()`がある場合、`getLocalStreams()`の挙動をあわせる</li>\n<li>ない場合は、`(add|remove)Track()`を実装して同様に挙動をあわせる\n<ul>\n<li>`create(Offer|Answer)()`で得たSDPに含まれる`streamId`を置換</li>\n</ul></li>\n<li>`iceTransportPolicy`を`iceTransports`に</li>\n<li>`RTCIceServer.url`を`RTCIceServer.urls`に</li>\n<li>`getStats()`の返り値を、バージョンによって`Map`にしたりプロパティ名を整理したり</li>\n<li>v51未満の`setXxxDescription()`などのPromiseベース化\n<ul>\n<li>`addIceCandidate()`も同様</li>\n</ul></li>\n<li>v52未満の`createOffer()`などのPromiseベース化</li>\n<li>`setXxxDescription()`で与えられる引数を、`RTCSessionDescription()`でラップ\n<ul>\n<li>`addIceCandidate()`も同様</li>\n</ul></li>\n<li>`addIceCandidate(null OR undefined)`できるように</li>\n</ul><p>`srcObject`のやつのココでやるな感がすごい + またも余計なお世話感もすごい。</p><p>後はまあですよねという感じで、Stream系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>とTrack系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>の辻褄あわせがコードのほとんどを占める。<br />\nもうすぐ不要になるけど。</p><p>てか、v51なんてもう2年前のブラウザやし、今となっては不要なコードがほとんどに見える。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a></h3>\n    \n<div class=\"section\">\n    <h4>getusermedia</h4>\n    \n<ul>\n<li>各種エラーの`name`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%C3%A5%D4%A5%F3%A5%B0\">マッピング</a></li>\n<li>v37以下でも動くように古い`constraints`記法のコンバート</li>\n<li>`noiseSuppression`と`autoGainControl`に`moz`プレフィックスをつけたり</li>\n<li>`navigator.getUserMedia()`を動くようにしたり</li>\n<li>v41以下の`enumerateDevices()`のバグ対応\n<ul>\n<li><a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1169665\">1169665 - enumerateDevices should never fail with NotFoundError</a></li>\n</ul></li>\n<li>v49以下の`getUserMedia()`のバグ対応\n<ul>\n<li><a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=802326\">802326 - If video and audio is requested in gUM, but one of them fails, we should align with the spec</a></li>\n</ul></li>\n</ul><p>うーん、いらない・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/firefox\">firefox</a>_shim</h4>\n    \n<ul>\n<li>`RTCPeerConnection.prototype.ontrack`がない場合に、`addEventListener()`を使って補完</li>\n<li>`RTCTrackEvent.prototype.transceiver`で、`RTCTrackEvent.prototype.receiver`が取れるように</li>\n<li>`HTMLMediaElement.prototype.srcObject`がない場合、`mozSrcObject`を使うように</li>\n<li>v37以下の`iceServers`の指定の調整</li>\n<li>`mozRTCIceCandidate` -> `RTCIceCandidate`のようなリネーム諸々</li>\n<li>`setXxxDescription()`で与えられる引数を、`RTCSessionDescription()`でラップ\n<ul>\n<li>`addIceCandidate()`も同様</li>\n</ul></li>\n<li>`getStats()`の返り値を、バージョンによって`Map`にしたりプロパティ名を整理したり</li>\n<li>`removeStream()`を`removeTrack()`を使って動くように</li>\n<li>`addIceCandidate(null OR undefined)`できるように</li>\n</ul><p>この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B8%E5%CA%FD%B8%DF%B4%B9\">後方互換</a>推しはいったいなんなんだ・・ほんと誰のためのadapterなんだ・・って感じ。<br />\nブラウザのバージョンを上げてはいけない世界線があるんだろうか・・。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a></h3>\n    \n<div class=\"section\">\n    <h4>getusermedia</h4>\n    <p>`navigator.webkitGetUserMedia`で叩いても通るように。</p><p>もはやこんなん拾う必要ないやろ・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/safari\">safari</a>_shim</h4>\n    \n<ul>\n<li>Stream関連<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を、`addTrack`やら`removeTrack`を使って動くように\n<ul>\n<li>RTCPeerConnection.prototype.getLocalStreams()</li>\n<li>RTCPeerConnection.prototype.getStreamById()</li>\n<li>RTCPeerConnection.prototype.addStream()</li>\n<li>RTCPeerConnection.prototype.removeStream()</li>\n<li>RTCPeerConnection.prototype.getRemoteStreams()</li>\n<li>RTCPeerConnection.prototype.onaddstream</li>\n</ul></li>\n<li>`createOffer()`みたいなPromiseベースのメソッドを、あえてコール<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%C3%A5%AF%A5%B9%A5%BF%A5%A4%A5%EB\">バックスタイル</a>でも動くように</li>\n<li>`createOffer({ offerToReceiveAudio, offerToReceiveVideo })`のフォールバック\n<ul>\n<li>`setDirection()`やらを使って`sendonly`とか`inactive`とかに</li>\n</ul></li>\n<li>`RTCIceServer.url`を`RTCIceServer.urls`に</li>\n<li>`RTCTrackEvent.prototype.transceiver`で、`RTCTrackEvent.prototype.receiver`が取れるように</li>\n</ul><p>うーん、いったいいつのバージョンの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>を対象としてるの・・？大人しく新しい仕様の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>使えばよくない・・？なんのための<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>なの？</p><p>Proimseになってる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はそのまま使ったらいいやん・・なんで・・。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Edge</h3>\n    <p>他に比べてコードの行数が少ない。DataChannelがないから・・ってのもあるやろうけど、実際は次のライブラリに丸投げしてるから。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/otalk/rtcpeerconnection-shim\">GitHub - otalk/rtcpeerconnection-shim: Implementation of the RTCPeerConnection API ontop of ORTC</a></p>\n\n    </blockquote>\n<p>EdgeのORTCな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>上でWebRTCをいい感じにつなぐためのあれこれ・・的なやつらしい。<br />\n詳細は今回は割愛。</p>\n\n    <blockquote>\n        <p><a href=\"https://blogs.msdn.microsoft.com/msedgedev_japan/2017/02/01/introducing-webrtc-1-0-and-interoperable-real-time-communications-in-microsoft-edge/\">Microsoft Edge &#x3067;&#x306E; WebRTC 1.0 &#x304A;&#x3088;&#x3073;&#x76F8;&#x4E92;&#x904B;&#x7528;&#x53EF;&#x80FD;&#x306A;&#x30EA;&#x30A2;&#x30EB;&#x30BF;&#x30A4;&#x30E0;&#x901A;&#x4FE1;&#x306E;&#x7D39;&#x4ECB; | Microsoft Edge Japan</a></p>\n\n    </blockquote>\n<p>WebRTC 1.0とはなんだったのか！</p>\n\n<div class=\"section\">\n    <h4>getusermedia</h4>\n    \n<ul>\n<li>各種エラーの`name`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%C3%A5%D4%A5%F3%A5%B0\">マッピング</a>\n<ul>\n<li>`PermissionDeniedError`を`NotAllowedError`として返すようにしてるだけ</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>edge_shim</h4>\n    <p>`otalk/rtcpeerconnection-shim`の他には何やってるか。</p>\n\n<ul>\n<li>v15025以下の`addStream()`のバグの対応\n<ul>\n<li>`MediaStreamTrack.prototype.enabled`が変更された時に、`enabled`イベントを発火</li>\n</ul></li>\n<li>`RTCRtpSender.prototype.dtmf`を生やす</li>\n<li>`RTCDTMFSender`ではなく`RTCDtmfSender`なら生えてるらしいのでそれを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%A4%A5%EA%A5%A2%A5%B9\">エイリアス</a></li>\n<li>`RTCRtpSender.prototype.replaceTrack()`がない場合に、`RTCRtpSender.prototype.setTrack()`を呼ぶように</li>\n</ul><p>なんでこれだけは独自にやってるんやろう・・？全部あっちのライブラリに寄せたらいいのに。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>個人的な考えの結論としては、「いらないし、依存したくない」ですね。</p><p>そもそもライブラリとして、</p>\n\n<ul>\n<li>古いブラウザで新しいコードを動かしたいのか</li>\n<li>新しいブラウザで古いコードを動かしたいのか</li>\n</ul><p>そのあたりの立ち位置が不明瞭だなーと読んでて思った。<br />\nずるずる過去の遺産を引きずってるようにしか見えないというのが個人的な感想。</p><p>このパッチがなんのためのものなのか、いつまで必要なのかも探せないし、そのサポートポリシーも明確になってない。</p><p>BabelとかLodashとか見習って、もっと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>ごとに砕いたりすればいいのに。</p>\n\n<ul>\n<li>対象を最新ブラウザの2−3バージョンまでに</li>\n<li>古いコードへのフォールバックは廃止</li>\n<li>機能群ごとでパッケージを分ける</li>\n</ul><p>って感じの、YetAnotherWebRTCAdapterならワンチャンあるなーと思ったけど、各自がアプリ側でハマったところだけ対策するのでも十分よな・・と個人的には思います。</p><p>なんかハマった時に、このコードを読み漁ってみて原因のヒントを探す・・くらいの使い方が良さそう。</p>\n\n</div>"
}
