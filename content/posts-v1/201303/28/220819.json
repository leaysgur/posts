{
  "title": "0からはじめるBackbone.js Part.3",
  "html": "<p>つぎはCollection編。<br />\nまたも公式を読み解くよ。</p>\n\n    <blockquote>\n        <p>特定の技術を習得するために、ドキュメントを一から全部読む必要はまったくないと思うわけですが、それでも触れる時間を単純に確保できるっていう意味では無駄にはならんかなーと思って。</p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Backbone.jsのCollection</h3>\n    \n    <blockquote>\n        <p>Collections are ordered sets of models.</p>\n\n    </blockquote>\n<p>というわけで、Modelは単体、それがまとまってCollection。<br />\nどちらも相互に参照を持ってて、一心同体である、と。</p><p>単にModelの上位概念であり複数形みたいなもんか。</p>\n\n<ul>\n<li>extend</li>\n<li>model</li>\n<li>constructor / initialize</li>\n<li>models</li>\n<li>toJSON</li>\n<li>sync</li>\n<li>Underscore Methods (28)</li>\n<li>add</li>\n<li>remove</li>\n<li>reset</li>\n<li>update</li>\n<li>get</li>\n<li>at</li>\n<li>push</li>\n<li>pop</li>\n<li>unshift</li>\n<li>shift</li>\n<li>slice</li>\n<li>length</li>\n<li>comparator</li>\n<li>sort</li>\n<li>pluck</li>\n<li>where</li>\n<li>url</li>\n<li>parse</li>\n<li>clone</li>\n<li>fetch</li>\n<li>create</li>\n</ul><p>・・多い！ｗ<br />\nけど、なんとなく察しがつくのも多いですね。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Collectionの作成</h3>\n    \n<ul>\n<li>extend</li>\n<li>model</li>\n<li>constructor / initialize</li>\n</ul><pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> Album = Backbone.Collection.extend(<span class=\"synIdentifier\">{</span>\n\tmodel: Song,\n\tinitilize: <span class=\"synIdentifier\">function</span>()<span class=\"synIdentifier\">{</span>\n\t\t<span class=\"synComment\">// Init collection.</span>\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n\n<span class=\"synIdentifier\">var</span> myAlubum = <span class=\"synStatement\">new</span> Album(<span class=\"synIdentifier\">[</span>mySong1, mySong2, mySong3, mySong4<span class=\"synIdentifier\">]</span>);\n</pre><p>Modelの時とほとんど一緒、ただCollectionはModelの配列を渡して生成。</p><p></p>\n\n</div>\n<div class=\"section\">\n    <h3>値の参照</h3>\n    \n<ul>\n<li>models</li>\n<li>toJSON</li>\n<li>sync</li>\n</ul><pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>myAlbum.models; <span class=\"synComment\">// [mySong1, mySong2, mySong3, mySong4]</span>\n</pre><p>Collectionが内包しているModelの配列へのアクセス。<br />\ntoJSON()はModelの時と同じで、jsonが欲しいならJSON.stringify()で。<br />\nsync()も同じ。</p><p></p>\n\n</div>\n<div class=\"section\">\n    <h3>Underscore</h3>\n    \n<ul>\n<li>Underscore Methods (28)</li>\n</ul><p>Underscore.jsの以下のメソッドが使える。</p>\n\n<ul>\n<li>forEach (each)</li>\n<li>map (collect)</li>\n<li>reduce (foldl, inject)</li>\n<li>reduceRight (foldr)</li>\n<li>find (detect)</li>\n<li>filter (select)</li>\n<li>reject</li>\n<li>every (all)</li>\n<li>some (any)</li>\n<li>include (contains)</li>\n<li>invoke</li>\n<li>max</li>\n<li>min</li>\n<li>sortBy</li>\n<li>groupBy</li>\n<li>sortedIndex</li>\n<li>shuffle</li>\n<li>toArray</li>\n<li>size</li>\n<li>first (head, take)</li>\n<li>initial</li>\n<li>rest (tail)</li>\n<li>last</li>\n<li>without</li>\n<li>indexOf</li>\n<li>lastIndexOf</li>\n<li>isEmpty</li>\n<li>chain</li>\n</ul>\n    <blockquote>\n        <p>配列周りのヘルパーがすごく便利とだけ聞いてるけど、実際使ったことないんですよね・・。</p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>データの操作そのいち</h3>\n    \n<ul>\n<li>add</li>\n<li>remove</li>\n<li>reset</li>\n<li>update</li>\n<li>get</li>\n<li>at</li>\n</ul>\n<div class=\"section\">\n    <h4>add</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> newSong = <span class=\"synStatement\">new</span> Song();\nmyAlbum.add(newSong);\n</pre>\n<div class=\"section\">\n    <h5>オプションたち</h5>\n    \n<table>\n    <tr>\n    <th>Option</th>\n    <th>example</th>\n    <th>How?</th>\n    </tr>\n    <tr>\n    <th>silent</th>\n    <td>{silent:true}</td>\n    <td>addイベントを発火しないように</td>\n    </tr>\n    <tr>\n    <th>at</th>\n    <td>{at: 2}</td>\n    <td>指定の位置に挿入する</td>\n    </tr>\n    <tr>\n    <th>merge</th>\n    <td>{merge: true}</td>\n    <td>atで指定した位置にModelが既に存在した場合に更新するか</td>\n    </tr>\n</table><p>ちなみに、Modelは自らのidでもって存在を担保してるそうです。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>remove</h4>\n    <p>要素の削除。<br />\n{silent: true}対応。</p>\n\n</div>\n<div class=\"section\">\n    <h4>reset</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> newSong = <span class=\"synStatement\">new</span> Song();\nmyAlbum.reset(newSong);\n<span class=\"synComment\">// myAlbum.reset(); とすると空のCollectionに</span>\n</pre><p>一部の更新ではなく全取っ替えの場合。<br />\n実行するとresetイベントが発火。</p>\n\n</div>\n<div class=\"section\">\n    <h4>update</h4>\n    <p>増えたものは増やす、減ったものは減らす、変わったものは更新するという感じ。<br />\nそれぞれオプションでもって動作をしばれる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> myAlbum = <span class=\"synStatement\">new</span> Album(mySong1, mySong2, mySong3);\nmyAlbum.update(mySong1, mySong2, mySong4, mySong5, <span class=\"synIdentifier\">{</span>\n\tadd: <span class=\"synConstant\">false</span>,\n\tremove: <span class=\"synConstant\">false</span>,\n\tmerge: <span class=\"synConstant\">false</span>\n<span class=\"synIdentifier\">}</span>);\n</pre>\n</div>\n<div class=\"section\">\n    <h4>get / at</h4>\n    <p>idで要素を取得するのがget()、indexの順で要素を取得するのがat()。<br />\nat()の場合、sortされてない状態だと、sortされてない順に数えて取得されちゃう。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>データの操作そのに</h3>\n    <p>ネイティブのArrayっぽいやつ。</p>\n\n<ul>\n<li>push</li>\n<li>pop</li>\n<li>unshift</li>\n<li>shift</li>\n</ul><p>そのまんま。<br />\npush()とunshift()はadd()と同じ、pop()とshift()はremove()と同じオプションの指定が可能。</p>\n\n<ul>\n<li>slice</li>\n<li>length</li>\n</ul><p>ほんとにArrayのそのまんま。</p><p></p>\n\n</div>\n<div class=\"section\">\n    <h3>データの操作そのさん</h3>\n    \n<ul>\n<li>comparator</li>\n<li>sort</li>\n<li>pluck</li>\n<li>where</li>\n</ul>\n<div class=\"section\">\n    <h4>comparator / sort</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> Album = Backbone.Collection.extend(<span class=\"synIdentifier\">{</span>\n\tmodel: Song,\n\tcomparator: <span class=\"synIdentifier\">function</span>(model)<span class=\"synIdentifier\">{</span>\n\t\t<span class=\"synStatement\">return</span> model.get(<span class=\"synConstant\">'order'</span>);\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>Collectionに要素が追加された際、デフォルトで適応する並び順の指定。<br />\nsortで指定するキーを返すか、単純に比較する関数を定義することで指定する。</p><p>後から並び順のキーとなる値を変更したとしても、自動で並び直しはしてくれないところに注意。</p><p>comparatorを指定している場合、Collectionに要素がaddされると自動でsortされる。<br />\ncomparatorを指定していない場合は、sort()で並べ替える。</p><p>自動でsortさせたくないときは、{sort: false}をadd()の際に指定。</p>\n\n</div>\n<div class=\"section\">\n    <h4>pluck / where</h4>\n    <p>Collectionから特定の配列を抜き出すときに。<br />\nArray.map()とArray.filter()みたいなもん。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>データの所在系</h3>\n    \n<ul>\n<li>url</li>\n<li>parse</li>\n</ul><p>Modelの時と同じ。<br />\nサーバー側のどこに所在があるかを指定する。</p><p>parse()も、サーバー側のリソースを丸っと使うのではなく、一旦何か処理を通したい場合に利用。</p>\n\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    \n<ul>\n<li>clone</li>\n<li>fetch</li>\n<li>create</li>\n</ul>\n<div class=\"section\">\n    <h4>clone / fetch</h4>\n    <p>Modelの時ととおなじ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>create</h4>\n    <p>Modelを作ってCollectionにAddしてサーバー側に保存・・までを簡単に実行できるものらしい。</p><p></p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>所感</h3>\n    <p>Modelの時もそうやったけど、実際にサーバー側とのやりとりを踏まえて設計しないと使えない感じ。<br />\nそもそもRESTfullな思想に慣れてないと、ちんぷんかんぷんな予感。</p><p>とはいえ、Backbone.jsの真のクライアント側で扱うModelとCollectionについてはだいたいわかった気がする。(気が。)</p>\n\n</div>"
}
