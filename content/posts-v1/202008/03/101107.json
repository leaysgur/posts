{
  "title": "Svelteランタイムのコードを読む Part.1",
  "html": "<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>のコードを一通り読んだところなので、ランタイムもついでに読んでおこうかと。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>はじめに</h3>\n    <p>Svelteのランタイムのコードは、おおきく2種類ある。</p>\n\n<ul>\n<li>自分が書いたコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>した際に、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が生成するもの</li>\n<li>ランタイムで使う前提で公開されているもの</li>\n</ul><p>前者が1つだけで、あとはすべて後者だったりする。</p><p>ちなみにランタイム = クライアントサイドの話 = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>を`{ generate: \"dom\" }`して使う場合の話。</p>\n\n<div class=\"section\">\n    <h4>ネームスペースと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a></h4>\n    \n<ul>\n<li>`svelte`</li>\n<li>`svelte/store`</li>\n<li>`svelte/motion`</li>\n<li>`svelte/transition`</li>\n<li>`svelte/easing`</li>\n<li>`svelte/animate`</li>\n<li>`svelte/register`</li>\n</ul><p>現状ではこれだけのモジュールが`export`されてる。</p><p>さて、これらの使い方・・ではなく、中でどういうことやってるのかを順に見ていく。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>from `svelte`</h3>\n    <p>ランタイムのベースとなるコードたちで、公開されてるものが以下のとおり。</p>\n\n<ul>\n<li>`onMount()`</li>\n<li>`onDestroy()`</li>\n<li>`beforeUpdate()`</li>\n<li>`afterUpdate()`</li>\n<li>`setContext()`</li>\n<li>`getContext()`</li>\n<li>`tick()`</li>\n<li>`createEventDispatcher()`</li>\n<li>`SvelteComponent`</li>\n</ul><p>いわゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>のライフサイクルのフックに処理を追加する関数たちと、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>それ自身のコード。</p><p>表向きにモジュールとしてエクスポートされてるのがコレだけってだけで、実際にランタイムで走るコードという意味ではもっといろいろあって、`svelte/internal`ってネームスペースにある。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`SvelteComponent`</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/Component.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/Component.ts</a></p>\n\n    </blockquote>\n<p>ちなみにこのファイルでは、`CustomElement`のための`SvelteElement`の実装とかも入ってる。</p><p>さて、`*.svelte`ファイルは、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>によってこの`SvelteComponent`に集約されてランタイムになる。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>時に`{ dev: true }`が指定されてた場合は、かわりに`SvelteDevComponent`ってのが使われる。<br />\n基本的には同じだが、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>用のコードやらイベントやらが残ったままになる。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/dev.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/dev.ts</a></p>\n\n    </blockquote>\n<p>この`SvelteComponent`は直接使うのではなく、各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>がそれを`extends`して使うようになっており、だいたいこんな感じになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// App.svelteの場合</span>\n<span class=\"synStatement\">class</span> App <span class=\"synStatement\">extends</span> SvelteComponent <span class=\"synIdentifier\">{</span>\n  constructor(options) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">super</span>();\n    init(<span class=\"synIdentifier\">this</span>, options, <span class=\"synStatement\">null</span>, create_fragment, safe_not_equal, <span class=\"synIdentifier\">{}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>というわけで、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>編で見かけた`init()`と`create_fragment()`についにご対面というわけ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`init()`</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>に対しての初期化処理の実態。</p><p>やってることは、</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の核ともいえる`$$`プロパティを仕込む</li>\n<li>`beforeUpdate()`の実行</li>\n<li>`create_fragment()`</li>\n<li>`intro: true`なら、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%F3%A5%B8%A5%B7%A5%E7%A5%F3\">トランジション</a>のINを実行</li>\n<li>`mount_component()`</li>\n<li>`flush()`</li>\n</ul>\n<div class=\"section\">\n    <h4>`component.$$`</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>のすべてといっても過言ではないプロパティ。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">interface</span> T$$ <span class=\"synIdentifier\">{</span>\n  fragment: <span class=\"synType\">null</span> | <span class=\"synConstant\">false</span> | Fragment<span class=\"synStatement\">;</span>\n  ctx: <span class=\"synType\">null</span> | <span class=\"synType\">any</span><span class=\"synStatement\">;</span>\n\n  <span class=\"synComment\">// state</span>\n  props: Record<span class=\"synStatement\">&lt;</span><span class=\"synType\">string</span><span class=\"synStatement\">,</span> <span class=\"synConstant\">0</span> | <span class=\"synType\">string</span><span class=\"synStatement\">&gt;;</span>\n  update: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  not_equal: <span class=\"synType\">any</span><span class=\"synStatement\">;</span>\n  bound: <span class=\"synType\">any</span><span class=\"synStatement\">;</span>\n\n  <span class=\"synComment\">// lifecycle</span>\n  on_mount: <span class=\"synType\">any</span><span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  on_destroy: <span class=\"synType\">any</span><span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  before_update: <span class=\"synType\">any</span><span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  after_update: <span class=\"synType\">any</span><span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  context: Map<span class=\"synStatement\">&lt;</span><span class=\"synType\">any</span><span class=\"synStatement\">,</span> <span class=\"synType\">any</span><span class=\"synStatement\">&gt;;</span>\n\n  callbacks: <span class=\"synType\">any</span><span class=\"synStatement\">;</span>\n  dirty: <span class=\"synType\">number</span><span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>わかりやすく<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>っぽい。</p>\n\n<ul>\n<li>`fragment`\n<ul>\n<li>`create_fragment()`の返り値</li>\n</ul></li>\n<li>`ctx`\n<ul>\n<li>その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>特有の`instance()`があればその返り値</li>\n<li>自身が管理するリアクティブな値とそのアップデート処理があれば、配列にその値が並ぶ</li>\n</ul></li>\n<li>`context`\n<ul>\n<li>全<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>から参照できる`Map`</li>\n</ul></li>\n<li>`dirty`\n<ul>\n<li>ビットマスクになってて、初期値は`[-1]` つまり汚れてる状態</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>`create_fragment()`</h4>\n    <p>処理自体はランタイムのコードの中にはなくて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>が生成するもの。<br />\n型としてはこのように。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">interface</span> Fragment <span class=\"synIdentifier\">{</span>\n  key: <span class=\"synType\">string</span> | <span class=\"synType\">null</span><span class=\"synStatement\">;</span>\n  first: <span class=\"synType\">null</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* create  */</span> c: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* claim   */</span> l: <span class=\"synStatement\">(</span>nodes: <span class=\"synType\">any</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* hydrate */</span> h: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* mount   */</span> m: <span class=\"synStatement\">(</span>target: <span class=\"synConstant\">HTMLElement</span><span class=\"synStatement\">,</span> anchor: <span class=\"synType\">any</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* update  */</span> p: <span class=\"synStatement\">(</span>ctx: <span class=\"synType\">any</span><span class=\"synStatement\">,</span> dirty: <span class=\"synType\">any</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* measure */</span> r: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* fix     */</span> f: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* animate */</span> a: <span class=\"synStatement\">()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* intro   */</span> i: <span class=\"synStatement\">(</span>local: <span class=\"synType\">any</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* outro   */</span> o: <span class=\"synStatement\">(</span>local: <span class=\"synType\">any</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n  <span class=\"synComment\">/* destroy */</span> d: <span class=\"synStatement\">(</span>detaching: <span class=\"synConstant\">0</span> | <span class=\"synConstant\">1</span><span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synType\">void</span><span class=\"synStatement\">;</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>だいたいのやってることはこんな感じ。</p>\n\n<ul>\n<li>`c`: create\n<ul>\n<li>DOMの生成（`createElement()`とか）</li>\n</ul></li>\n<li>`m`: mount\n<ul>\n<li>DOMの挿入（`insertNode()`とか`appendChild()`とか）</li>\n</ul></li>\n<li>`p`: update\n<ul>\n<li>DOMの更新（`setAttribute()`とか`input.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/value\">value</a> =`とか`textNode.data = `とか）</li>\n</ul></li>\n<li>`d`: destroy\n<ul>\n<li>DOMから削除（`removeChild()`とか）</li>\n</ul></li>\n</ul><p>このへんのコードはココにあるものが使われてる。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/dom.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/dom.ts</a></p>\n\n    </blockquote>\n<p>プロパティ名はミニファイできないから、元から短く<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CC%BF%CC%BE\">命名</a>するという涙ぐましい努力を感じる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`mount_component()` / `flush()`</h4>\n    <p>その<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の`fragment.m()`を実行する。</p><p>その際に、`onMount()`のライフサイクルでやることがあれば実行して、その返り値が関数なら、`onDestory()`で実行されるように登録してる。</p><p>Issueでよく`onMount()`で非同期のコードを書きたい話が出てくるけど、安易に`async`を渡して返り値を`Promise`にしてしまうと、`onDestory()`に処理してもらえなくなるのはこのせい。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>後の各種コールバック（ライフサイクル含む）は、それ用の配列に貯められて、非同期にMicrotaskで実行される。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/scheduler.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/scheduler.ts</a></p>\n\n    </blockquote>\n<p>このファイルにある配列がそれで、`tick()`や`flush()`がそれらを実際に実行する処理。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>それ以外</h3>\n    <p>`SvelteComponent`以外のものたち。</p>\n\n<ul>\n<li>`onMount()`</li>\n<li>`onDestroy()`</li>\n<li>`beforeUpdate()`</li>\n<li>`afterUpdate()`</li>\n</ul>\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/lifecycle.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/lifecycle.ts</a></p>\n\n    </blockquote>\n<p>基本的に、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の`$$`にあるコールバック用の配列に関数を登録するだけで、あとは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>が任意のタイミングで呼び出す。</p><p>このファイルには他にも、`set_current_component()`と`get_current_component()`というプライベートな関数があって、グローバルにどの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の処理をするかを切り替えてる。</p>\n\n<ul>\n<li>`setContext()`</li>\n<li>`getContext()`</li>\n</ul><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の`$$.context`が`Map<any, any>`であり、それを`set()`と`get()`するだけ。</p>\n\n<ul>\n<li>`tick()`</li>\n</ul><p>先のレンダリング用の配列をいったん空にするまで`flush()`してる。</p>\n\n<ul>\n<li>`createEventDispatcher()`</li>\n</ul><p>自身のコンポーネントに対して、任意のイベントを発行できる`dispatch()`を得るためのもの。</p><p>任意の`type`でコールバックを登録できるようにするための仕組み。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`svelte/internal`の落ち穂拾い</h3>\n    <pre class=\"code\" data-lang=\"\" data-unlink>.\n├── Component.ts\n├── animations.ts\n├── await_block.ts\n├── dev.ts\n├── dom.ts\n├── environment.ts\n├── globals.ts\n├── index.ts\n├── keyed_each.ts\n├── lifecycle.ts\n├── loop.ts\n├── scheduler.ts\n├── spread.ts\n├── ssr.ts\n├── style_manager.ts\n├── transitions.ts\n└── utils.ts</pre><p>ファイルとしてはこれだけあるので、気になるものを見ておく。</p>\n\n<div class=\"section\">\n    <h4>テンプレート補助</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/await_block.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/await_block.ts</a><br />\n<a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/keyed_each.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/keyed_each.ts</a><br />\n<a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/spread.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/spread.ts</a></p>\n\n    </blockquote>\n<p>`markup`部で使える記法のためのヘルパーたち。</p>\n\n</div>\n<div class=\"section\">\n    <h4>アニメーション・トランジション</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/animations.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/animations.ts</a><br />\n<a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/transitions.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/transitions.ts</a><br />\n<a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/style_manager.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/style_manager.ts</a></p>\n\n    </blockquote>\n<p>エフェクトを実行するためのベースの処理たちで、かなり泥臭い処理になってる・・。</p><p>トランジションは、内部的な処理でもDOMの`CustomEvent`を使ってる。</p>\n\n<ul>\n<li>`introstart`</li>\n<li>`introend`</li>\n<li>`outrostart`</li>\n<li>`outroend`</li>\n</ul><p>なのでこれらのイベントが拾える。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`internal/loop`</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/loop.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/loop.ts</a></p>\n\n    </blockquote>\n<p>コンポーネントの各種レンダリングは、`Promise.resolve()`をチェーンしてMicrotaskで実行される。</p><p>こっちはさっきのアニメーション用で、`requestAnimationFrame()`が使われてる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`internal/ssr`</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/ssr.ts\">https://github.com/sveltejs/svelte/blob/master/src/runtime/internal/ssr.ts</a></p>\n\n    </blockquote>\n<p>SSR用のコンポーネント（文字列と関数）を返す用の処理がまとまってる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>コンパイラが生成したコードは、ランタイムで読み込めるAPIを使って動く</li>\n<li>`svelte`コアから`import`できるもの\n<ul>\n<li>コンポーネントの実装そのもの</li>\n<li>各種ライフサイクルへの関数を登録するフック</li>\n</ul></li>\n</ul><p>次の記事で残りの`svelte/*`も読んでしまいたい。</p>\n\n</div>"
}
