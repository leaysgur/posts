{
  "title": "OSSのWebRTC SFU mediasoup v3のコードを読む（サーバー/C++後編）",
  "html": "<p>前編はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/04/04/180307\">OSS&#x306E;WebRTC SFU mediasoup v3&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080;&#xFF08;&#x30B5;&#x30FC;&#x30D0;&#x30FC;/C++&#x524D;&#x7DE8;&#xFF09; - console.lealog();</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>前編のおさらい</h3>\n    <p>SFUのRoomに入ったクライアントがメディアを送受信するためには、`WebRtcTransport`の確立が必要。</p><p>`WebRtcTransport`が確立できると、クライアントはサーバーのICEやDTLSの接続情報を知っている状態になる。<br />\nあとはいつでもいいのでメディアを送受信するAPIを叩けば、通信が開始できるというわけ。</p><p>送信なら`produce()`、受信なら`consume()`で、そのどちらをやった場合でも、`WebRtcTransport`に`connect()`する処理が内部的に走る。</p><p>後編では、この実際にメディアを送受信する時に呼ばれる処理の流れを見ていく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>C++のコードを読む</h3>\n    \n<div class=\"section\">\n    <h4>transport.connect</h4>\n    <p>クライアントが`produce()`や`consume()`でメディアを送受信しようとしたタイミングで発火する。</p><p>そのときにC++側では`transport.connect`のメッセージが渡されて、ICEの処理やDTLSのセッション確立が行われ、メディアの送受信の準備が整う。</p><p>このイベントも`RTC/Router.cpp`からはじまり、`RTC/WebRtcTransport.cpp`へ。</p>\n\n<div class=\"section\">\n    <h5>RTC::WebRtcTransport</h5>\n    \n<ul>\n<li>DTLSのFingerprintやRoleなど、クライアントの接続情報をもらう\n<ul>\n<li>それによって、自身のDTLSの振る舞いを決める</li>\n<li>`DtlsTransport::SetRemoteFingerprint()`</li>\n</ul></li>\n<li>その後、`WrbRtcTransport::MayRunDtlsTransport()`を実行\n<ul>\n<li>この裏でクライアントがオファーアンサーを済ませるはず</li>\n<li>なので、程なくしてDTLSハンドシェイクや他の処理がはじまる</li>\n<li>`DtlsTransport::Run()`へ</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>RTC::DtlsTransport</h5>\n    \n<ul>\n<li>`Run(role)`\n<ul>\n<li>そのRoleから判断して、必要あればDTLSハンドシェイクをする</li>\n<li>ハンドシェイクが成功すると、SRTP用の鍵を取得できるはず</li>\n</ul></li>\n<li>そこまでいければDTLSのステータスが`connected`になる</li>\n</ul><p>そして`RTC/WebRtcTransport.cpp`へ戻る。</p>\n\n</div>\n<div class=\"section\">\n    <h5>RTC::WebRtcTransport</h5>\n    \n<ul>\n<li>`WebRtcTransport::OnDtlsConnected()`\n<ul>\n<li>`RTC::SrtpSession`を用意</li>\n<li>送信用と受信用の2つ</li>\n</ul></li>\n<li>`RTC::Transport::Connected()`\n<ul>\n<li>RTCPのタイマーをスタート</li>\n<li>既に`Consumer`がいれば、キーフレームを要求する（親切）</li>\n</ul></li>\n</ul><p>ここまでくると、DTLS-SRTPのパスが通りサーバーとクライアントの間に`WebRtcTransport`が確立することになって、メディアの送受信の準備が整うことになる。</p>\n\n</div>\n<div class=\"section\">\n    <h5>RTC::SrtpSession</h5>\n    \n<ul>\n<li>`libsrtp`を使っているらしく、コードはそんなにない\n<ul>\n<li><a href=\"https://chromium.googlesource.com/chromium/deps/libsrtp/+/master/\">https://chromium.googlesource.com/chromium/deps/libsrtp/+/master/</a></li>\n</ul></li>\n</ul><p>これもまたあとでメディアを実際に送信するシーンで読むことになるかな？</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>transport.produce</h4>\n    <p>クライアントが`produce()`した時に発火する。<br />\nこの時点で`transport.connect`のメッセージは処理されてるはず。</p><p>`RTC/Tranport.cpp`から読み進める。<br />\n実際は`RTC/WebRtcTransport`がこれを継承してる。</p>\n\n<div class=\"section\">\n    <h5>RTC::Transport</h5>\n    \n<ul>\n<li>新たに`Producer`のIDを払い出し、インスタンスを作成\n<ul>\n<li>`RTC::Producer`</li>\n</ul></li>\n<li>その`Producer`をRTPのリスナーとして追加\n<ul>\n<li>`RTC::RtpListener`</li>\n</ul></li>\n<li>一部のRTPのヘッダ拡張をチェック</li>\n</ul><p>クライアントからメディアが送信されてくる処理なので、RTP関連の話になるというわけ。</p>\n\n</div>\n<div class=\"section\">\n    <h5>RTC::Producer</h5>\n    \n<ul>\n<li>担当する`kind`を指定される\n<ul>\n<li>audioかvideoか</li>\n</ul></li>\n<li>その他に渡されるRTPのパラメータの格納\n<ul>\n<li>コーデックとかヘッダとか</li>\n</ul></li>\n<li>ssrc/ridのチェック</li>\n<li>キーフレームの管理をするクラスの初期化</li>\n</ul><p>初期化でやってるのはそれくらいで、他に主要なメソッドとしては、</p>\n\n<ul>\n<li>`ReceiveRtpPacket()`\n<ul>\n<li>クライアントに紐づく`Producer`がRTPを受け取ったとき</li>\n<li>RTPのストリームを構成するものとしてマーク</li>\n<li>`Router`にそれを通知して、`Consumer`がいればそこに分配する\n<ul>\n<li>`RTC::Consumer::SendRtpPacket()`</li>\n</ul></li>\n</ul></li>\n<li>`GetRtcp()`\n<ul>\n<li>RTCPを送るために必要な情報を集める処理</li>\n</ul></li>\n<li>`ReceiveRtcpSenderReport()`</li>\n<li>`RequestKeyFrame()`\n<ul>\n<li>SSRCでもってキーフレームを要求する</li>\n</ul></li>\n<li>etc..</li>\n</ul><p>その他にもいろいろやってるけど、今回の記事ではあまり踏み込まないので割愛。</p>\n\n</div>\n<div class=\"section\">\n    <h5>RTC::RtpListener</h5>\n    \n<ul>\n<li>`Transport`が抱えるリスナーであり、`Producer`のマップでもあるクラス</li>\n<li>ssrc/rid/midで`Producer`をそれぞれマッピングしてる</li>\n</ul><p>このへんの煩雑さがSFU実装の面倒ポイントの1つなのかなー。</p>\n\n</div>\n<div class=\"section\">\n    <h5>クライアントからメディアを受信</h5>\n    <p>ICEで解決されたポートに対して、UDPのパケットがいろいろ飛んできてるはず。</p><p>前編でみてた`WebRtcTransport`がその役割を担ってて、`WebRtcTransport::OnPacketRecv()`が根本。</p>\n\n<ul>\n<li>各パケットのタイプを見る</li>\n<li>RTPの場合は`OnRtpDataRecv()`</li>\n<li>DTLS-SRTP、ICEのTupleなどセッションが有効かチェック</li>\n<li>SRTPをdecryptしてRTPを取り出し</li>\n<li>RTPのヘッダ拡張を必要あれば適用</li>\n<li>送信元の`Producer`を特定</li>\n<li>その`Producer`にパケットを渡す\n<ul>\n<li>さっき見てた`ReceiveRtpPacket()`へ</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h4>transport.consume</h4>\n    <p>最後にメディアを受信したいときの処理を追う。</p><p>これはクライアントが`consume()`した時に発火する。<br />\nこの時点で`transport.connect`のメッセージは処理されてるはず。</p><p>これも`RTC/Tranport.cpp`から。<br />\n実際は`RTC/WebRtcTransport`がこれを継承してる。</p>\n\n<ul>\n<li>`Consumer`のIDを払い出して、インスタンスを作成\n<ul>\n<li>`Consumer`は3種類: `SimpleConsumer` / `SimulcastConsumer` / `PipeConsumer`</li>\n<li>Encodingの指定が複数あれば`SimulcastConsumer`で、1つなら`SimpleConsumer`など</li>\n</ul></li>\n<li>`Router`に対して、新たな`Consumer`ができたことを通知\n<ul>\n<li>`Router`で`consume()`したい`Producer`IDと`Consumer`を紐づけ</li>\n</ul></li>\n</ul><p>これで特定の`Producer`と`Consumer`が関連付けられて、メディアがクライアントからクライアントへ流れるように。</p>\n\n<div class=\"section\">\n    <h5>RTC::SimpleConsumer / RTC::Consumer</h5>\n    <p>継承関係にあるので、根本の`RTC::Consumer`から。</p>\n\n<ul>\n<li>担当する`kind`の指定</li>\n<li>RTPのパラメータやエンコーディングなどのチェック\n<ul>\n<li>基本的には`Producer`と同じ感じ</li>\n</ul></li>\n</ul><p>次に`RTC::SimpleConsumer`。</p>\n\n<ul>\n<li>`kind`によってRTCPのインターバルの指定を変更</li>\n<li>クライアントに流すようのRTPストリームを作成\n<ul>\n<li>`Router`が`Producer`から受け取ったRTPを流してくれるときに使う</li>\n</ul></li>\n</ul><p>主要なメソッドは、</p>\n\n<ul>\n<li>`SendRtpPacket()`\n<ul>\n<li>`Router`が`Producer`から受け取ったRTPを流してくれるときに呼ばれる</li>\n</ul></li>\n<li>`ProducerNewRtpStream()`\n<ul>\n<li>対応する`Producer`を紐づけ</li>\n</ul></li>\n<li>`ReceiveNack()`\n<ul>\n<li>RTCPのNACKのパケットを受け取ったとき</li>\n</ul></li>\n<li>`ReceiveKeyFrameRequest()`\n<ul>\n<li>これをきっかけに`Producer`にキーフレームを要求する</li>\n</ul></li>\n<li>`ReceiveRtcpReceiverReport()`</li>\n<li>etc..</li>\n</ul><p>などなど、受信用だけあってそれ系のメソッドがいろいろある。</p>\n\n</div>\n<div class=\"section\">\n    <h5>クライアントにメディアを送信</h5>\n    <p>ICEのTupleにパケットを送っているところを探して、逆引きしてみた。<br />\nっても起点となるのは`Producer`側でメディアの送信なので、そこから追うだけ。</p>\n\n<ul>\n<li>`Producer::ReceiveRtpPacket()`\n<ul>\n<li>クライアントがメディアを送信してきた</li>\n</ul></li>\n<li>`Transport::OnProducerRtpPacketReceived()`\n<ul>\n<li>パケットを受けるのは`WebRtcTransport`なので、それを`Router`に分配</li>\n</ul></li>\n<li>`Router::OnTransportProducerRtpPacketReceived()`\n<ul>\n<li>`Router`はそのメディアを`consume()`してる`Consumer()`に分配</li>\n</ul></li>\n<li>`SimpleConsumer::SendRtpPacket()`\n<ul>\n<li>`Consumer`は受け取ったメディアをクライアントへ送信</li>\n</ul></li>\n<li>`Transport::OnConsumerSendRtpPacket()`</li>\n<li>`WebRtcTransport::SendRtpPacket()`\n<ul>\n<li>SRTPにencrypt</li>\n<li>SRTPのセッションが有効化チェック</li>\n</ul></li>\n</ul><p>これですっきり。</p>\n\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3>後編のまとめ</h3>\n    <p>メディアを送受信する`Producer`と`Consumer`の処理をメインにお送りました。<br />\nこれでmediasoupでメディアが送受信される一連の処理はこれでだいたい見たはずですが、まだまだ読み足りない。</p><p>いちおうこの記事で触れてないトピックも一覧にしておくと。</p>\n\n<ul>\n<li>DTLS-SRTPのハンドシェイクまわりの詳細</li>\n<li>ICEのTuple決定までの詳細</li>\n<li>AudioLevelObserver\n<ul>\n<li>その`Router`に属するメディアの音量の統括するやつ</li>\n</ul></li>\n<li>コーデックまわりの解析処理\n<ul>\n<li>VP8とH264</li>\n<li>encode/decode</li>\n</ul></li>\n<li>NACKやREMBなどRTCP関連\n<ul>\n<li>ファイル数としてはこのあたりが一番多い</li>\n<li>各種FBのタイプごとにファイルあったりする</li>\n</ul></li>\n<li>`WebRtcTransport`以外の`Transport`\n<ul>\n<li>`PlainRtpTransport` / `PipeTransport`</li>\n</ul></li>\n<li>RTPのヘッダ拡張やパラメータの取り回しの部分</li>\n<li>`SimlucastConsumer`\n<ul>\n<li>およびそのあたりの実装まるっと全部</li>\n<li>というかSFUの実装という意味での差別化ポイントはここにある</li>\n</ul></li>\n</ul><p>うーん高機能！</p><p>本当に参考になりまくるawesome work👏でした。</p><p>C++、こんな感じでコードを読む分にはいけるけど、実際に書くとなると大変そう・・という感想になりました。</p>\n\n</div>"
}
