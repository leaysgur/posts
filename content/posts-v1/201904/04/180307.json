{
  "title": "OSSのWebRTC SFU mediasoup v3のコードを読む（サーバー/C++前編）",
  "html": "<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>はまだ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/noob\">noob</a>なんですが、雰囲気を察して読んでみたメモです。</p><p>サーバー/NodeJS編はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/03/25/180850\">OSS&#x306E;WebRTC SFU mediasoup v3&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080;&#xFF08;&#x30B5;&#x30FC;&#x30D0;&#x30FC;/NodeJS&#x7DE8;&#xFF09; - console.lealog();</a></p>\n\n    </blockquote>\n<p>最低限のコードだけでも読んでて息切れするほどにデカいので、前後編にしました。<br />\nただそれでもすべてのコードを読めたわけではないという。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>コードの入手</h3>\n    <p>NodeJS編と同じです。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リだけ少し違うくて、Nodeが`/lib`で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>は`/worker/src`が本体。</p><p>多すぎるので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リとエントリーポイントである`main.cpp`だけを載せるとこのような構造。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── Channel\n├── RTC\n│   ├── Codecs\n│   ├── REMB\n│   ├── RTCP\n│   └── RtpDictionaries\n├── Utils\n├── handles\n└── main.cpp</pre><p>`RTC`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リの中がメディアサーバーとしての本丸って感じで、70ファイルくらいあります。</p><p>コードを読むための前提知識としては、</p>\n\n<ul>\n<li>Node側から子プロセスとして`spawn()`されるのが`main.cpp`\n<ul>\n<li>それが`Worker`という概念を初期化する</li>\n</ul></li>\n<li>Node側と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>側は、`Channel`という概念を使って互いにメッセージングしてる\n<ul>\n<li>`Worker`は基本的にパッシブで、メッセージを待ち受ける</li>\n<li>なのでコードを読むのもそのメッセージ名からたどることになるはず</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>の1Roomごとに、`Worker`が1つ存在する\n<ul>\n<li>参加するクライアントはみんな同じ`Worker`に対して接続する</li>\n</ul></li>\n</ul><p>という感じ。</p><p>ではまずエントリーポイントから。</p>\n\n</div>\n<div class=\"section\">\n    <h3>main()</h3>\n    <p>言わずもがな`main.cpp`。</p>\n\n<ul>\n<li>`main()`で各種<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の初期化をしてる\n<ul>\n<li>ベースになってる`libuv`を筆頭に</li>\n</ul></li>\n<li>Node側とやり取りするための`Channel`の設定\n<ul>\n<li>`spawn()`時に渡されるファイル<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%B9%A5%AF%A5%EA%A5%D7%A5%BF\">ディスクリプタ</a>を使ってる</li>\n</ul></li>\n<li>各種サーバー設定の反映</li>\n<li>各クラスのstaticの初期化\n<ul>\n<li>OpenSSLやSRTP、DTLSなどなど</li>\n<li>後述</li>\n</ul></li>\n<li>`Worker`の起動\n<ul>\n<li>起動できればNode側に最初のイベントが飛ぶ</li>\n<li>`Worker`は`libuv`のループを走らせて待機</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>RTC::DtlsTransport / RTC::SrtpSession</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>文化なのか、クラスのstaticにて自クラスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>のための処理をやるらしい。</p><p>まずはDTLSの`RTC/DtlsTransport.cpp`の`ClassInit()`から。</p>\n\n<ul>\n<li>DTLSのために<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TLS\">TLS</a>のコンテキストを初期化\n<ul>\n<li>DTLSのバージョンをOpenSSLのバージョンで決める</li>\n<li>古いやつだとDTLSv1.0になる</li>\n<li>もっと古いとエラー</li>\n</ul></li>\n<li>ECDHの有効化など</li>\n<li>`use_srtp`の拡張を指定</li>\n<li>各ハッシュごとにFingerprintの用意</li>\n</ul><p>つぎ、SRTPは`RTC/SrtpSession.cpp`にて。</p>\n\n<ul>\n<li>実装は`libsrtp`を使ってる\n<ul>\n<li>ので、それに<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%D9%A5%F3%A5%C8%A5%CF%A5%F3%A5%C9%A5%E9\">イベントハンドラ</a>を追加するくらい</li>\n</ul></li>\n</ul><p>ほかにもstatic関連でやってることはあるけど割愛。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Worker</h4>\n    <p>`Worker.cpp`です。</p>\n\n<ul>\n<li>`Channel`でのメッセージに対してのハンドラを自身に定義して紐づけ\n<ul>\n<li>あとは`SIGTERM`などのシグナルに対するハンドラも</li>\n</ul></li>\n<li>Node側に`running`だと状態を通知</li>\n<li>`libuv`のloopを実行</li>\n</ul><p>`Channel`を通して受けたメッセージを見てハンドラを実行、その結果をまた`Channel`で返すのが主な仕事。</p><p>後で登場するけど、ここで`Router`の新規作成やら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>の保持もやってます。<br />\n`Channel`から受け取ったメッセージのいくつかは、そのまま`Router`のハンドラに委譲したりもしてる。</p><p>なのでそのメッセージを追っていけば、処理の本体にもたどりつけるはず。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>最低限のデモから動きをおさらい</h3>\n    <p>ちょっとだけNodeJSのサイドを見直します。</p><p>というのも、クライアントからの入力を受けるのはNodeが起点になるからで、そのきっかけをおさらいしておきたく。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/mediasoup-demo-v3-simple\">GitHub - leader22/mediasoup-demo-v3-simple</a></p>\n\n    </blockquote>\n<p>またもこの最低限の自作デモから、サーバーサイドで使ってる各クラスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を抜粋すると・・、</p>\n\n<ul>\n<li>Worker\n<ul>\n<li>createRouter()</li>\n</ul></li>\n<li>Router\n<ul>\n<li>createWebRtcTransport()</li>\n<li>canConsume()</li>\n</ul></li>\n<li>WebRtcTransport\n<ul>\n<li>connect()</li>\n<li>produce()</li>\n<li>consume()</li>\n</ul></li>\n</ul><p>最低限の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>の機能を使うのに必要なNodeの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はこれだけ。</p><p>これらを追えば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>側に投げてるメッセージのタイプがわかるはずで、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>側の入り口に到達できるという算段。</p><p>以下、Node側でやってることのサマリです。</p>\n\n<div class=\"section\">\n    <h4>Worker</h4>\n    \n<div class=\"section\">\n    <h5>createRouter()</h5>\n    \n<ul>\n<li>`worker.createRouter`というメッセージを送る\n<ul>\n<li>レスポンスはなし</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h4>Router</h4>\n    \n<div class=\"section\">\n    <h5>createWebRtcTransport()</h5>\n    \n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>として待ち受けるサーバーを建てる処理\n<ul>\n<li>IPとか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>どっちを優先するとか</li>\n</ul></li>\n<li>`router.createWebRtcTransport`というメッセージを送る\n<ul>\n<li>ICEとDTLSのデータが返る</li>\n<li>クライアントがいつでもつなぎにいけるようになる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>canConsume()</h5>\n    \n<ul>\n<li>サーバー起動時に指定していたコーデックやパラメータの設定を照会するだけ</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>側は関係ない</li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h4>WebRtcTransport</h4>\n    <p>呼び出しシーケンス的には、`produce()` OR `consume()`すると、内部的に`connect()`が先に走るイメージ。</p>\n\n<div class=\"section\">\n    <h5>connect()</h5>\n    \n<ul>\n<li>クライアントからDTLSのパラメータを受け取る\n<ul>\n<li>さっき渡してたやつ</li>\n</ul></li>\n<li>`transport.connect`というメッセージを送る\n<ul>\n<li>DTLSの役割が返る</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>produce()</h5>\n    \n<ul>\n<li>クライアントがメディアを送信してきた処理</li>\n<li>`transport.produce`というメッセージを送る\n<ul>\n<li>送るのはメディアの種類やRTPのパラメータ</li>\n<li>返るのはメディアの状況</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>consume()</h5>\n    \n<ul>\n<li>クライアントがメディアを受信したいときの処理</li>\n<li>`transport.consume`というメッセージを送る\n<ul>\n<li>送るのはメディアの種類やRTPのパラメータ</li>\n<li>返るのはメディアの状況</li>\n</ul></li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>のコードを読む</h3>\n    <p>さっき調べた`Channel`のメッセージのタイプからそれぞれの処理を見ていきます。</p>\n\n<ul>\n<li>worker.createRouter</li>\n<li>router.createWebRtcTransport</li>\n<li>transport.connect</li>\n<li>transport.produce</li>\n<li>transport.consume</li>\n</ul>\n<div class=\"section\">\n    <h4>worker.createRouter</h4>\n    <p>まず最初に必要となる`Router`を作るタイミングで発火。</p><p>メッセージは`Worker`で受け取って、`RTC::Router`を初期化してるだけ。<br />\n`RTC/Router.cpp`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タでやってることも何もなくて、以降のタイミングで使われるもの。</p>\n\n</div>\n<div class=\"section\">\n    <h4>router.createWebRtcTransport</h4>\n    <p>クライアントが`produce()`や`consume()`でメディアを送受信するために、まずWebRTCのトランスポートが必要。<br />\nそれを用意する前段のタイミングで発火する。</p><p>これは`RTC/Router.cpp`から。</p>\n\n<ul>\n<li>`Transport`の初期化\n<ul>\n<li>`RTC::WebRtcTransport`</li>\n</ul></li>\n<li>`Router`に保持</li>\n<li>`FillJson()`してクライアントに情報を返す</li>\n</ul><p>初期化してる`WebRtcTransport`がメイン。<br />\n`RTC/WebRtcTransport.cpp`は、圧巻の1200行。</p><p>まずはコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タ。</p>\n\n<ul>\n<li>`RTC/Transport.cpp`を継承してる</li>\n<li>ICEのセットアップ\n<ul>\n<li>待ち受けるIPの数だけ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/TCP\">TCP</a>ソケットを作る</li>\n<li>`RTC::UdpSocket`/`RTC::TcpSocket`</li>\n<li>そしてパケットの待受</li>\n<li>STUN / RTCP / RTP / DTLS</li>\n</ul></li>\n<li>ICEのサーバーを建てる\n<ul>\n<li>`RTC::IceServer`</li>\n</ul></li>\n<li>DTLSの用意\n<ul>\n<li>`RTC::DtlsTransport`</li>\n</ul></li>\n</ul><p>`fillJson()`で返すサーバーの情報は、概ねこんな感じ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">{</span>\n  iceRole: <span class=\"synConstant\">'controlled'</span>,\n  iceParameters: <span class=\"synIdentifier\">{</span>\n    usernameFragment,\n    password,\n    iceLite: <span class=\"synConstant\">true</span>,\n  <span class=\"synIdentifier\">}</span>,\n  iceCandidates: <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{}</span>, <span class=\"synIdentifier\">{}</span>, ..., <span class=\"synIdentifier\">{}</span>,\n  <span class=\"synIdentifier\">]</span>,\n  iceState,\n  dtlsParamseters: <span class=\"synIdentifier\">{</span>\n    fingerprints: <span class=\"synIdentifier\">[{</span>\n      algorithm,\n      value,\n    <span class=\"synIdentifier\">}</span>, <span class=\"synIdentifier\">{}</span>, ..., <span class=\"synIdentifier\">{}</span>,<span class=\"synIdentifier\">]</span>,\n    role,\n  <span class=\"synIdentifier\">}</span>,\n  dtlsState,\n  rtpHeaderExtensions: <span class=\"synIdentifier\">{</span>\n    absSendTime,\n    mid,\n    rid,\n    rrid,\n  <span class=\"synIdentifier\">}</span>,\n  rtpListener,\n<span class=\"synIdentifier\">}</span>\n</pre><p>これをクライアントに返すので、クライアントは任意のタイミングで接続を開始できるようになる仕組み。</p><p>ここで初期化してるクラスの深掘りをしておく。</p>\n\n<div class=\"section\">\n    <h5>RTC::IceServer</h5>\n    \n<ul>\n<li>ICE-Liteなので、クライアントにはレスポンスするだけ</li>\n<li>引数は`ufrag`と`password`</li>\n<li>クライアントからSTUNメッセージが届くのを待つ\n<ul>\n<li>さっき待ち受けた</li>\n</ul></li>\n<li>ハンドラは`ProcessStunMessage()`\n<ul>\n<li>STUNの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%F3%A5%C7%A5%A3%A5%F3%A5%B0\">バインディング</a>リク<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>トを検証する</li>\n<li>内容に応じてエラーレスポンスや成功レスポンスを返す</li>\n</ul></li>\n<li>成功の場合、`HandleTuple()`でクライアントのトランスポートアドレスをさばく</li>\n<li>stateが`connected`か`complete`になったら、DTLSの接続へ\n<ul>\n<li>`WebRtcTransport::MayRunDtlsTransport()`</li>\n<li>あとで`connect()`された時に呼ばれるはず</li>\n</ul></li>\n<li>ICEの経路が決まると、`WebRtcTransport::OnIceSelectedTuple()`を呼ぶ\n<ul>\n<li>このIP/ポート上で、今後一切のパケットが流れる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>RTC::DtlsTransport</h5>\n    <p>こちらも圧巻の1200行超え。</p>\n\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSL\">SSL</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>の生成\n<ul>\n<li>BIO</li>\n<li>タイマー</li>\n</ul></li>\n</ul><p>コンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タはこれくらい。<br />\nこのクラスもあとで`connect()`されてからいろいろ呼ばれるはず。</p><p>ともあれ、`WebRtcTransport`というクラスが、`iceSelectedTuple`上で、クライアントとのパケットのやり取りを一手に引き受けることになる。<br />\nなにかの処理を追うときは、まずこのクラスからでよさそう。</p>\n\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3>前編のまとめ</h3>\n    <p>Nodeはユーザーランドのコードから呼ばれるただのI/Oであって、処理の実態はほとんど<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>にある。<br />\nただNode側と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>側でも概念は一致していて、透過的に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>を作れると思ってよい。</p>\n\n<ul>\n<li>Roomごとに`Worker`ができる\n<ul>\n<li>`Worker`は実行されるプロセスであって、メディア処理の実態ではない</li>\n<li>`Worker`は`Channel`を保持していて、Nodeと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/C%2B%2B\">C++</a>をつないでいる</li>\n</ul></li>\n<li>`Worker`は`Router`を作ってRoomに割り当てる\n<ul>\n<li>以降の処理は`Router`が起点になる</li>\n<li>もちろん`Channel`を保持している</li>\n</ul></li>\n<li>`Router`は`Transport`をクライアントとの間に作る\n<ul>\n<li>`Transport`には種類があって、今回は`WebRtcTransport`を使ってる</li>\n<li>その上でクライアントとパケットを送り合う</li>\n<li>= その上でメディアをやり取りする</li>\n<li>そこで出てくる概念が`Producer`/`Consumer`</li>\n</ul></li>\n</ul><p>という構造になっていて、この記事ではメディアのやり取りをするために準備を整えるところまで書きました。</p><p>この時点ではWebRTC的な通信は開始されてないけど、いつでもいいのでメディアを送受信する<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を叩けば、通信が開始できるという段階。<br />\n後編では、実際にメディアを送受信する時に呼ばれる処理の流れを見ていきます。</p><p>引き続き後編へ。</p>\n\n</div>"
}
