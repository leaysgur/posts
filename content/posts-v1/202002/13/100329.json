{
  "title": "JavaScriptでもバーチャル背景する",
  "html": "<p>やってやれないことはなかったです。<br />\nぱっと思いついた2通りのアプローチで実装してみたので、その学びをメモっておきます。</p><p>ただ、個人的には別にいらない機能かな・・。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>バーチャル背景とは</h3>\n    \n    <blockquote>\n        <p><a href=\"https://support.zoom.us/hc/ja/articles/210707503-%E3%83%90%E3%83%BC%E3%83%81%E3%83%A3%E3%83%AB%E8%83%8C%E6%99%AF\">&#x30D0;&#x30FC;&#x30C1;&#x30E3;&#x30EB;&#x80CC;&#x666F; &ndash; Zoom &#x30D8;&#x30EB;&#x30D7;&#x30BB;&#x30F3;&#x30BF;&#x30FC;</a></p>\n\n    </blockquote>\n<p>たとえばWeb会議のZoom（のデスクトップクライアント）で使える機能で、汚部屋や背景をさくっと隠せて便利！というもの。</p><p>JavaScriptでもこういうことやりたいなーと思ったときに、どういうアプローチがあって、どういう仕上がりになるか？をやってみた話です。</p>\n\n</div>\n<div class=\"section\">\n    <h3>案1: クロマキー合成</h3>\n    \n    <blockquote>\n        <p><a href=\"https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%9E%E3%82%AD%E3%83%BC\">&#x30AF;&#x30ED;&#x30DE;&#x30AD;&#x30FC; - Wikipedia</a></p>\n\n    </blockquote>\n<p>TVでおなじみ（ガチャピンが消えてたやつ）の手法。</p><p>グリーンバックとかブルーバックとか、とにかくベタ塗りの背景の前に立って撮る。<br />\nそして撮ったデータのピクセルの色を判定し、そのベタ塗りの色なら透過にして、背景と合成する。</p>\n\n<div class=\"section\">\n    <h4>実装</h4>\n    <p>コードもシンプルで、</p>\n\n<ul>\n<li>事前に抜きたい色を決めておく</li>\n<li>`canvas`に映像を貼り付ける</li>\n<li>指定された色を探して見つかったらそこを透過にする</li>\n<li>背景の上に貼り付ける</li>\n</ul><p>ってだけ。</p><p>そんなコードを使いやすくラップしてライブラリにしたのがこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/chromakey\">GitHub - leader22/chromakey: Minimum chroma key processing for your camera stream.</a></p>\n\n    </blockquote>\n<p>コードはこんな感じで使えるようにした。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> create <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;chromakey&quot;</span>;\n\n(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// setup input and output HTMLVideoElement</span>\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">[</span>$<span class=\"synStatement\">in</span>, $out<span class=\"synIdentifier\">]</span> = <span class=\"synStatement\">document</span>.querySelectorAll(<span class=\"synConstant\">&quot;video&quot;</span>);\n  $<span class=\"synStatement\">in</span>.muted = $<span class=\"synStatement\">in</span>.playsInline = <span class=\"synConstant\">true</span>;\n  $out.muted = $out.playsInline = <span class=\"synConstant\">true</span>;\n\n  <span class=\"synComment\">// get media to process</span>\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n  $<span class=\"synStatement\">in</span>.srcObject = stream;\n  await $<span class=\"synStatement\">in</span>.play();\n\n  <span class=\"synComment\">// create ChromaKey instance w/ base img, video, or canvas</span>\n  <span class=\"synStatement\">const</span> ck = create($<span class=\"synStatement\">in</span>);\n\n  ck.setColor(<span class=\"synIdentifier\">[</span>255, 255, 255<span class=\"synIdentifier\">]</span>);\n  ck.setThreshold(100);\n\n  <span class=\"synComment\">// your background</span>\n  ck.setBackgroundColor(<span class=\"synIdentifier\">[</span>\n    Math.random() * 255,\n    Math.random() * 255,\n    Math.random() * 255,\n  <span class=\"synIdentifier\">]</span>);\n  <span class=\"synComment\">// ck.setBackgroundMedia();</span>\n\n  <span class=\"synComment\">// run it</span>\n  ck.start();\n\n  <span class=\"synComment\">// display processed output</span>\n  $out.srcObject = ck.destination.captureStream();\n  await $out.play();\n\n  <span class=\"synComment\">// ck.stop();</span>\n<span class=\"synIdentifier\">}</span>)();\n</pre><p>指定の色かどうかを判定する部分はある程度のしきい値をもうけて調整できるようにしてみた。</p><p>`video`を受け取って`canvas`を返すAPIになってるので、`captureStream()`すればWebRTCで飛ばすこともできます。</p>\n\n</div>\n<div class=\"section\">\n    <h4>パフォーマンス</h4>\n    <p>そういうベタ塗り画像の背景を消す用途にはバッチリ使えた。</p><p>ただWeb会議に組み込んで使うとなると・・・、そもそもグリーンバックがない！！<br />\n家の白っぽい壁だと、照明との兼ね合いで調整がだいぶ難しいし、顔が白飛びしたりする！</p><p>という感じで、ちゃんとした設備があるなら使えるけど、そうでないならだいぶ厳しかったのが正直なところ。</p><p>デモもあるのでこの厳しさをぜひお試しあれ。</p>\n\n    <blockquote>\n        <p><a href=\"https://leader22.github.io/chromakey\">https://leader22.github.io/chromakey</a></p>\n\n    </blockquote>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>案2: 機械学習</h3>\n    <p>やはり時代はマシンラーニング！<br />\n画像データに対して「人物っぽい部分」を判定して、そこを切り抜くアプローチ。</p>\n\n<div class=\"section\">\n    <h4>実装</h4>\n    <p>幸いなことにTensorFlowにずばりそれ用の`BodyPix`というモデルがあったのでそれを使ってみる。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/tensorflow/tfjs-models/tree/master/body-pix\">tfjs-models/body-pix at master &middot; tensorflow/tfjs-models &middot; GitHub</a></p>\n\n    </blockquote>\n<p>試したバージョンはこのとおり。</p>\n\n<ul>\n<li>tfjs@1.5.2\n<ul>\n<li>tf.setBackend(\"wasm\")</li>\n</ul></li>\n<li>body-pix@2.0.4</li>\n</ul><p>コードはこんな感じになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> net = await bodyPix.load();\n\n  <span class=\"synComment\">// input source</span>\n  <span class=\"synStatement\">const</span> $video = <span class=\"synStatement\">document</span>.querySelector(<span class=\"synConstant\">&quot;video&quot;</span>);\n  <span class=\"synComment\">// output source</span>\n  <span class=\"synStatement\">const</span> $destCanvas = <span class=\"synStatement\">document</span>.querySelector(<span class=\"synConstant\">&quot;canvas&quot;</span>);\n\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n  $video.srcObject = stream;\n\n  <span class=\"synStatement\">document</span>.querySelector(<span class=\"synConstant\">&quot;button&quot;</span>).onclick = async () =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// THESE LINES ARE REQUIRED!</span>\n    $video.width = $destCanvas.width = $video.videoWidth;\n    $video.height = $destCanvas.height = $video.videoHeight;\n\n    <span class=\"synStatement\">const</span> destCtx = $destCanvas.getContext(<span class=\"synConstant\">&quot;2d&quot;</span>);\n\n    <span class=\"synComment\">// to remove background, need another canvas</span>\n    <span class=\"synStatement\">const</span> $tempCanvas = <span class=\"synStatement\">document</span>.createElement(<span class=\"synConstant\">&quot;canvas&quot;</span>);\n    $tempCanvas.width = $video.videoWidth;\n    $tempCanvas.height = $video.videoHeight;\n    <span class=\"synStatement\">const</span> tempCtx = $tempCanvas.getContext(<span class=\"synConstant\">&quot;2d&quot;</span>);\n\n    (async <span class=\"synIdentifier\">function</span> loop() <span class=\"synIdentifier\">{</span>\n      requestAnimationFrame(loop);\n\n      <span class=\"synComment\">// create mask on temp canvas</span>\n      <span class=\"synStatement\">const</span> segmentation = await net.segmentPerson($video);\n      <span class=\"synStatement\">const</span> mask = bodyPix.toMask(segmentation);\n      tempCtx.putImageData(mask, 0, 0);\n\n      <span class=\"synComment\">// draw original</span>\n      destCtx.drawImage($video, 0, 0, $destCanvas.width, $destCanvas.height);\n      <span class=\"synComment\">// then overwrap, masked area will be removed</span>\n      destCtx.save();\n      destCtx.globalCompositeOperation = <span class=\"synConstant\">&quot;destination-out&quot;</span>;\n      destCtx.drawImage($tempCanvas, 0, 0, $destCanvas.width, $destCanvas.height);\n      destCtx.restore();\n    <span class=\"synIdentifier\">}</span>)();\n  <span class=\"synIdentifier\">}</span>;\n<span class=\"synIdentifier\">}</span>)();\n</pre><p>注意点としては、`segmentPerson()`に渡すインプットで、これに`width`と`height`のプロパティに値が必須なこと。（`video`ならとりあえず`videoHeight`と`videoWidth`をコピーするだけでいい）<br />\nこれに気付かずめっちゃハマった・・・。</p><p>仕組みとしてはMLでセグメンテーションして、その結果を使ってマスクを作って、あわせて描画してるだけ。<br />\n`canvas`の`globalCompositeOperation`で重なりをどう合成するか指定するシンプルなコードになったはず。</p><p>`tfjs/body-pix`は、こういった描画の部分でいくつか便利メソッドを公開してて、体の一部をぼかすとか、背景をぼかすのがあったりするけど、バーチャル背景用途に透過するものはなかった。<br />\nあったら嬉しくない？ってIssue立てたけど、いまだ返事はない・・。</p><p>ちなみに背景ボケはこんな感じでできちゃう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> img = <span class=\"synStatement\">document</span>.getElementById(<span class=\"synConstant\">'image'</span>);\n<span class=\"synStatement\">const</span> canvas = <span class=\"synStatement\">document</span>.getElementById(<span class=\"synConstant\">'canvas'</span>);\n\n<span class=\"synStatement\">const</span> net = await bodyPix.load();\n<span class=\"synStatement\">const</span> segmentation = await net.segmentPerson(img);\n\n<span class=\"synStatement\">const</span> backgroundBlurAmount = 3;\n<span class=\"synStatement\">const</span> edgeBlurAmount = 3;\n<span class=\"synStatement\">const</span> flipHorizontal = <span class=\"synConstant\">false</span>;\n\nbodyPix.drawBokehEffect(\n  canvas, img, segmentation, \n  backgroundBlurAmount, edgeBlurAmount, flipHorizontal\n);\n</pre><p>簡単すぎる・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>パフォーマンス</h4>\n    <p>こっちはライブラリにはしてないけど、さっきのクロマキーのリポジトリに簡単なデモだけ置いといた。</p>\n\n    <blockquote>\n        <p><a href=\"https://leader22.github.io/chromakey/tfjs-body-pix/index.html\">https://leader22.github.io/chromakey/tfjs-body-pix/index.html</a></p>\n\n    </blockquote>\n<p>かがくのちからってすげー！<br />\nどうみてもこれが顧客が欲しかったものであり、バーチャル背景って聞いたらこっちのアプローチになるんかなー。</p><p>ただ長時間やってるとファンが結構回ってくる（WASMバックエンドにしてもそれなりに）ので、学習モデルのパラメータを調整したりする余地はあるかなーという感じ。<br />\nなのでZoomもデスクトップクライアントでだけ使えるんかなーと。</p>\n\n</div>\n</div>"
}
