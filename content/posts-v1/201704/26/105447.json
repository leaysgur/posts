{
  "title": "Docker？なにそれおいしいの？ for フロントエンド（だけやる）エンジニア",
  "html": "<p>最初に結論を書いてしまうけど、フロントエンド（だけやる）エンジニアにはたぶんおいしくない。</p><p>っていうことに気付くまでの学びを社内勉強会用にまとめたメモ。<br />\n概念的なところがメインなので、細かいDockerのコマンドとかそういうのには触れません。</p>\n\n    <blockquote>\n        <p>あんまり詳しい分野じゃないので、なんか変なこと書いてたら教えてください・・・！</p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Docker is 何</h3>\n    \n    <blockquote>\n        <p><a href=\"https://docs.docker.com/\">Docker Documentation - Docker Documentation</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h4>Docker is コンテナ型の仮想化技術</h4>\n    \n<ul>\n<li>\"ざっくり\"いうと、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/KVM\">KVM</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VMWare\">VMWare</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Hyper-V\">Hyper-V</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VirtualBox\">VirtualBox</a>とかと同じ\n<ul>\n<li>ホストOS（たとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mac\">mac</a>）上で、ゲストOS（たとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\">Linux</a>）を動かせる</li>\n</ul></li>\n<li>もう少しだけ\"厳密\"にいうと、コンテナ型の仮想化技術というもの\n<ul>\n<li>先述のVirtualMachineたち（完全仮想化とか言ったりする）とは違う</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>コンテナ</h4>\n    \n<ul>\n<li><a href=\"https://www.docker.com/what-container#comparing\">What is a Container | Docker</a>\n<ul>\n<li>仮想化する部分が一部 = 軽快</li>\n<li>ポータビリティ！</li>\n</ul></li>\n<li>アプリケーション（WebサーバーとかDBサーバーとか）の実行環境\n<ul>\n<li>そのサービスの実行に必要なものを全部ひとまとめにしたもの</li>\n</ul></li>\n<li>そんなサービスが起動するプロセスの単位\n<ul>\n<li>黒い画面でなんかコマンド叩くと実行されて、終わったら消えるアレがプロセス</li>\n<li>何回やってもどこでやっても同じ結果</li>\n<li>状態は持たない <- 重要</li>\n<li>あの感覚でアプリケーションを動かせる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>コンテナ = イメージをビルドしたもの</h4>\n    \n<ul>\n<li>Dockerfile\n<ul>\n<li>コンテナの構成を定義をするファイル</li>\n<li><a href=\"https://github.com/nodejs/docker-node/blob/master/7.9/Dockerfile\">docker-node/Dockerfile at master &middot; nodejs/docker-node &middot; GitHub</a></li>\n</ul></li>\n<li>これを使ってイメージというものをビルド\n<ul>\n<li>このビルドされたイメージ = コンテナ</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>よさそう</h4>\n    \n<ul>\n<li>コンテナの単位でデプロイとかできるといいよね\n<ul>\n<li>Immutable Infrastructureとかいう思想</li>\n<li><a href=\"https://martinfowler.com/bliki/BlueGreenDeployment.html\">BlueGreenDeployment</a></li>\n</ul></li>\n<li>Dockerさえ動けば、どこでも動かせる\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/macOS\">macOS</a>, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\">Linux</a>, Heroku, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/AWS\">AWS</a>, ..etc</li>\n<li>仮想リソースなのでいらなくなったら消せばいい</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>だが実際は</h4>\n    \n<ul>\n<li>コンテナ = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D6%A5%E9%A5%C3%A5%AF%A5%DC%A5%C3%A5%AF%A5%B9\">ブラックボックス</a>\n<ul>\n<li>メモリ足りなくて死んだりするのどうやって拾うの</li>\n<li>障害時の切り分け</li>\n<li>ログ吐いたり見たりしたいけどドコに・・</li>\n</ul></li>\n<li>Dockerfileのメンテが辛い</li>\n<li>実際に運用するには<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AA%A1%BC%A5%B1%A5%B9%A5%C8%A5%EC%A1%BC%A5%B7%A5%E7%A5%F3\">オーケストレーション</a>ツールが別途でほぼ必須\n<ul>\n<li>docker-compose, Swarm, Kubernetes, ...etc</li>\n</ul></li>\n</ul><p>と、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%CD%AD%BC%B1%BC%D4\">有識者</a>の方々はおっしゃる・・( ˘ω˘)<br />\n可能性はあるが、まだ枯れてはいないというのが現状のステータスっぽい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ここまでのまとめ</h4>\n    \n<ul>\n<li>アプリケーションをコンテナという単位で扱えるのがキモ\n<ul>\n<li>Dockerが動くところであればコンテナが動く = サービスが動く</li>\n</ul></li>\n<li>イメージの中に、アプリのコードや依存関係は含まれる\n<ul>\n<li>コードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GitHub\">GitHub</a>にpush -> CIが動いてイメージをビルド</li>\n<li>そのイメージ（＝コンテナ）が、本番環境でもそのまま実行される</li>\n</ul></li>\n</ul><p>というのがそもそものDockerの本意。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>我々にとっておいしいか</h3>\n    \n<div class=\"section\">\n    <h4>おいしいも何も、関係ない（かも）</h4>\n    <p>ここまで見てきて、自分には関係ないかな・・と思ったら、関係ない。</p><p>Dockerの本来の用途に関して言えば、</p>\n\n<ul>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`にサーバー建てて開発する</li>\n<li>環境依存なのはNode.jsくらい</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GitHub\">GitHub</a>にコードをpushすればおわり</li>\n<li>あっても静的なデータを返す<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>モックサーバーくらい</li>\n</ul><p>っていういわゆるフロントエンド（だけやる）エンジニアにとっては、無用の長物なのは間違いない。<br />\n使いたいなら使えばいいけど。</p>\n\n</div>\n<div class=\"section\">\n    <h4>おいしいかもしれない</h4>\n    \n<ul>\n<li>フロントエンドはいつもどおり`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/localhost\">localhost</a>`で開発</li>\n<li>ただし他にもサーバーがないと開発できない場合\n<ul>\n<li>サーバーサイドで動かすべきロジックがある</li>\n<li>モックデータの入ったDBサーバーがいる</li>\n<li>Redisみたいなやつもいる・・etc</li>\n</ul></li>\n</ul><p>適当にモック用のBFFみたいなの用意したらええやんってのはさておき、こういうのがDockerで動かせる場合はおいしい。</p><p>適当なコマンド一発でコンテナが起動して、適当なポートでアクセスできるようにしてるはず。<br />\n`npm start`するついでに`docker run`とか`docker-compose up`すればいいだけ。</p><p>Dockerさえインス<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%EB\">トール</a>してれば、環境構築したり他に何かインス<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A1%BC%A5%EB\">トール</a>したりしなくていいので楽ちん。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Docker = ただの軽い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VM\">VM</a>ではない</h4>\n    <p>けども、そういう使い方もできてしまう。</p>\n\n<ul>\n<li>ホストOS（たとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mac\">mac</a>）で、ゲストOS（たとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Linux\">Linux</a>）を動かす\n<ul>\n<li>実行環境（Nodeとか）は、ゲストOS側に</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>（`node_modules`含む）は、ホストOS側に</li>\n</ul></li>\n</ul><p>みたいに、コンテナの中で状態が持てないなら、開発中で変化するものはホスト側に残しておくしかない。<br />\nコンテナの実行時にコピーしたりボリューム共有したりしてやってく。</p><p>ただしその場合、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VirtualBox\">VirtualBox</a>とか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vagrant\">Vagrant</a>とかで過去にやってたのと同じ問題がつきまとう。</p>\n\n<div class=\"section\">\n    <h5>ホスト <-> ゲスト間のファイルI/Oが激遅い問題</h5>\n    <p>修正した内容が反映されるのが遅いとか、いわゆる`npm run watch`的なやつが遅くて使い物にならん問題。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/docker/for-mac/issues/77\">File access in mounted volumes extremely slow &middot; Issue #77 &middot; docker/for-mac &middot; GitHub</a></p>\n\n    </blockquote>\n<p>公式でもだいぶ前から取り上げられてるけど、イマイチ解決策が出てきてない。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Vagrant\">Vagrant</a> x <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VirtualBox\">VirtualBox</a>の頃は`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/rsync\">rsync</a>`で手動コピーしたりしてなんとかしてた思い出がある・・。</p><p>Dockerの場合でも一緒。</p>\n\n<ul>\n<li><a href=\"http://docker-sync.io/\">docker-sync by EugenMayer</a></li>\n<li><a href=\"https://github.com/zchee/docker-machine-driver-xhyve\">GitHub - zchee/docker-machine-driver-xhyve: docker-machine/libmachine driver plugin for xhyve/hyperkit (native macOS hypervisor.framework)</a></li>\n</ul><p>などなど結局がんばるしかなくて、Docker for <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Mac\">Mac</a>とかから参入したエンジョイ勢はたぶんここで駆逐される。<br />\n大したファイル数がないとか、別にこの遅さが待てるとかなら問題にはならんけど。</p>\n\n</div>\n<div class=\"section\">\n    <h5>ホストとゲストでOS違う問題</h5>\n    <p>Cとかのネイティブモジュールを使うモジュールにありがち。`node-sass`とか。<br />\n`npm install`する側（= ホスト側 = <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mac\">mac</a>）でビルドしたモジュールが、ゲスト側で使えない。</p><p>どうしようもない気がする。</p><p>諦めて全部ホスト側でやったらいいと思う。<br />\n`yarn.lock`で依存関係もだいぶマシになったし、せいぜい解決できてNodeのバージョンくらい・・。</p>\n\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>というわけで、フロントエンド（だけやる）エンジニアにとっては、知らなくても困らんと思う。</p><p>まあ知識は無駄にならんし、CircleCIが2.0になってDockerが1stサポートになったので、ちょっと楽ができるかもーくらい。</p><p>本質を見極めた上で、選択・判断しよう、そのために日々勉強しようという話か・・。</p>\n\n</div>"
}
