{
  "title": "Qwikというフレームワークについて",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik\">GitHub - BuilderIO/qwik: An Open-Source framework designed for best possible time to interactive, by focusing on resumability of server-side-rendering of HTML, and fine-grained lazy-loading of code.</a></p>\n\n    </blockquote>\n<p>去年から気になってて、調べたいなーと思ってたやつ。</p><p>昨今の覇権を握ってる系のJavaScript-firstなフレームワークたちとは違い、HTML-firstを謳うユニークなアプローチをしてるのが一番の特徴。</p><p>中の人による一連のシリーズもあって、そこも読んでまとめてみた記事です。</p>\n\n    <blockquote>\n        <p><a href=\"https://dev.to/mhevery/series/13467\">Qwik Series&#39; Articles - DEV Community</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Qwikの特徴</h3>\n    \n<ul>\n<li>遅いモバイル環境だとしても、TTIを爆速にすることを目的としたフレームワーク\n<ul>\n<li>TTI: Time To Interactive</li>\n<li>ページが読み込まれて、UIが表示され、イベントハンドラがアタッチされ、操作可能になるまでの時間</li>\n</ul></li>\n<li>Resumableをテーマに作られている\n<ul>\n<li>詳細は後述</li>\n<li>現状のフレームワークたちはどれもResumableではなく、強いて言うならReplayable</li>\n</ul></li>\n<li>JSではなく、HTML(DOM)を中心とした設計になってる\n<ul>\n<li>内部状態の管理などに、JSのヒープではなくDOM属性の文字列を使う</li>\n<li>JSが不要というわけではない</li>\n</ul></li>\n</ul><p>という具合で、これまでのものとは一線を画する感じ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>現状のフレームワークとTTIの問題</h3>\n    <p>TTIまでに必要なステップは、ざっくり次のとおり。</p>\n\n<ul>\n<li>クライアントがページをリクエスト</li>\n<li>サーバーがそれを受けてSSR\n<ul>\n<li>CDNなどから返すでもいいけど、それだとCSRが必須になってしまう</li>\n<li>遅いモバイル環境でも最速を目指すなら、SSRしかない</li>\n</ul></li>\n<li>HTMLとJSのダウンロード\n<ul>\n<li>HTMLはたいていすぐ取得できるけど、問題はJS</li>\n</ul></li>\n<li>ダウンロードしたJSの実行\n<ul>\n<li>テンプレの構築やイベントハンドラのアタッチなど</li>\n<li>いわゆるハイドレーション</li>\n</ul></li>\n</ul><p>Nextなど現状のフレームワークを使う場合、この後半のステップが重くなりがちで、どうしてもTTIが遅くなる傾向にある、と。</p><p>ほとんど静的なページだったとしても、デカいランタイムが必要（Svelteみたいにそこが小さいのもあるけど）になるし、イベントハンドラをアタッチするためにVDOMを全走査したりしないといけない。</p><p>そうやってJSをロードしてすべてのUIにハンドラをアタッチしても、ユーザーがそれらを必ず使う保証はないという別の問題もある。もしそれらが使われなかったら？その部分のイベントハンドラ（およびその裏側のクロージャに連なる多数の依存コード）や、テンプレですらも無駄になる。</p><p>ただこれはそういうデザインになってるからであって、それが必ずしも悪いというわけではない。そのおかげで以降のランタイムのパフォーマンスは良くなるので、何事もトレードオフ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Qwikのデザイン</h3>\n    <p>TTIを速くするには、そういう初期ロードでのJSのダウンロードや実行をやめる、もしくは遅延させる必要がある。</p><p>Qwikでも初期ロードでJSを利用するけど、それは1KB足らずで実行も1ms以内に終わる。あとの全て（UIもイベントハンドラも何もかも）は、非同期で遅延ロードされる。</p><p>もちろん他のフレームワークでも、遅延ロードするように手書きすることはできる。けど、それは付け足しであって、コードは確実に煩雑になるはず。</p><p>Qwikの場合、遅延ロードするのがデフォルトなので、そのための特別なコードは必要ない。単にQwik-wayにコードを書けば、それだけで遅延ロードされる。そんなすべてを遅延ロードするデザインを可能にしてるのが、最初に言ってたResumableという概念。</p>\n\n<div class=\"section\">\n    <h4>Resumableなフレームワーク</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/RESUMABLE.md\">qwik/RESUMABLE.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>現状のフレームワークたちはResumableではなく、Replayableと言ってたけどそれは、</p>\n\n<ul>\n<li>フレームワークの内部状態が、JSのヒープで管理されてる\n<ul>\n<li>イベントハンドラがどこにアタッチされるか</li>\n<li>コンポーネントの構造</li>\n<li>状態のバインディング</li>\n</ul></li>\n<li>その解釈や評価がロード時に行われる\n<ul>\n<li>そのために、大量のJSが必要になるわけではある</li>\n</ul></li>\n<li>SSR時にやったはずのことを、\"リプレイ\"する必要がある</li>\n<li>途中でやめることも、一部だけをハイドレーションすることもできない\n<ul>\n<li>いわゆるパーシャルハイドレーションができない</li>\n</ul></li>\n</ul><p>という特徴があるから。</p><p>このデザインだと、どうしてもTTIに不利であり、アプリのサイズが大きくなればなるほど、もっと不利になる。</p><p>それに対してQwikでは、</p>\n\n<ul>\n<li>SSRでやったことを、クライアントで引き継げる\n<ul>\n<li>つまり\"レジューム\"できる</li>\n</ul></li>\n<li>そのためには、引き継ぎ情報をサーバーからクライアントに渡す必要がある</li>\n<li>それに使われるのが、DOMの属性(= Attributes)\n<ul>\n<li>ありとあらゆるものが、シリアライズされて属性値に書かれる</li>\n<li>イベントハンドラやコンポーネントの状態、再描画が必要というマーキングなども</li>\n</ul></li>\n<li>レジュームできるということは、途中でやめることも容易\n<ul>\n<li>スクロールしないと表示されないようなUIは、後回しにできる</li>\n<li>いわゆるパーシャルハイドレーションができる</li>\n</ul></li>\n</ul><p>という風になってる。</p><p>たとえば、これはいわゆる`Counter`コンポーネントをSSRした結果のコード。（手動でこれを書くわけではない）</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink><span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">div</span>\n<span class=\"synIdentifier\">  on:q-mount=</span><span class=\"synConstant\">&quot;./q-fbbfca2f#Counter_onMount&quot;</span>\n<span class=\"synIdentifier\">  on:q-render=</span><span class=\"synConstant\">&quot;./q-35fc9755#Counter_onRender&quot;</span>\n<span class=\"synIdentifier\">  count-step=</span><span class=\"synConstant\">&quot;5&quot;</span>\n<span class=\"synIdentifier\">  q:obj=</span><span class=\"synConstant\">&quot;#2 !:22l6t4ye9i5&quot;</span>\n<span class=\"synIdentifier\">&gt;</span>\n  <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n    <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\"> on:click=</span><span class=\"synConstant\">&quot;./q-3f6b5546#Counter_onRender_on_click&quot;</span><span class=\"synIdentifier\">&gt;</span>-5<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\">&gt;</span>\n    1\n    <span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\"> on:click=</span><span class=\"synConstant\">&quot;./q-4e593eee#Counter_onRender_on_click5&quot;</span><span class=\"synIdentifier\">&gt;</span>+5<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">button</span><span class=\"synIdentifier\">&gt;</span>\n  <span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">div</span><span class=\"synIdentifier\">&gt;</span>\n</pre><p>というように、内部状態がすべて属性で書かれてる。クリックのハンドラですら文字列。</p><p>属性で書かれてるがゆえに、特定の状態が更新されたときに再描画が必要なコンポーネントも、`querySelectorAll()`で一発で取ってきてマーキングできる。`requestAnimationFrame()`で間引きながら再描画していくときにも、Dirtyとマーキングがされてるものだけを逐次処理できる。変わってないかもしれない部分をわざわざレンダリングする必要もない。</p>\n\n</div>\n<div class=\"section\">\n    <h4>すべてを遅延ロードする</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/LAZY_LOADING.md\">qwik/LAZY_LOADING.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>さっきのコードにもあったけど、なんとイベントハンドラですら遅延ロードされる。実際にクリックされるまで、ハンドラで実行するコードをダウンロードすらしない！インクリメントのハンドラと、デクリメントのハンドラも別ファイルになる。クリックされたら、その当該のハンドラと、テンプレのためのコードがダウンロードされて実行される。</p><p>イベントハンドラは、もちろんそのイベントが実行されない限りは必要にならない。そして必要にならないかもしれないのに、実行コードとその依存を必ずダウンロードして、待ち受けるというコストを支払う必要がある。</p><p>これを回避するために、QwikではイベントハンドラすらDOM属性にシリアライズしてしまうことで、遅延ロードを可能にしてる、と。</p><p>ただ原初のクリックイベントを拾う必要はもちろんあって、それをやってるのが最初にロードする1KBに満たない`qwikloader.js`ってやつ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/src/bootloader-shared.ts\">https://github.com/BuilderIO/qwik/blob/main/src/bootloader-shared.ts</a></p>\n\n    </blockquote>\n<p>各イベントタイプごとに1つだけ、グローバルなハンドラをアタッチする。そして`ev.target.getAttribute()`で何をすべきか判断して、サーバーにリクエストする。サーバーとのやりとりには、QRLっいうプロトコルを使ってるけど、これはただの独自URL。</p><p>あとは、遅延ロードされたコンポーネントだとしても既存のグローバルな状態や親の状態などとやり取りできるように、`Entity`っていう仕組みがあったりする。</p><p>このあたりは、コードを書く我々としても考え方をQwik-wayにする必要があって、そこは少しとっつきにくいなーとは思った。最速のTTIを実現するために必要な代価ではあるけど。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/BuilderIO/qwik/blob/main/docs/MENTAL_MODEL.md#component--entities\">qwik/MENTAL_MODEL.md at main &middot; BuilderIO/qwik &middot; GitHub</a></p>\n\n    </blockquote>\n<p>ともあれ、デザインからしてすべてを遅延ロードするので、TTIは必然的に速くなるというわけ。遅いモバイル環境であっても、それがどれだけデカいアプリになったとしても、初期ロードが常に速いってのが、Qwikの特徴。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>コードを動かす、試す</h3>\n    <p>実際に動いてるものを見るなら、</p>\n\n<ul>\n<li>Qwikの中の人たちであるBuilder.ioのサイト\n<ul>\n<li><a href=\"https://www.builder.io/?render=qwik\">https://www.builder.io/?render=qwik</a></li>\n<li>パラメータに注目</li>\n</ul></li>\n<li>TODOのデモ\n<ul>\n<li><a href=\"https://stackblitz.com/edit/qwik-todo-demo\">https://stackblitz.com/edit/qwik-todo-demo</a></li>\n<li>ただしChrome系のブラウザでしか見れない</li>\n<li>そしてQwikのバージョンが古いので、コードは参考にならなそう</li>\n</ul></li>\n</ul><p>確かに、初期ロードは軽いしめっちゃ速い気がする・・！</p><p>さっきの`Counter`コンポーネントはこんな感じで書いてた。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> h <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@builder.io/qwik&quot;</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> qComponent<span class=\"synStatement\">,</span> qHook <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;@builder.io/qwik&quot;</span><span class=\"synStatement\">;</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synType\">const</span> Counter <span class=\"synStatement\">=</span> qComponent<span class=\"synStatement\">&lt;</span><span class=\"synIdentifier\">{</span> countStep: <span class=\"synType\">number</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">,</span> <span class=\"synIdentifier\">{</span> count: <span class=\"synType\">number</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">&gt;(</span><span class=\"synIdentifier\">{</span>\n  onMount: qHook<span class=\"synStatement\">(()</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span> count: <span class=\"synConstant\">1</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)),</span>\n  onRender: qHook<span class=\"synStatement\">((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synStatement\">(</span>\n    <span class=\"synStatement\">&lt;</span>div<span class=\"synStatement\">&gt;</span>\n      <span class=\"synStatement\">&lt;</span>button\n        on:click<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span>qHook<span class=\"synStatement\">&lt;typeof</span> Counter<span class=\"synStatement\">&gt;((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n          state.count <span class=\"synStatement\">-=</span> props.countStep<span class=\"synStatement\">;</span>\n        <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)</span><span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&gt;</span>\n        -<span class=\"synIdentifier\">{</span>props.countStep<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>/button<span class=\"synStatement\">&gt;</span>\n      <span class=\"synIdentifier\">{</span>state.count<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>button\n        on:click<span class=\"synStatement\">=</span><span class=\"synIdentifier\">{</span>qHook<span class=\"synStatement\">&lt;typeof</span> Counter<span class=\"synStatement\">&gt;((</span>props<span class=\"synStatement\">,</span> state<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synIdentifier\">{</span>\n          state.count <span class=\"synStatement\">+=</span> props.countStep<span class=\"synStatement\">;</span>\n        <span class=\"synIdentifier\">}</span><span class=\"synStatement\">)</span><span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&gt;</span>\n        +<span class=\"synIdentifier\">{</span>props.countStep<span class=\"synIdentifier\">}</span>\n      <span class=\"synStatement\">&lt;</span>/button<span class=\"synStatement\">&gt;</span>\n    <span class=\"synStatement\">&lt;</span>/div<span class=\"synStatement\">&gt;</span>\n  <span class=\"synStatement\">)),</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n</pre><p>という感じで、</p>\n\n<ul>\n<li>`class`ではなく、`qComponent()`にオブジェクトを渡してコンポーネントを作る\n<ul>\n<li>`onMount()`で、コンポーネントに閉じた状態を返す</li>\n<li>`onRender()`で、おなじみのJSXを使ってテンプレを書く</li>\n</ul></li>\n<li>`qHook()`でラップすると、コンポーネントのPropsやStateにアクセスできる</li>\n<li>CSSはクラスを振って書くしかなさそう\n<ul>\n<li>ただしオブジェクトを渡せば`true`のときに付加するみたいな仕組みはある</li>\n</ul></li>\n</ul><p>これはできる限り現状のフレームワークっぽい書き方でComponentにすべてを詰め込んでるけど、Qwikの真髄的には、ViewとStateとHandlerはそれぞれバラして書くべきらしい。そのほうが、本当に必要なものだけを遅延ロードできるから。</p>\n\n    <blockquote>\n        <p><a href=\"https://dev.to/builderio/your-bundler-is-doing-it-wrong-ic0\">Your bundler is doing it wrong - DEV Community</a></p>\n\n    </blockquote>\n<p>ただこのへんはコンパイラがいい感じにやってくれる？っぽい感もあって、まだよくわかってない。</p>\n\n    <blockquote>\n        <p><a href=\"https://qwik-playground.builder.io/\">Qwik compiler playground</a></p>\n\n    </blockquote>\n<p>Rollupのプラグインとして動いてるであろうOptimizerでもその具合を調整してる風だった。推論できないときのためのマーキングなんだろうか・・？</p><p>ローカルで試したい場合は、スターターのコマンドを使う。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npm init qwik</pre><p>ってやると、いくつかテンプレを選ぶだけでコードを書き始められる。</p><p>現時点のデプロイ先の選択肢には、Node.js用の`express`のバージョンと、Cloudflare Workersへデプロイできるバージョンの2つがあった。たしかにコレはWorkerでやれると良さそうって思ってたんよね。</p><p>スターターを使って、</p>\n\n<ul>\n<li>もっともベーシックな`Starter`プロジェクトを</li>\n<li>Node.jsでデプロイする</li>\n</ul><p>とした場合に、生成されたコードはこのような感じ。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>├── README.md\n├── package.json\n├── rollup.config.js\n├── server\n│   └── index.js\n├── src\n│   ├── index.server.tsx\n│   └── my-app.tsx\n└── tsconfig.json</pre><p>`src`配下がアプリのコードで、この状態でビルドすると、こうなる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>├── README.md\n├── package.json\n├── public\n│   └── build\n│       ├── index.server.js\n│       ├── my-app.js\n│       ├── q-1612aa57.js\n│       ├── q-5404689f.js\n│       ├── q-6c8e2d16.js\n│       └── q-8b22cd88.js\n├── rollup.config.js\n├── server\n│   ├── build\n│   │   ├── core-3865dc2e.js\n│   │   ├── h_my-app_myapp_onmount-4f2b0222.js\n│   │   ├── h_my-app_myapp_onrender-e999a192.js\n│   │   ├── h_my-app_myapp_onrender_on_keyup-69b97bcc.js\n│   │   ├── index.server.js\n│   │   ├── my-app.js\n│   │   └── q-symbols.json\n│   └── index.js\n├── src\n│   ├── index.server.tsx\n│   └── my-app.tsx\n└── tsconfig.json</pre><p>`server/build`配下にSSRのために必要なアプリのコードが出力されて、クライアントに返して使うための同様のものが、`public/build`配下にできるという感じ。とにかく細かいファイルが作られて、必要なときに必要なものだけが利用されるってのがよくわかるはず。</p><p>Cloudflare Workersにデプロイする方式を選んだ場合は、Workers Sitesを使ってホスティングするようになってた。</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>というわけで、TTIが速いのは納得のデザインって感じでかなり好印象だった。TTIをKPIに据えてるなら、選択肢として考えられるようにしていきたい感じ。</p><p>ただ、UIイベントが発生してからハンドラのコードをリクエストするので、UIとしてのレスポンスにはいくらか制限があるんでは？とも思った。キャッシュしたりWorker使ったり、ある程度はカバーできると思うけど。</p><p>まだ生まれて間もないし（というかドキュメントすらないし）、実用段階ではないにしても、これからも要チェックでいきたいところ。</p><p>JSの用法と用量を最適化しようとする昨今のトレンドは割といいなと思っていて、そういう意味ではAstroとかと出発点は同じなのかもなーと。SSRのQwikと、SSGのAstroみたいな。</p><p>ちなみにQwikの中の人、あのAngularの中の人でもあるそうな。ここでまたその名を聞くとはな・・どうりでそれらしいコードやらコメントやらがあるわけやって感じ。</p><p>ほかにもBuilder.io社のOSSは興味深いのが多くて、`partytown`とか`mitosis`とか、一度は話題になってたことがあるはず。</p>\n\n</div>"
}
