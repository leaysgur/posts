{
  "title": "アクセストークンをWebWorkerで扱う",
  "html": "<p>というアプローチを紹介してる記事があって、なるほど？と思ったのでまとめてみる。</p><p>元記事はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://thenewstack.io/leveraging-web-workers-to-safely-store-access-tokens\">Leveraging Web Workers to Safely Store Access Tokens &ndash; The New Stack</a></p>\n\n    </blockquote>\n<p>毎度のことながら、今にはじまったことではない。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>元記事いわく</h3>\n    <p>WebWorkerであれば、メインスレッドで実行されるであろうXSSや3rdのコードから触れないので安全！</p><p>設計としては、</p>\n\n<ul>\n<li>メイン: まず`Worker`をロード</li>\n<li>メイン: 初期化のメッセージを`postMessage()`\n<ul>\n<li>クレデンシャルがあるならそれを渡す</li>\n</ul></li>\n<li>ワーカー: アクセストークンの準備\n<ul>\n<li>受け取ったやつ or そこで`fetch()`して、オンメモリに保存</li>\n</ul></li>\n<li>（これで準備OK）</li>\n<li>メイン: APIにリクエストしてほしいと`postMessage()`</li>\n<li>ワーカー: APIに向けてアクセストークンつけて`fetch()`</li>\n<li>ワーカー: レスポンスをメインスレッドに`postMessage()`</li>\n<li>メイン: それを受け取って使う！</li>\n</ul><p>大事なのは、アクセスできるAPIのリストを、ワーカー内にホワイトリストとして定義しておくこと。<br />\nそうすることで、メインスレッドから悪意のあるコードによって、意図しないドメインに送信されることがない。</p><p>ただしWebWorker自体のライフサイクルはそのセッションと同じで、永続化ができるわけではない。<br />\nとはいえ、最近のAuthベンダーであれば、セキュアなセッションCookieを使ってユーザー入力なくアクセストークンを更新できるはずなので、UXに影響はないであろう。</p><p>とのこと。</p>\n\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>この記事を読み始めたときは、「LocalStorageを使わなくても、WebWorkerならセキュアにトークンを永続化できる・・？」って思ってたけど、まったく関係のない話だった。言われてみれば当然なんやけど、なぜか永続化の話だと思いこんでしまってた。</p><p>「大事なトークンを一瞬たりともメインスレッドに置きたくない！」というのを実現する方法としては、実装コスパとしては妥当なのかな〜と思った。（ワーカー内にスコープが狭まっただけではあるけど）</p><p>あとはトークンそれ自体のIOだけを隠蔽するのでは不十分で、結局それがリクエストに載っていくならば、`fetch()`なんかもXSSの対象になることを忘れるなということかね。</p><p>Auth0のSPA用のSDKでも、オンメモリのStorage + FetcherとしてWebWorkerを使うようになってた。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/auth0/auth0-spa-js/pull/409\">[SDK-1516] Use Web Workers for token endpoint call for in-memory storage by adamjmcgrath &middot; Pull Request #409 &middot; auth0/auth0-spa-js &middot; GitHub</a></p>\n\n    </blockquote>\n<p>あとWebWorker使えっていう話は、Auth0のドキュメントにも書かれてた。</p>\n\n    <blockquote>\n        <p><a href=\"https://auth0.com/docs/security/data-security/token-storage\">Token Storage</a></p>\n\n    </blockquote>\n<p>ちなみに先行実装とかないかなーと思って探したけど、見つけられたのはこれだけだった。</p>\n\n<ul>\n<li><a href=\"https://gitlab.com/jimdigriz/oauth2-worker\">https://gitlab.com/jimdigriz/oauth2-worker</a></li>\n</ul><p>まあやるからには自作するか・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>永続化は結局どうする</h3>\n    <p>元記事は大丈夫って言ってるけど、実際には3rdのCookieに対する風向きも微妙な昨今では、Cookieに頼る方法はぜんぜん大丈夫じゃないと思う。</p><p>となるとやはりリフレッシュトークン + ローテーションを必須にしつつ、LocalStorageに入れるしかないんやろうけど、なんかもっと画期的なソリューションは出てこないもんかね〜。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> auth0 = await createAuth0Client(<span class=\"synIdentifier\">{</span>\n    domain: <span class=\"synConstant\">'&lt;your Auth0 domain&gt;'</span>,\n    client_id: <span class=\"synConstant\">'&lt;your Auth0 client ID&gt;'</span>,\n    cacheLocation: <span class=\"synConstant\">'localstorage'</span>,\n    useRefreshTokens: <span class=\"synConstant\">true</span>,\n<span class=\"synIdentifier\">}</span>);\n    \n<span class=\"synComment\">// Logging-in will automatically request the offline_access scope</span>\n<span class=\"synComment\">// and store the resulting refresh token</span>\nauth0.loginWithRedirect();\n    \n<span class=\"synComment\">// Silently refreshing the access token will use the /token endpoint</span>\n<span class=\"synComment\">// with ‘refresh_token’ grant and the refresh token from the cache</span>\nawait auth0.getTokenSilently();\n</pre><p>`auth0-spa.js`だとこんな感じのコードになるらしい。</p>\n\n    <blockquote>\n        <p><a href=\"https://auth0.com/blog/secure-browser-storage-the-facts/\">Secure Browser Storage: The Facts</a></p>\n\n    </blockquote>\n<p>こっちの記事もブラウザのストレージまわりについてよくまとまってたのでおすすめ。</p>\n\n</div>"
}
