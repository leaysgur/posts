{
  "title": "Cloudflare WorkersのDurable Objectsでチャットを実装する",
  "html": "<p>っていうコードが公式のリポジトリにあって、なかなか読み応えのあるコードだったので記事に。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-chat-demo\">GitHub - cloudflare/workers-chat-demo</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>はじめに</h3>\n    <p>Cloudflare Workersは、</p>\n\n<ul>\n<li>CDNのエッジで動かせるWorker</li>\n<li>ServiveWorkerみたいなコードを書く</li>\n<li>Node.jsが動くわけではなく、プロトコルもHTTPしか話せない</li>\n</ul><p>ただ、HTTPが話せるならWebSocketが使えるのでは？って気付いてコード漁ってたら、ドンピシャなコードを見つけたという。</p><p>本旨としてはDurable Objectsのデモだけれども、他にもいろいろ気になる感じだったので、ちゃんと読んでみたらいろいろと発見があった。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Durable Objectsとは</h3>\n    <p>端的にいうと、Workerから参照できる共通の状態。</p><p>WorkerAからもWorkerBからも同じ参照にアクセスできるので、トランザクションなどを気にせずdurableな状態として扱えるというもの。</p>\n\n    <blockquote>\n        <p><a href=\"https://blog.cloudflare.com/introducing-workers-durable-objects/\">Workers Durable Objects Beta: A New Approach to Stateful Serverless</a></p>\n\n    </blockquote>\n<p>この公式BlogのQ&Aがなかなか含蓄のあるものだったので、それもメモっておく。</p>\n\n<div class=\"section\">\n    <h4>DOでWebSocketを配信できるの？</h4>\n    <p>できる。</p><p>DOをβ公開するにあたり、Workerそれ自体をWebSocketのエンドポイントとして使えるようにした。</p><p>DOのユースケースとして、もっとも便利だと思われるのがWebSocketを使ったアプリケーションのはず。<br />\nDOを識別するIDさえあれば、任意のWebSocketクライアントにメッセージングできるということ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Workers KVとの違いは？</h4>\n    <p>KVの永続化は、真にリアルタイムではない。</p><p>最終的にはすべてのロケーションに格納されるけど、その過程では特定のWorkerだけ古いデータがあったりする。<br />\nなので基本的に後勝ちで上書きされてしまうという前提がある。</p><p>そもそもKVをStorageとして見るなら、DOはまったく別物。<br />\n静的なコンテンツや設定、更新頻度の低いものを置いておく場所としては、引き続きKVは最適であり、オワコンではない。</p><p>ただ、パフォーマンス向上のために、内部的にKVの実装をDOにするかもしれないらしい。</p><p>DOも実行環境としてはシングルスレッドになるので、キャッシュできるものはKVに寄せるほうがいいし、あまりハードな計算をさせると、レスポンスが遅くなるはず。</p>\n\n</div>\n<div class=\"section\">\n    <h4>なんでCRDTじゃないの？</h4>\n    <p>（CRDTについてあまり知らない）</p><p>DOで想定したユースケースとしては、CRDTは大仰すぎるから。</p><p>もちろんDOの上に、独自のCRDTを実装することもできるので、お好きにどうぞ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>真にServerlessであるとは？</h4>\n    \n<ul>\n<li>サーバーレスのアーキテクチャは、状態を持たないことが主流だった\n<ul>\n<li>特定の関心ごとに、決められた処理を行う</li>\n<li>だからわかりやすく、これまで支持されてきた</li>\n</ul></li>\n<li>ただその反面、共通のデータや協調が必要になった場合は、別のサービスが必要になってしまう</li>\n<li>結局こういう層が必要になってしまうと、そもそものサーバーレスの目的を達せられない\n<ul>\n<li>スケールさせるためには？とか、リージョンは？とか考える必要があり、すごく煩雑になる</li>\n</ul></li>\n<li>この問題を解決するため、特定の状態を分離して配置し、どこからでも参照できるようにした、それがDO\n<ul>\n<li>状態の単位は、ユースケースに依存する</li>\n<li>ECならカートごと、チャットならルームなど</li>\n</ul></li>\n</ul><p>とまあ、なかなかに壮大なことが語られていた・・・！</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>DOのAPIドキュメント</h3>\n    \n    <blockquote>\n        <p><a href=\"https://developers.cloudflare.com/workers/runtime-apis/durable-objects\">Durable Objects &middot; Cloudflare Workers docs</a></p>\n\n    </blockquote>\n<p>使い方をざっと書き下す。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これを、wrangler.tomlで指定する</span>\n<span class=\"synComment\">// { binding = &quot;mydo&quot;, class_name = &quot;MyDO&quot; } みたいに</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">class</span> MyDO <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// 詳細は後述</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synComment\">// DOをリクエスト時に取得する</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synIdentifier\">{</span>\n  async fetch(req, env) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">const</span> id = <span class=\"synComment\">/* なんとかしてリクエストから手に入れる */</span>;\n    <span class=\"synStatement\">const</span> mydo = env.mydo.get(id);\n\n    <span class=\"synComment\">// ID生成もできる</span>\n    env.mydo.newUniqueId();\n    <span class=\"synComment\">// 任意の文字列からも生成できる</span>\n    env.mydo.idFromName(name);\n    env.mydo.idFromString(name);\n\n    <span class=\"synComment\">// DOに処理を投げる</span>\n    <span class=\"synStatement\">return</span> mydo.fetch();\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synComment\">// DOの詳細</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">class</span> MyDO <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// おそらくデプロイ時に自動で呼ばれるので、参照をキープしておく</span>\n  constructor(state, env) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.state = state;\n    <span class=\"synIdentifier\">this</span>.env = env;\n\n    <span class=\"synComment\">// this.xxx はご自由に初期化する</span>\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synComment\">// Worker or 別のDOから呼ばれる（インターネットではなく、内部的な通信で）</span>\n  async fetch(req) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.state.storage.get(); <span class=\"synComment\">// put(), list(), delete(), transaction()</span>\n\n    <span class=\"synComment\">// 通常のWorkerのと一緒</span>\n    <span class=\"synIdentifier\">this</span>.state.waitUntil(promise);\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synComment\">// インスタンスメソッドもご自由に</span>\n  async yyy() <span class=\"synIdentifier\">{}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>プリミティブではあるけど、割と直感的かなと思った。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h4>`.mjs`</h4>\n    <p>現状ドキュメントやらサンプルで一般的に書かれてるWorkerのコードは、ServiceWorkerのそれと一緒で、こんな書き口なはず。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// index.js</span>\naddEventListener(<span class=\"synConstant\">&quot;fetch&quot;</span>, (ev) =&gt; <span class=\"synIdentifier\">{</span> ev.request <span class=\"synIdentifier\">}</span>)\naddEventListener(<span class=\"synConstant\">&quot;scheduled&quot;</span>, () =&gt; <span class=\"synIdentifier\">{}</span>)\n</pre><p>でもDOのサンプルではそうではなく、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// index.mjs</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synIdentifier\">{</span>\n  async fetch(request) <span class=\"synIdentifier\">{}</span>\n  async scheduled(request) <span class=\"synIdentifier\">{}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">class</span> DO <span class=\"synIdentifier\">{}</span>\n</pre><p>ってなってる。</p><p>どうやらこれはこの先そうなるかもよっていうコードだとか。<br />\nそして、現状βであるDOを使うためには、このシンタックスが必須らしい。</p><p>今までグローバル変数だった値たちは、`async fetch(request, env) {}`の第2引数から参照するようになる。これはこっちのほうがいいな。</p><p>ちなみにこれは、Modules-syntax Workerと称してるらしい。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>いざコード</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-chat-demo\">GitHub - cloudflare/workers-chat-demo</a></p>\n\n    </blockquote>\n<p>ファイルとしては2つだけ。</p>\n\n<ul>\n<li>Workerとして動かすスクリプト\n<ul>\n<li>`chat.mjs`</li>\n</ul></li>\n<li>そのWorkerが返すHTMLをファイルに切り出したもの\n<ul>\n<li>`chat.html.bin`</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>UIとしては</h4>\n    <p>特に特筆すべき点はない。（って、コードコメントにも書いてあるけど）</p>\n\n<ul>\n<li>名前の入力+次へ</li>\n<li>ルーム名の入力+入室</li>\n<li>チャット開始</li>\n</ul><p>ってだけ。</p><p>WebSocketでチャットというところでは、</p>\n\n<ul>\n<li>直接`new WebSocket(\"wss://\")`してる</li>\n<li>JSON文字列をやりとりしてる</li>\n</ul><p>くらい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`.bin`</h4>\n    <p>このUIのファイルの拡張子、なんでこんな風になってるの？って思ったら。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> HTML from <span class=\"synConstant\">&quot;chat.html.bin&quot;</span>;\n</pre><p>というように、`.bin`の拡張子にしておくと、それをバイナリとして認識させられて、`content-type`だけちゃんとすれば、そのまま`Response`で返せると。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(HTML, <span class=\"synIdentifier\">{</span>headers: <span class=\"synIdentifier\">{</span><span class=\"synConstant\">&quot;Content-Type&quot;</span>: <span class=\"synConstant\">&quot;text/html;charset=UTF-8&quot;</span><span class=\"synIdentifier\">}}</span>);\n</pre><p>ただこれも、</p>\n\n    <blockquote>\n        <p>However, the space available for assets served this way is very limited; larger sites should continue to use Workers KV to serve assets.</p>\n\n    </blockquote>\n<p>だそうです。</p>\n\n</div>\n<div class=\"section\">\n    <h4>WebSocketPair</h4>\n    <p>見慣れないやつがいると思ったら、CFWが独自で実装した秘密のクラスっぽかった。（そのうちドキュメントされるんかな？）</p>\n\n    <blockquote>\n        <p>To accept the WebSocket request, we create a WebSocketPair (which is like a socketpair, i.e. two WebSockets that talk to each other), we return one end of the pair in the response, and we operate on the other end. Note that this API is not part of the Fetch API standard; unfortunately, the Fetch API / Service Workers specs do not define any way to act as a WebSocket server today.</p>\n\n    </blockquote>\n<p>なるほど。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">[</span>clientWS, serverWS<span class=\"synIdentifier\">]</span> = <span class=\"synStatement\">new</span> WebSocketPair();\n\nserverWS.accept();\n<span class=\"synComment\">// このレスポンスで、WebSocketのUPGRADEが成される</span>\n<span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(<span class=\"synStatement\">null</span>, <span class=\"synIdentifier\">{</span> <span class=\"synStatement\">status</span>: 101, webSocket: clientWS <span class=\"synIdentifier\">}</span>);\n</pre><p>あとはいつものWebSocketってわけ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>serverWS.addEventListener(<span class=\"synConstant\">&quot;message&quot;</span>, fn);\nclientWS.send(JSON.stringify(<span class=\"synIdentifier\">{</span> hello: <span class=\"synConstant\">&quot;world&quot;</span> <span class=\"synIdentifier\">}</span>));\n</pre>\n</div>\n<div class=\"section\">\n    <h4>DOは`fetch()`でしか操作できない</h4>\n    <p>あくまで現時点では、らしいけども。</p><p>たとえばこのデモでは、レート制限が実装されてて、特定のIPからめちゃめちゃ書き込むことができないようになってる。</p><p>で、IPごとのレートを管理するためにもDOを使ってる。</p><p>ただDOを使うがゆえに、そのカウンターを操作するためにも`fetch()`する必要が出てくる。URLなんかないのに。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// みたく、validな適当なURLを指定するしかないらしい（どうせインターネットに出ないのでなんでもいい）</span>\nawait <span class=\"synIdentifier\">this</span>.limiter.fetch(<span class=\"synConstant\">&quot;https://dummy-url&quot;</span>, <span class=\"synIdentifier\">{</span>method: <span class=\"synConstant\">&quot;POST&quot;</span><span class=\"synIdentifier\">}</span>);\n</pre><p>あとDOへの`fetch()`も、失敗することがあるって書いてあった。<br />\nまあDOもどこかのネットワーク上に配置されてるので、不通になることもあるってことか。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>最初のQ&Aにあった通り、発想自体は良さそうではある・・。</p><p>が、実行時パフォーマンスが気になるのと、要するにグローバル変数なので、扱うのはかなり難易度が高そうだなと思った。</p>\n\n    <blockquote>\n        <p><a href=\"https://developers.cloudflare.com/workers/learning/using-durable-objects#limitations\">Using Durable Objects &middot; Cloudflare Workers docs</a></p>\n\n    </blockquote>\n<p>現状はまだβであり、制約も結構あるので、単に試す事自体もそれなりにハードやなというのが正直なところ。（自分もコード読んで満足してしまった）</p><br />\n<p>単純な増減カウンターの実装がこうなるというのを見て、このお気持ちを察して欲しい。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">class</span> Counter <span class=\"synIdentifier\">{</span>\n    constructor(state, env) <span class=\"synIdentifier\">{</span>\n        <span class=\"synIdentifier\">this</span>.state = state;\n    <span class=\"synIdentifier\">}</span>\n\n    async initialize() <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">try</span> <span class=\"synIdentifier\">{</span>\n            <span class=\"synIdentifier\">let</span> stored = await <span class=\"synIdentifier\">this</span>.state.storage.get(<span class=\"synConstant\">&quot;value&quot;</span>);\n            <span class=\"synIdentifier\">this</span>.value = stored || 0;\n        <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">catch</span> (err) <span class=\"synIdentifier\">{</span>\n            <span class=\"synComment\">// If anything throws during initialization then we</span>\n            <span class=\"synComment\">// need to be sure that a future request will retry by</span>\n            <span class=\"synComment\">// creating another `initializePromise` below.</span>\n            <span class=\"synIdentifier\">this</span>.initializePromise = <span class=\"synStatement\">undefined</span>;\n            <span class=\"synStatement\">throw</span> err;\n        <span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">}</span>\n\n    <span class=\"synComment\">// Handle HTTP requests from clients.</span>\n    async fetch(request) <span class=\"synIdentifier\">{</span>\n        <span class=\"synComment\">// Make sure we're fully initialized from storage.</span>\n        <span class=\"synStatement\">if</span> (!<span class=\"synIdentifier\">this</span>.initializePromise) <span class=\"synIdentifier\">{</span>\n            <span class=\"synIdentifier\">this</span>.initializePromise = <span class=\"synIdentifier\">this</span>.initialize();\n        <span class=\"synIdentifier\">}</span>\n        await <span class=\"synIdentifier\">this</span>.initializePromise;\n\n        <span class=\"synComment\">// Apply requested action.</span>\n        <span class=\"synIdentifier\">let</span> url = <span class=\"synStatement\">new</span> URL(request.url);\n        <span class=\"synIdentifier\">let</span> currentValue = <span class=\"synIdentifier\">this</span>.value;\n        <span class=\"synStatement\">switch</span> (url.pathname) <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">case</span> <span class=\"synConstant\">&quot;/increment&quot;</span>"
}
