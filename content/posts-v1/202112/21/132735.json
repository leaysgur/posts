{
  "title": "Cloudflare Pages Functionsを試す",
  "html": "<p>Cloudflare Pagesは、今まで単なる静的サイトのホスティングサービスだった。</p><p>それがこの度のパワーアップで動的なAPIも一緒にデプロイできるようになった。しかもそれはCloudflare Workersで実行されるので、デフォルトで速いんですよ！っていう触れ込み。</p>\n\n    <blockquote>\n        <p><a href=\"https://blog.cloudflare.com/cloudflare-pages-goes-full-stack/\">Cloudflare Pages Goes Full Stack</a></p>\n\n    </blockquote>\n<p>そんな折、社の案件で人柱になれる機会もあったので、その仕組みやら使用感やらをメモっておく。</p><p>Functions自体のドキュメントはこちらのページ。</p>\n\n    <blockquote>\n        <p><a href=\"https://developers.cloudflare.com/pages/platform/functions\">https://developers.cloudflare.com/pages/platform/functions</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Overview</h3>\n    <p>Pagesでサイトをデプロイする時、Functionsを一緒にデプロイさせるためには、以下のいずれかをやればよい。</p>\n\n<ul>\n<li>`functions`ディレクトリを作り、そこにコードを置く\n<ul>\n<li>特別なルールに則ったコード</li>\n<li>ファイルベースのルーティングにできる</li>\n</ul></li>\n<li>リポジトリルートに`_worker.js`というファイルを置く\n<ul>\n<li>今までWorker単独でやってたのと同じコード</li>\n</ul></li>\n</ul><p>SSR系のフレームワークだと後者のフォーマットで勝手に出力してくれたりするけど、それ以外の用途は基本的に前者になるはず。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ハンドラのコード</h3>\n    <p>パスはディレクトリとファイル名がそのまま使われて、そこで受けたいHTTPメソッド専用の関数を公開する。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// GET</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequestGet = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span>\n    request, <span class=\"synComment\">// same as existing Worker API</span>\n    env, <span class=\"synComment\">// same as existing Worker API</span>\n    params, <span class=\"synComment\">// if filename includes [id] or [[path]]</span>\n    waitUntil, <span class=\"synComment\">// same as ctx.waitUntil in existing Worker API</span>\n    next, <span class=\"synComment\">// used for middleware or to fetch assets</span>\n    data, <span class=\"synComment\">// arbitrary space for passing data between middlewares</span>\n  <span class=\"synIdentifier\">}</span> = context;\n\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Hello ;D&quot;</span>);\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// POST</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequestPost = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Created!&quot;</span>, <span class=\"synIdentifier\">{</span> <span class=\"synStatement\">status</span>: 201 <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// ぜんぶ手動で</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequest = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  context.request.method;\n<span class=\"synIdentifier\">}</span>;\n</pre><p>`onRequest(Xxx)`からなる関数があれば、それがルーティングとして登録され、それ以外は単なるモジュールとして使える。</p><p>なのでファイルベースルーティングではありつつ、ルートを定義しないただのファイルを置いても良いし、そこからただの関数をエクスポートしてもいい。わざわざ`_`からはじまるディレクトリ・ファイルにする必要もない。これはなかなかスマートやなって思った。</p><p>ただドキュメントに明示されてるわけではないので、そのうち変わるかもしれない・・？</p><p>基本的にコードとしてはこれだけ知ってれば、それだけでAPIが生える。</p>\n\n<div class=\"section\">\n    <h4>ミドルウェア</h4>\n    <p>APIといえばやっぱミドルウェアですよね〜ってことで、ちゃんと対応してる。</p><p>これも使い方は2通りあって、</p>\n\n<ul>\n<li>特定のディレクトリに、`_middleware.js`を置く\n<ul>\n<li>それ以降の層で自動的に使われるようになる</li>\n</ul></li>\n<li>各ハンドラの`onRequestXxx`を、配列にする\n<ul>\n<li>実行したいミドルウェアとハンドラ本体を順番に書く</li>\n</ul></li>\n</ul><p>という具合に、割と細かく挙動が調整できる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>ローカルで開発する</h3>\n    <p>まだステータスとしてはベータな`wrangler2`を使う必要がある。現行のv1は`@cloudflare/wrangler`なので、npmのネームスペースが違うので注意。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npx wrangler@beta pages dev dist</pre><p>ってすると、`dist`ディレクトリにある静的なコンテンツをプレビューしつつ、`functions`にコードがあればそれが叩けるようになる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npx wrangler@beta pages dev -- npm run dev</pre><p>ってすると、静的なコンテンツをプレビューする部分は既存のツールでやらせつつ、APIのルートとまとめてプロキシするサーバーを立ててくれる。</p>\n\n<div class=\"section\">\n    <h4>コマンドの仕組み</h4>\n    <p>`pages dev`コマンドは、</p>\n\n<ul>\n<li>静的なコンテンツを返すサーバー\n<ul>\n<li>コマンドがあればそれで立てたやつ</li>\n<li>なかったら`npx serve`</li>\n</ul></li>\n<li>動的なAPIのためのサーバー\n<ul>\n<li>Miniflareを使ってる</li>\n</ul></li>\n</ul><p>この2つを、`http-proxy-middleware`を使ってプロキシしてまとめて返す`express`のサーバーを立てるコマンド。</p><p>まあそうするしかないよなって感じではあるけど、割と力ずく・・ｗ<br />\nってことが、中のコードを読んでてわかった。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/wrangler2/blob/main/packages/wrangler/src/pages.tsx\">https://github.com/cloudflare/wrangler2/blob/main/packages/wrangler/src/pages.tsx</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>@cloudflare/pages-functions-compiler</h4>\n    <p>これは、Functionsのルーティングの定義をパースしてビルドする`plinko`ってツールのパッケージ名。</p><p>ソースは公開されてないけど、ログやら`node_modules`のコードをがんばって読む限りは、</p>\n\n<ul>\n<li>`functions`配下のコードをすべてASTにパースする</li>\n<li>`onRequest`からはじまる関数を取得</li>\n<li>ディレクトリ構成とあわせてルーティングのツリーにする</li>\n<li>その定義をインポートしたWorkerのコードを生成して、`esbuild`でビルドする</li>\n</ul><p>ということをやってる。なので、適当にファイルを置いたとしても、いい感じにファイルベースのルーティングを実現してくれる。</p><p>このツールが`functions`配下に変更があったときに毎回リビルドして、それをMiniflareのサーバーが実行するという形になってる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>環境変数</h3>\n    <p>Workersと違って、CLIから登録できない。<br />\nなのでダッシュボードから平文で登録するしかなく、ここはちょっと惜しい感じ。</p><p>現状の`wrangler@beta pages`コマンドは、さっきの`dev`しかサブコマンドが存在しないし。</p><p>ローカルでの開発時は、`-b KEY=VALUE`でコマンド引数で渡せるものの、`.env`などがサポートされてるわけでもない。（Miniflareは`.env`を読めるはずなので、あえてやってないのはおそらくデザイン的な問題っぽい）</p>\n\n</div>\n<div class=\"section\">\n    <h3>まとめと感想</h3>\n    <p>使えないことはないし、動作もするけど、なんだろうこの惜しい感じは・・。</p><p>特にCLIの`wrangler2`は絶賛ベータって感じで、大々的に告知されてる割に中身はぜんぜんWIPだったりするし。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/wrangler2/issues/12\">Roadmap to v2 &middot; Issue #12 &middot; cloudflare/wrangler2 &middot; GitHub</a></p>\n\n    </blockquote>\n<p>コード読んでても思ったけど割と荒削りなので、そこが不安を感じるポイントなのかもしれない・・。</p><p>そういう意味では、静的サイト+APIっていう本来の使い方よりも、SSR系フレームワークも動かせるプラットフォームとしての使い方のほうが、気持ちよく開発できると思う。いまのところは。</p><p>ちなみに、PagesでFunctionsをデプロイしたとしても、Workersのダッシュボードには何も現れない。<br />\nというわけで、Workers側で見れてたメトリクスとか実行結果とかそういうのも一切みれない。</p><p>というのが2021年末での感想。</p>\n\n</div>"
}
