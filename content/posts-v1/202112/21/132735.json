{
  "title": "Cloudflare Pages Functionsを試す",
  "html": "<p>Cloudflare Pagesは、今まで単なる静的サイトの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DB%A5%B9%A5%C6%A5%A3%A5%F3%A5%B0\">ホスティング</a>サービスだった。</p><p>それがこの度のパワーアップで動的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>も一緒にデプロイできるようになった。しかもそれはCloudflare Workersで実行されるので、デフォルトで速いんですよ！っていう触れ込み。</p>\n\n    <blockquote>\n        <p><a href=\"https://blog.cloudflare.com/cloudflare-pages-goes-full-stack/\">Cloudflare Pages Goes Full Stack</a></p>\n\n    </blockquote>\n<p>そんな折、社の案件で人柱になれる機会もあったので、その仕組みやら使用感やらをメモっておく。</p><p>Functions自体のドキュメントはこちらのページ。</p>\n\n    <blockquote>\n        <p><a href=\"https://developers.cloudflare.com/pages/platform/functions\">https://developers.cloudflare.com/pages/platform/functions</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>Overview</h3>\n    <p>Pagesでサイトをデプロイする時、Functionsを一緒にデプロイさせるためには、以下のいずれかをやればよい。</p>\n\n<ul>\n<li>`functions`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リを作り、そこにコードを置く\n<ul>\n<li>特別なルールに則ったコード</li>\n<li>ファイルベースのルーティングにできる</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>ルートに`_worker.js`というファイルを置く\n<ul>\n<li>今までWorker単独でやってたのと同じコード</li>\n</ul></li>\n</ul><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>だと後者のフォーマットで勝手に出力してくれたりするけど、それ以外の用途は基本的に前者になるはず。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ハンドラのコード</h3>\n    <p>パスは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リとファイル名がそのまま使われて、そこで受けたいHTTPメソッド専用の関数を公開する。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// GET</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequestGet = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span>\n    request, <span class=\"synComment\">// same as existing Worker API</span>\n    env, <span class=\"synComment\">// same as existing Worker API</span>\n    params, <span class=\"synComment\">// if filename includes [id] or [[path]]</span>\n    waitUntil, <span class=\"synComment\">// same as ctx.waitUntil in existing Worker API</span>\n    next, <span class=\"synComment\">// used for middleware or to fetch assets</span>\n    data, <span class=\"synComment\">// arbitrary space for passing data between middlewares</span>\n  <span class=\"synIdentifier\">}</span> = context;\n\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Hello ;D&quot;</span>);\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// POST</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequestPost = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Created!&quot;</span>, <span class=\"synIdentifier\">{</span> <span class=\"synStatement\">status</span>: 201 <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// ぜんぶ手動で</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> onRequest = async (context) =&gt; <span class=\"synIdentifier\">{</span>\n  context.request.method;\n<span class=\"synIdentifier\">}</span>;\n</pre><p>`onRequest(Xxx)`からなる関数があれば、それがルーティングとして登録され、それ以外は単なるモジュールとして使える。</p><p>なのでファイルベースルーティングではありつつ、ルートを定義しないただのファイルを置いても良いし、そこからただの関数をエクスポートしてもいい。わざわざ`_`からはじまる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リ・ファイルにする必要もない。これはなかなかスマートやなって思った。</p><p>ただドキュメントに明示されてるわけではないので、そのうち変わるかもしれない・・？</p><p>基本的にコードとしてはこれだけ知ってれば、それだけで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が生える。</p>\n\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DF%A5%C9%A5%EB%A5%A6%A5%A7%A5%A2\">ミドルウェア</a></h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>といえばやっぱ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DF%A5%C9%A5%EB%A5%A6%A5%A7%A5%A2\">ミドルウェア</a>ですよね〜ってことで、ちゃんと対応してる。</p><p>これも使い方は2通りあって、</p>\n\n<ul>\n<li>特定の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リに、`_middleware.js`を置く\n<ul>\n<li>それ以降の層で自動的に使われるようになる</li>\n</ul></li>\n<li>各ハンドラの`onRequestXxx`を、配列にする\n<ul>\n<li>実行したい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DF%A5%C9%A5%EB%A5%A6%A5%A7%A5%A2\">ミドルウェア</a>とハンドラ本体を順番に書く</li>\n</ul></li>\n</ul><p>という具合に、割と細かく挙動が調整できる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>ローカルで開発する</h3>\n    <p>まだステータスとしてはベータな`wrangler2`を使う必要がある。現行のv1は`@cloudflare/<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/wrangler\">wrangler</a>`なので、npmのネームスペースが違うので注意。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npx wrangler@beta pages dev dist</pre><p>ってすると、`dist`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リにある静的なコンテンツをプレビューしつつ、`functions`にコードがあればそれが叩けるようになる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npx wrangler@beta pages dev -- npm run dev</pre><p>ってすると、静的なコンテンツをプレビューする部分は既存のツールでやらせつつ、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>のルートとまとめてプロキシするサーバーを立ててくれる。</p>\n\n<div class=\"section\">\n    <h4>コマンドの仕組み</h4>\n    <p>`pages dev`コマンドは、</p>\n\n<ul>\n<li>静的なコンテンツを返すサーバー\n<ul>\n<li>コマンドがあればそれで立てたやつ</li>\n<li>なかったら`npx serve`</li>\n</ul></li>\n<li>動的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>のためのサーバー\n<ul>\n<li>Miniflareを使ってる</li>\n</ul></li>\n</ul><p>この2つを、`http-proxy-middleware`を使ってプロキシしてまとめて返す`express`のサーバーを立てるコマンド。</p><p>まあそうするしかないよなって感じではあるけど、割と力ずく・・ｗ<br />\nってことが、中のコードを読んでてわかった。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/wrangler2/blob/main/packages/wrangler/src/pages.tsx\">https://github.com/cloudflare/wrangler2/blob/main/packages/wrangler/src/pages.tsx</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>@cloudflare/pages-functions-compiler</h4>\n    <p>これは、Functionsのルーティングの定義をパースしてビルドする`plinko`ってツールのパッケージ名。</p><p>ソースは公開されてないけど、ログやら`node_modules`のコードをがんばって読む限りは、</p>\n\n<ul>\n<li>`functions`配下のコードをすべてASTにパースする</li>\n<li>`onRequest`からはじまる関数を取得</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リ構成とあわせてルーティングのツリーにする</li>\n<li>その定義をインポートしたWorkerのコードを生成して、`esbuild`でビルドする</li>\n</ul><p>ということをやってる。なので、適当にファイルを置いたとしても、いい感じにファイルベースのルーティングを実現してくれる。</p><p>このツールが`functions`配下に変更があったときに毎回リビルドして、それをMiniflareのサーバーが実行するという形になってる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a></h3>\n    <p>Workersと違って、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>から登録できない。<br />\nなので<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%C3%A5%B7%A5%E5\">ダッシュ</a>ボードから平文で登録するしかなく、こ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%B3%A4%CF%A4%C1\">こはち</a>ょっと惜しい感じ。</p><p>現状の`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/wrangler\">wrangler</a>@beta pages`コマンドは、さっきの`dev`しかサブコマンドが存在しないし。</p><p>ローカルでの開発時は、`-b KEY=<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/VALUE\">VALUE</a>`でコマンド引数で渡せるものの、`.env`などがサポートされてるわけでもない。（Miniflareは`.env`を読めるはずなので、あえてやってないのはおそらくデザイン的な問題っぽい）</p>\n\n</div>\n<div class=\"section\">\n    <h3>まとめと感想</h3>\n    <p>使えないことはないし、動作もするけど、なんだろうこの惜しい感じは・・。</p><p>特に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CLI\">CLI</a>の`wrangler2`は絶賛ベータって感じで、大々的に告知されてる割に中身はぜんぜんWIPだったりするし。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/wrangler2/issues/12\">Roadmap to v2 &middot; Issue #12 &middot; cloudflare/wrangler2 &middot; GitHub</a></p>\n\n    </blockquote>\n<p>コード読んでても思ったけど割と荒削りなので、そこが不安を感じるポイントなのかもしれない・・。</p><p>そういう意味では、静的サイト+<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>っていう本来の使い方よりも、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>系<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>も動かせるプラットフォームとしての使い方のほうが、気持ちよく開発できると思う。いまのところは。</p><p>ちなみに、PagesでFunctionsをデプロイしたとしても、Workersの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C0%A5%C3%A5%B7%A5%E5\">ダッシュ</a>ボードには何も現れない。<br />\nというわけで、Workers側で見れてたメトリクスとか実行結果とかそういうのも一切みれない。</p><p>というのが2021年末での感想。</p>\n\n</div>"
}
