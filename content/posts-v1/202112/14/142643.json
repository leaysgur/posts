{
  "title": "miniflare@next のコードを読む",
  "html": "<p>現時点ではまだリリースされてなくてベータの状態。</p><p>現行のv1について読んでみたのはこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2021/07/26/105807\">miniflare &#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; - console.lealog();</a></p>\n\n    </blockquote>\n<p>ちなみに、Cloudflare系スタックの開発に使うCLIの`warngler`が、なんとv2になると同時にMiniflareを内蔵したCLIになった。そしてその`wrangler`もv2はまだリリースされてない。つまりそういうことやな・・！<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>Overview</h3>\n    <p>v2になったとはいえ、正統進化といった感じなので、機能に大きな差異があるわけではない。</p><p>読み始めたときの最新のコミットハッシュは`97e5fa1570d8a2d5032130590cd661c32244a1b1`で、公開バージョンでいうと`2.0.0.-rc.3`だった。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/tree/v2\">https://github.com/cloudflare/miniflare/tree/v2</a></p>\n\n    </blockquote>\n<p>コードベースがモノレポになって、より洗練され、より新しいNode.jsのWeb標準系のコードを使うようになったって感じ。</p><p>新機能もちょいちょい増えてて、JestのEnvironmentとしても使えるようになったりもしてる。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>npm i -D jest jest-environment-miniflare@next</pre><p>というわけで、コードをざっくり読み直す。</p><p>パッケージの全容はこちら。イメージしやすいよう分類別に並べ替えしておいた。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink># 表向きのAPI\n├── miniflare\n├── cli-parser\n├── http-server\n├── scheduler\n\n# そのコア\n├── core\n├── watcher\n├── storage-file\n├── storage-memory\n├── storage-redis\n├── runner-vm\n\n# Workerのランタイム\n├── cache\n├── durable-objects\n├── kv\n├── sites\n├── html-rewriter\n├── web-sockets\n\n# その他\n├── shared\n├── shared-test\n└── jest-environment-miniflare</pre><p>というわけで、ざっくり上から眺めていく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>エントリーポイント</h3>\n    <p>`packages/miniflare`がすべてのエントリーであり、npmに公開されてるやつ。</p><p>CLIとしてキックする場合は、</p>\n\n<ul>\n<li>miniflare/bootstrap\n<ul>\n<li>miniflare/src/cli\n<ul>\n<li>miniflare/src/index</li>\n</ul></li>\n</ul></li>\n</ul><p>モジュールとして利用する場合は、</p>\n\n<ul>\n<li>miniflare/src/index</li>\n</ul><p>からのスタートになる。</p>\n\n<div class=\"section\">\n    <h4>miniflare: cli</h4>\n    \n<ul>\n<li>コマンドライン引数と初期値をさばく</li>\n<li>それで各プラグインを初期化し、Miniflareのインスタンスを作る</li>\n<li>Devサーバーを立てて、リクエストを待ち受け</li>\n</ul><p>引数をさばくところは、`packages/cli-parser`に分離されてる。</p><p>気になった引数は、`--mount`で、これは複数のWorkerを同時に立てて開発するためのもの。複数のWorkerから単一のKVを参照したりするために、あれこれするの大変そう。</p>\n\n</div>\n<div class=\"section\">\n    <h4>miniflare: api</h4>\n    \n<ul>\n<li>`class Miniflare extends MiniflareCore {}`\n<ul>\n<li>プラグインと、コードを実行する`VMScriptRunner`でコアを初期化\n<ul>\n<li>`packages/runner-vm`</li>\n</ul></li>\n</ul></li>\n<li>`startServer()`と`startScheduler()`が、CLIでDevサーバーを立てるもの\n<ul>\n<li>コードは`packages/http-server`と`packages/scheduler`にある</li>\n</ul></li>\n<li>APIとして使う場合は、コア側の`dispatchFetch()`と`dispatchScheduled()`を直接使うことになる</li>\n</ul>\n<div class=\"section\">\n    <h5>http-server: index</h5>\n    \n<ul>\n<li>リクエストを受けて、コアの`dispatchFetch()`を呼ぶまでのコード</li>\n<li>HTTP(s)のサーバーだけでなく、WebSocketにも対応するのでWSのサーバーも立ててる</li>\n<li>Workerが`text/html`を返すときのために、LiveReload用のコードもある\n<ul>\n<li>それもWebSocketでやってる</li>\n</ul></li>\n<li>Nodeで受けたリクエストを、Workerの`Request`に変換してる\n<ul>\n<li>CFWなので、`cf`プロパティなども付け足す</li>\n</ul></li>\n<li>レスポンスを返すとき、gzipなどの圧縮もオンザフライでやってる</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>scheduler: index</h5>\n    \n<ul>\n<li>実際にCron自体を実装してある\n<ul>\n<li><a href=\"https://github.com/P4sca1/cron-schedule\">https://github.com/P4sca1/cron-schedule</a></li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h4>XxxPlugin</h4>\n    <p>`http-server`に限らず、だいたいの実装は、</p>\n\n<ul>\n<li>`:pkg/src/index`: 実装それ自体</li>\n<li>`:pkg/src/plugin`: プラグインとしての設定値の保持、セットアップや事前の処理</li>\n</ul><p>という2本柱になってて、C/C++とかでいうヘッダファイルみたいやなって思った。</p>\n\n<ul>\n<li>`setup()`でグローバルオブジェクトとして使われる実装を返せる</li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>core: index</h3>\n    \n<ul>\n<li>`class MiniflareCore extends TypedEventTarget {}`\n<ul>\n<li>`EventEmitter`ではなく、`EventTarget`を使ってのイベント駆動</li>\n<li>そして型付にするための独自実装\n<ul>\n<li>コードは`packages/shared`にある</li>\n</ul></li>\n</ul></li>\n<li>`#init()`: Workerの初期化（前編）\n<ul>\n<li>各プラグインのインスタンスを作って、セットアップ処理を実行</li>\n<li>ここにユーザーのコードやら、バインディングやら、動的なものが入ってる</li>\n</ul></li>\n<li>`#reload()`: Workerの初期化（後編）\n<ul>\n<li>初回はスキップされる処理もあるが、実態はこっち</li>\n<li>`#init()`で用意したものを使って、コードを実行するグローバルスコープの用意など</li>\n<li>そして`scriptRunner.run(globalScope, script)`\n<ul>\n<li>`addEventListener()`のWorkerの場合、その内容で待ち受け</li>\n<li>ESMのWorkerの場合は、ここで`fetch`と`scheduled`が返るので、それを待ち受け</li>\n</ul></li>\n<li>コードの変更を検知するWatcherも再構成\n<ul>\n<li>`packages/watcher`</li>\n</ul></li>\n</ul></li>\n<li>`dispatchFetch()`\n<ul>\n<li>自身が抱えるグローバルスコープの実装の`kDispatchFetch()`を呼ぶ</li>\n<li>ユーザーが書いた`addEventListener()`は、既にこのグローバルスコープで保持されてる</li>\n<li>グローバルスコープも`EventTarget`を継承してる</li>\n</ul></li>\n<li>`dispatchScheduled()`\n<ul>\n<li>同上</li>\n</ul></li>\n<li>このあたりのイベントに関するコードは、`standards/event`にある\n<ul>\n<li>グローバルスコープである`ServiceWorkerGlobalScope`もここ</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>core: standards</h4>\n    \n<ul>\n<li>グローバルスコープに生えてる標準APIたちの実装\n<ul>\n<li>`ServiceWorkerGlobalScope`自体</li>\n<li>`addEventListener()`</li>\n<li>`fetch()` / `FetchEvent`</li>\n<li>`Request` / `Response`</li>\n<li>`DOMException`</li>\n<li>`atob()` / `btoa()`</li>\n<li>etc..</li>\n</ul></li>\n<li>これらがそのまま生えるわけではない\n<ul>\n<li>生えてるものもあるけど</li>\n<li>それを決めるのは実装を利用するプラグインの仕事</li>\n</ul></li>\n<li>`fetch()`は、`undici`を使うようになった\n<ul>\n<li>しかし実態としてはラップしたやつを使うことになる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>core: plugin</h4>\n    \n<ul>\n<li>`MiniflareCore`に渡るプラグインリストの一員たち</li>\n<li>CorePlugin\n<ul>\n<li>Miniflareの振る舞いを決める</li>\n<li>CLI引数のマッピングもココにある</li>\n<li>グローバルスコープで公開されるグローバルオブジェクトを決めてるのもココ</li>\n<li>`global.MINIFLARE: true`</li>\n</ul></li>\n<li>BuildPlugin\n<ul>\n<li>Workerスクリプトのビルドを担当</li>\n</ul></li>\n<li>BindingsPlugin\n<ul>\n<li>環境変数やシークレット、WASMモジュールの対応</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>watcher</h3>\n    \n<ul>\n<li>スクリプトのコード変更を検知する仕組み</li>\n<li>`chokidar`とか使わずに自作してる</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>storage-xxx</h3>\n    \n<ul>\n<li>KVSの実装で、データをどこに保存するかで3種類ある</li>\n<li>`MemoryStorage`\n<ul>\n<li>オンメモリで保存</li>\n</ul></li>\n<li>`RedisStorage`\n<ul>\n<li>`ioredis`とつなげてそこに保存</li>\n</ul></li>\n<li>`FileStorage`\n<ul>\n<li>ローカルファイルに保存</li>\n</ul></li>\n<li>KVなどの実装のバックエンドとしてだけでなく、内部的なプラグインの設定を保持する用途にも使われる</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>runner-vm</h3>\n    \n<ul>\n<li>Nodeの`vm`のラッパー</li>\n<li>実装したグローバルスコープで、ユーザーのWorkerスクリプトを実行する</li>\n<li>ESMのWorkerの場合に必要なモジュールリンカもココ</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>その他のグローバルオブジェクト</h3>\n    \n<ul>\n<li>Cache\n<ul>\n<li>`XxxStorage`を操作する層として実装してある</li>\n</ul></li>\n<li>KV\n<ul>\n<li>`XxxStorage`を操作する層として実装してある</li>\n<li>`ArrayBuffer`や`Stream`で取り出すこともできるところまで</li>\n<li>Nodeの`stream/consumers|web`とかまで使い倒してる</li>\n</ul></li>\n<li>DO\n<ul>\n<li>MultiRead / SingleWriteな性質を再現するMutexまで自作して再実装してある</li>\n</ul></li>\n<li>Sites\n<ul>\n<li>`__STATIC_CONTENT`というKVを用意して再現</li>\n</ul></li>\n<li>HTMLRewriter\n<ul>\n<li>`html-rewriter-wasm`を使ってる</li>\n</ul></li>\n<li>WebSocket\n<ul>\n<li>`WebScocket`や`WebSocketPair`を実装してる</li>\n<li>WSのアップグレードに対応した`fetch()`を上書き公開してる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>shared</h3>\n    \n<ul>\n<li>`compat.ts`\n<ul>\n<li>Compatibility Dates/Flagsの管理</li>\n<li>ここにあるすべてが対応済というわけではなさそう</li>\n<li><a href=\"https://developers.cloudflare.com/workers/platform/compatibility-dates\">https://developers.cloudflare.com/workers/platform/compatibility-dates</a></li>\n</ul></li>\n<li>`event.ts`\n<ul>\n<li>`EventTarget`を拡張した`TypedEventTarget`がココにある</li>\n<li>`ServiceWorkerGlobalScope`だけが継承してる`ThrowingEventTarget`もココ\n<ul>\n<li>リスナの実行が`try/catch`されてて、catch時に`stopImmediatePropagation()`する</li>\n</ul></li>\n</ul></li>\n<li>型まわり\n<ul>\n<li>`runner.ts` / `storage.ts` / `plugin.ts` / `wrangler.ts`</li>\n</ul></li>\n<li>`sync/mutex.ts`\n<ul>\n<li>いわゆる`Mutex`の実装</li>\n<li>コアがスクリプトの変更検知で実行するコールバックの同期実行を保証するのに使ってる</li>\n<li>DOの部分では、`ReadWriteMutex`というのが別で実装されてる</li>\n</ul></li>\n<li>`sync/gate.ts`\n<ul>\n<li>`InputGate` / `OutputGate`</li>\n<li>`AsyncLocalStorage`を使って非同期処理を直列にしてるっぽい・・？</li>\n<li>`WebSocket`は、ココにある`InputGatedEventTarget`を継承してる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>感想</h3>\n    <p>現行のv1系を読んでても思ったけど、ほんとこれ一人で書いてんのマジっすか・・って感じ。</p><p>もちろんリファクタする余地とかはあるけど、それでもこの設計とその構想を一人で練り上げてコードに落とし込むって、簡単にできることじゃない・・ほんとすごいわこの人・・。</p><p>一通りのコードを読んでみたものの、バグ対応とかOSS的なことができるかと聞かれると、それはまた別の話って感じ。</p><p>個人プロジェクトからCloudflareのプロジェクトになったけど、そのへんがこれからどうなっていくのか次第かなーと思ってる。（少なくとも以前よりIssueの反応は遅くなってるので、インターン忙しいんかなー、`wrangler2`のほうに駆り出されてるんかなーとか邪推してる）</p>\n\n</div>"
}
