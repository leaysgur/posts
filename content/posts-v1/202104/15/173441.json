{
  "title": "SvelteKitの特徴をざっくり理解する",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/kit\">GitHub - sveltejs/kit: A monorepo for SvelteKit and friends</a></p>\n\n    </blockquote>\n<p>SvelteKitは、Svelteでハイパフォーマンスなアプリを作ることができるフレームワーク。</p><p>`v1.0`を目指しているところで、いま時点での進捗は37%というところらしい。</p><p>つまり、世界的に知見もたまってないし、めちゃめちゃ頻繁にアップデートされるし、この記事で書いた内容もすぐに陳腐化する可能性があるということ・・・。</p><p>という感じのものをここ数日ずっと触ってて、それでもまあ色々わかったこともあるので、その整理を兼ねてメモっておこうかと。</p><p>ドキュメントはこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://kit.svelte.dev/docs\">Docs &bull; SvelteKit</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>`/routes`</h3>\n    \n<ul>\n<li>Nextとかと一緒で、ファイルベースのルーティング</li>\n<li>`.svelte`を置くと、それがクライアントで表示できるページになる</li>\n<li>`.(js|ts)`を置くと、それはサーバーで動くエンドポイントになる\n<ul>\n<li>クライアントにDLされないコード</li>\n<li>なので、DBアクセスもできるし環境変数とかシークレットキーとか使える</li>\n<li>Nodeのサーバーを手軽に書けるというだけ</li>\n</ul></li>\n<li>`_`からはじまるファイルは、ルーティングに含まれない\n<ul>\n<li>ディレクトリ名にも適用される</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>共通レイアウト・エラー</h4>\n    \n<ul>\n<li>ディレクトリをつくって、`$layout.svelte`を置くと、そのディレクトリで共通レイアウトとして使われる\n<ul>\n<li>中身はただの`slot`を使ったコンポーネント</li>\n<li>これはネストして使える</li>\n</ul></li>\n<li>`$error.svelte`も同様に、エラー表示としてディレクトリごとに置ける</li>\n</ul><p>Nextのそれと基本的には同じイメージで使えるけど、`_`とか共通テンプレが持てるとか、利用ハードルが下がってる感じ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>`load()`</h3>\n    <p>ページを構成する`.svelte`に定義できる関数で、そのコンポーネントが初期化される前に呼ばれる。</p><p>つまり、</p>\n\n<ul>\n<li>初回アクセス時にSSRが走る場合ならサーバーで</li>\n<li>その後の回遊時には、クライアントで</li>\n<li>後のコードをブロッキングしながら</li>\n</ul><p>そのページの起点となる処理が書ける。<br />\n（Nextのありし日の`getInitialProps()`相当・・？）</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink><span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\"> context=</span><span class=\"synConstant\">&quot;module&quot;</span><span class=\"synIdentifier\">&gt;</span>\n<span class=\"synSpecial\">  </span><span class=\"synStatement\">export</span><span class=\"synSpecial\"> </span><span class=\"synStatement\">const</span><span class=\"synSpecial\"> load = async </span>(<span class=\"synIdentifier\">{</span><span class=\"synSpecial\"> page, fetch, session, context </span><span class=\"synIdentifier\">}</span>)<span class=\"synSpecial\"> =&gt; </span><span class=\"synIdentifier\">{</span>\n<span class=\"synSpecial\">    page; </span><span class=\"synComment\">// その時のパスやクエリパラメータなど</span>\n<span class=\"synSpecial\">    fetch; </span><span class=\"synComment\">// クライアントでもサーバーでも使えるfetch（つまりnode-fetchいらず）</span>\n<span class=\"synSpecial\">    session; </span><span class=\"synComment\">// いわゆるセッション情報を入れておける便利スペース</span>\n<span class=\"synSpecial\">    context; </span><span class=\"synComment\">// 上層から下層のコンポーネントに引き渡すことのできる状態</span>\n<span class=\"synSpecial\">  </span><span class=\"synIdentifier\">}</span><span class=\"synSpecial\">;</span>\n<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\">&gt;</span>\n</pre><p>（`context=module`は、頻繁に登場するSvelte特有のシンタックスで、FWメタな処理をするところって感じ）</p><p>これを具体的に何に使うのかというと、</p>\n\n<ul>\n<li>クライアントで`onMount`で`fetch`してたような、初期データの取得処理\n<ul>\n<li>`return { props: data }`する</li>\n<li>ただ、初回アクセスではその待ち時間はブランクになってしまう</li>\n<li>そしてローディング表示も出せない</li>\n</ul></li>\n<li>セッションの状態によってリダイレクトする\n<ul>\n<li>`return { refirect: href, status: 300 }`する</li>\n</ul></li>\n<li>エラーにする\n<ul>\n<li>`return { error: err, status: 400 }`する</li>\n</ul></li>\n</ul><p>HTTPなら直接どこぞのAPIを呼びに行ってもいいし、自分で定義したエンドポイントを叩いてもよい。</p><p>この関数に処理を寄せることで、</p>\n\n<ul>\n<li>初回表示のSSR時にサーバーで実行するコードと</li>\n<li>その後の回遊でクライアントが実行するコードが</li>\n</ul><p>同じ場所に書けるよ！という機能らしい。</p><p>サーバーでもクライアントでも動くというわけで、基本的にはクライアントから叩けてしまって問題ないデータにアクセスする処理を書くところ。</p><p>サーバーでもクライアントでも動くIsomorphicなコードを書くところ。<br />\nどうしてもって場合は、従来どおり`onMount`にくるんだり、後述のフラグで処理を分けたりする。</p><p>ブロッキングするの、初回アクセスのSSR時はそもそも仕方ないとして、クライアントでの回遊時は後述の`navigating`でローディング表示も出せるので、まあ理解できるかなと。</p><p>ただSSRしない場合は、ブロッキングしてまでやるべき初期化処理なんか存在しないし、手動でローディング表示も出したいので、正直使いみちがない気がしてる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>特別なモジュール</h3>\n    \n<ul>\n<li>`$app/env`: 実行環境についての情報\n<ul>\n<li>ブラウザ or NOT / 事前レンダリング or NOTなど</li>\n</ul></li>\n<li>`$app/navigation`: プリフェッチとページ遷移</li>\n<li>`$app/paths`: パス情報（何に使うのか）</li>\n<li>`$app/stores`: コンテキストにある各種ストアへのショートカット\n<ul>\n<li>`navigating`: ページ遷移中を表す`store/readable`</li>\n<li>`page`: `load()`で見れたようなパスとかクエリ</li>\n</ul></li>\n<li>`$lib`: `src/lib`へのショートカット\n<ul>\n<li>なぜかこれだけ明示的に設定してくれてて謎</li>\n<li>実体はViteやTSのパスエイリアス指定なので、別に自分で増やせるし消せる・・</li>\n</ul></li>\n<li>`$service-worker`: SWで使える便利なやつら</li>\n</ul>\n<div class=\"section\">\n    <h4>src/hooks.js</h4>\n    <p>というファイルを置くと、それがSSR時に実行されるコードで使えるようになるらしい。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> getContext = async () =&gt; <span class=\"synIdentifier\">{}</span>;\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> getSession = async () =&gt; <span class=\"synIdentifier\">{}</span>;\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> handle = async () =&gt; <span class=\"synIdentifier\">{}</span>;\n</pre><p>（SSRする気がないのでよく見てない）</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Adapter</h3>\n    <p>SvelteKitでコードを書くと、</p>\n\n<ul>\n<li>`routes/*.svelte`によるページ</li>\n<li>`routes/*.(js|ts)`によるエンドポイント</li>\n</ul><p>この2つができる。</p><p>で、それらをどんな環境にデプロイしたいかを選べるのがこのAdapterという仕組み。</p>\n\n<ul>\n<li>`adapter-static`\n<ul>\n<li>全ページを事前レンダリングして静的に配置する用</li>\n<li>エンドポイントは使われない</li>\n</ul></li>\n<li>`adapter-node`\n<ul>\n<li>SSRするNodeのサーバーにする用</li>\n</ul></li>\n<li>`adapter-XXX`\n<ul>\n<li>XXXは、NetlifyだったりVercelだったりCloudflare Workersだったり</li>\n<li>Nodeのサーバー相当の処理をするところを、それぞれのFaaSにできる</li>\n</ul></li>\n</ul><p>1コードで、複数のデプロイ先を渡り歩けるよって感じ。</p><p>どこかの発表で、サーバーレスファースト！って言ってたのはこういう意味やったのね。</p><p>基本的にこのいずれかを指定してから、ビルドコマンドを叩く。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ssr / hydrate / router / prerender</h3>\n    <p>個人的に一番わかりにくいなーと思ったのがこれらの設定。</p><p>まずSvelteKitには、アプリ単位のグローバルな設定ファイルである`svelte.config.cjs`というのがある。</p>\n\n    <blockquote>\n        <p><a href=\"https://kit.svelte.dev/docs#configuration\">https://kit.svelte.dev/docs#configuration</a></p>\n\n    </blockquote>\n<p>さっきのアダプターの指定をしたり、Viteの設定をしたり、ディレクトリのエイリアスをしたり。<br />\nそれらに加えて、SSRやハイドレーションの挙動についても指定ができるようになってる。</p><p>で、これらの指定はアプリ単位でもできるし、各ページ`.svelte`の`context=module`の中でフラグを返すことでも指定できるようになってるのである。</p>\n<pre class=\"code lang-html\" data-lang=\"html\" data-unlink><span class=\"synIdentifier\">&lt;</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\"> context=</span><span class=\"synConstant\">&quot;module&quot;</span><span class=\"synIdentifier\">&gt;</span>\n<span class=\"synSpecial\">  </span><span class=\"synStatement\">export</span><span class=\"synSpecial\"> </span><span class=\"synStatement\">const</span><span class=\"synSpecial\"> ssr = </span><span class=\"synConstant\">false</span><span class=\"synSpecial\">;</span>\n<span class=\"synIdentifier\">&lt;/</span><span class=\"synStatement\">script</span><span class=\"synIdentifier\">&gt;</span>\n</pre><p>こうすると、このページではこの設定がアプリ設定よりも優先して使われる。</p><p>で、このあたりの挙動について指定できるオプションが4つある。</p>\n\n<ul>\n<li>ssr</li>\n<li>router</li>\n<li>hydrate</li>\n<li>prerender</li>\n</ul>\n    <blockquote>\n        <p><a href=\"https://kit.svelte.dev/docs#ssr-and-javascript\">https://kit.svelte.dev/docs#ssr-and-javascript</a></p>\n\n    </blockquote>\n<p>まず前提として、SvelteKitはSSRで動かす前提のデザインになってる。<br />\n（とはいっても全ページではなく、初回アクセスのページだけで、その後はクライアントでSPAライクに動くし、アダプターによってはその限りではないけど、基本的なスタンスという意味で）</p>\n\n<div class=\"section\">\n    <h4>ssr</h4>\n    <p>その名の通り、サーバーでレンダリングしないようにするオプション。</p><p>つまり、そのページはクライアントですべて描画するということになるので、いわゆるSPAにしたい場合に`false`を指定することになる。</p><p>どうやら`adapter-static`を使ったビルド時にもSSRされなくなるので、いわゆる事前レンダリングをしたい場合には、`false`にしてはいけないっぽい。（事前レンダリングのそれとSSRは違うのでは？って気がするけど・・）</p><p>（このへんがデザインなのかバグなのか想定外の用途なのかは、いまいちわかってない）</p><p>ちなみに、`ssr: false`にしていても、`svelte-kit dev`で開発してる間はSSRされるし、`svelte-kit build`して生成するときもSSRされるので、おもむろに`localStorage`とか書いていいというわけではない。</p>\n\n</div>\n<div class=\"section\">\n    <h4>hydrate</h4>\n    <p>初回アクセス時にSSRされた結果をクライアントで解釈するステップのためのオプション。</p><p>つまりこれが`false`だと、クライアント側でJSを実行しないので、`load()`はおろか通常の`script`の処理も何も実行されない。クリックなどのイベントハンドラも何も。</p><p>しかし初回アクセスではなく、回遊した結果のアクセスであれば、ちゃんと実行される。</p><p>（これがデザインなのかバグなのか想定外の用途なのかは、いまいちわかってない）</p>\n\n</div>\n<div class=\"section\">\n    <h4>router</h4>\n    <p>端的に、JSによるページ遷移を制御するオプション。</p><p>Nextだと`next/link`でつなげたところだけがつながるけど、SvelteKitはトップページから`a`要素をたどって自動的につなげてくれるので、それを制御するためのもの。</p><p>`false`を指定すると、ページ間のつながりを断ち切れて、リンクを踏むとHTMLがリクエストされるようになる。</p><p>あとは、特別なモジュールである`$app/navigation`の`goto()`なども使えなくなる。</p><p>さっきの`hydrate`とあわせて`false`にすると、クライアントに落ちてくるJSがなくなる！「0kb JS pages!」っていう触れ込み。</p>\n\n</div>\n<div class=\"section\">\n    <h4>prerender</h4>\n    <p>これだけデフォルトが`false`。<br />\nというのも、SvelteKitはSSRをデフォルトで想定してるから。</p><p>なので基本はSSRでいいけど、このページは事前レンダリングできる！という場合に、例外的にマーキングするためのもの。</p><p>ページ単位では`true`を指定するし、アプリ単位ではもう少し細かい指定ができるようになってる。</p><p>で、全ページ事前レンダリングしたいという場合に、`adapter-static`を使うというわけらしい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>まとめ</h4>\n    <p>とまあそれぞれ言いたいことはわかるが、それぞれの相関とか、おそらくこういうパターンで使うだろうとか、そういうガイドが欲しい。</p><p>まだこれから先、フィードバックやらで洗練されていくとは思うけど、現時点では手探りでやるしかないので非常につらいものがある。</p><p>特にいわゆるSPAを作るためには、フォールバックのページ指定だったりいろいろ仕組みが足りないらしく、まだまだどうなることやら・・って感じ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/kit/issues/754\">True SPA mode &middot; Issue #754 &middot; sveltejs/kit &middot; GitHub</a></p>\n\n    </blockquote>\n<p>手元のコードでは`adapter-static`を使ってるけど、</p>\n\n<ul>\n<li>`ssr: false`にしなかった場合、初回ロード時には事前レンダリングのSSR時にキャッシュされたコードがあるからか、ハイドレーションが動かない</li>\n<li>`hydrate: true`にしても、`ssr: false`にしてないと、初回アクセス時にルーターが動かない</li>\n<li>etc..</li>\n</ul><p>などなど絶賛ハマってて、どういう理由でそうなるのか、設定を誤解してるのかただのバグなのかも判断できないのが現状。（コードを読む限りはデザインな気もするけど、なんしか釈然としない・・）</p><p>とりあえずここまでの経験としては、</p>\n\n<ul>\n<li>部分的な事前レンダリング + SPAライクな挙動</li>\n<li>1HTMLファイルによる完全なSPA</li>\n</ul><p>少なくともこの2つは現状だと実現できないという認識。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>というわけで</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/kit/milestone/2\">1.0 Milestone &middot; GitHub</a></p>\n\n    </blockquote>\n<p>もう少し気長に待ちましょう・・。</p>\n\n</div>"
}
