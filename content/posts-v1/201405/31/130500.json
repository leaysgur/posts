{
  "title": "_.extend() は いわゆる\"継承\"ではない",
  "html": "<p>どうも、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%E6%A4%C8%A4%EA%C0%A4%C2%E5\">ゆとり世代</a>です。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>で継承ってキーワード聞いて、どんなコードを連想しますか？</p><p>なんと私が最初に連想したのは、UnderscoreとかBackboneとかのextendでした・・。</p>\n\n    <blockquote>\n        <p>※注：うまくまとまる気のしないメモ記事です。</p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>結論からいうと</h3>\n    <p>勘違いというか、そもそも完全に己が無知を晒すことになるんですけど、</p><p>いわゆる\"継承\"で実現したいであろう機能のひとつである、</p>\n\n<ul>\n<li>親クラスAがあって、それを継承して子クラスBを作った場合、</li>\n<li>子クラスBにも、親クラスAにも同名の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9\">メソッド</a>Fが定義されてても、</li>\n<li>子クラスBは親クラスAを継承してるので、親の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9\">メソッド</a>Fを実行することができる</li>\n</ul><p>恥ずかしながら、この\"子から親の同名の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9\">メソッド</a>を実行する\"って発想がまるっとなかったんですよね。<br />\nむしろそういうことできるから、\"継承\"って言うんや！っていう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>_.extend()</h3>\n    <p>コードを抜粋。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Extend a given object with all the properties in passed-in object(s).</span>\n_.extend = <span class=\"synIdentifier\">function</span>(obj) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (!_.isObject(obj)) <span class=\"synStatement\">return</span> obj;\n  _.each(slice.call(<span class=\"synIdentifier\">arguments</span>, 1), <span class=\"synIdentifier\">function</span>(source) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">for</span> (<span class=\"synIdentifier\">var</span> prop <span class=\"synStatement\">in</span> source) <span class=\"synIdentifier\">{</span>\n      obj<span class=\"synIdentifier\">[</span>prop<span class=\"synIdentifier\">]</span> = source<span class=\"synIdentifier\">[</span>prop<span class=\"synIdentifier\">]</span>;\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>);\n  <span class=\"synStatement\">return</span> obj;\n<span class=\"synIdentifier\">}</span>;\n</pre><p>コード見れば一目瞭然なんですけど、いわゆる\"継承\"ではないんですよね。<br />\nただ単に、プロパティを代入してるだけ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>_.extend(Model.prototype, Events, <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>;\n</pre><p>みたく、prototypeに突っ込めばいわゆる継承っぽいこともできるので、一概に間違ってはいないんやろうけど。<br />\nそれでもプロパティ名が被ったら、上書きされちゃうし、コピーではないし。</p><p>いわゆる継承って何と言われればまた定義が必要になりますが、<br />\nなんでこんな風に認識してたのかなーと思うと、単に知らんかったとしか言えず。<br />\n単純にプロトタイプをどんどん生やしていくのが\"継承\"ではないということで。</p><p>改めて精進せにゃなーという次第。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%E6%A4%C8%A4%EA%C0%A4%C2%E5\">ゆとり世代</a>な人は要注意？です。<br />\n<br />\n</p>\n\n</div>\n<div class=\"section\">\n    <h3>Backbone.**.extend()</h3>\n    <p>せっかくなので、Backboneのもみてみる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">function</span> (protoProps, staticProps) <span class=\"synIdentifier\">{</span>\n  <span class=\"synIdentifier\">var</span> <span class=\"synStatement\">parent</span> = <span class=\"synIdentifier\">this</span>;\n  <span class=\"synIdentifier\">var</span> child;\n\n  <span class=\"synComment\">// The constructor function for the new subclass is either defined by you</span>\n  <span class=\"synComment\">// (the &quot;constructor&quot; property in your `extend` definition), or defaulted</span>\n  <span class=\"synComment\">// by us to simply call the parent's constructor.</span>\n  <span class=\"synStatement\">if</span> (protoProps &amp;&amp; _.has(protoProps, <span class=\"synConstant\">'constructor'</span>)) <span class=\"synIdentifier\">{</span>\n    child = protoProps.constructor;\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n    child = <span class=\"synIdentifier\">function</span>()<span class=\"synIdentifier\">{</span> <span class=\"synStatement\">return</span> <span class=\"synStatement\">parent</span>.apply(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">arguments</span>); <span class=\"synIdentifier\">}</span>;\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synComment\">// Add static properties to the constructor function, if supplied.</span>\n  _.extend(child, <span class=\"synStatement\">parent</span>, staticProps);\n\n  <span class=\"synComment\">// Set the prototype chain to inherit from `parent`, without calling</span>\n  <span class=\"synComment\">// `parent`'s constructor function.</span>\n  <span class=\"synIdentifier\">var</span> Surrogate = <span class=\"synIdentifier\">function</span>()<span class=\"synIdentifier\">{</span> <span class=\"synIdentifier\">this</span>.constructor = child; <span class=\"synIdentifier\">}</span>;\n  Surrogate.prototype = <span class=\"synStatement\">parent</span>.prototype;\n  child.prototype = <span class=\"synStatement\">new</span> Surrogate;\n\n  <span class=\"synComment\">// Add prototype properties (instance properties) to the subclass,</span>\n  <span class=\"synComment\">// if supplied.</span>\n  <span class=\"synStatement\">if</span> (protoProps) _.extend(child.prototype, protoProps);\n\n  <span class=\"synComment\">// Set a convenience property in case the parent's prototype is needed</span>\n  <span class=\"synComment\">// later.</span>\n  child.__super__ = <span class=\"synStatement\">parent</span>.prototype;\n\n  <span class=\"synStatement\">return</span> child;\n<span class=\"synIdentifier\">}</span>\n</pre><p>というわけで、子で親クラスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E1%A5%BD%A5%C3%A5%C9\">メソッド</a>を使いたい場合は、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> Parent = Backbone.Model.extend(<span class=\"synIdentifier\">{</span>\n  c: <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span> console.log(<span class=\"synConstant\">'Parent'</span>); <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synIdentifier\">var</span> Child = Parent.extend(<span class=\"synIdentifier\">{</span>\n  c: <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'Child'</span>);\n    <span class=\"synIdentifier\">this</span>.constructor.__super__.c(); <span class=\"synComment\">// =&gt; &quot;Parent&quot;</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>ってすればできる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>そもそもなんで</h3>\n    <p>こんなことに今さら気付いたかというと、<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CoffeeScript\">CoffeeScript</a>で書かれたコードを、生<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>のプロジェクトで使いたくって、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>して参考にしようとしたときの話です。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CoffeeScript\">CoffeeScript</a>の継承イディオムって、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>(そして整形)するとこうなってるんですよね。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> A, B,\n    __hasProp = <span class=\"synIdentifier\">{}</span>.hasOwnProperty,\n    __extends = <span class=\"synIdentifier\">function</span>(child, <span class=\"synStatement\">parent</span>) <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">for</span> (<span class=\"synIdentifier\">var</span> key <span class=\"synStatement\">in</span> <span class=\"synStatement\">parent</span>) <span class=\"synIdentifier\">{</span>\n            <span class=\"synStatement\">if</span> (__hasProp.call(<span class=\"synStatement\">parent</span>, key))\n                child<span class=\"synIdentifier\">[</span>key<span class=\"synIdentifier\">]</span> = <span class=\"synStatement\">parent</span><span class=\"synIdentifier\">[</span>key<span class=\"synIdentifier\">]</span>;\n        <span class=\"synIdentifier\">}</span>\n        <span class=\"synIdentifier\">function</span> ctor() <span class=\"synIdentifier\">{</span>\n            <span class=\"synIdentifier\">this</span>.constructor = child;\n        <span class=\"synIdentifier\">}</span>\n        ctor.prototype = <span class=\"synStatement\">parent</span>.prototype;\n        child.prototype = <span class=\"synStatement\">new</span> ctor();\n        child.__super__ = <span class=\"synStatement\">parent</span>.prototype;\n        <span class=\"synStatement\">return</span> child;\n    <span class=\"synIdentifier\">}</span>;\n\nA = (<span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synIdentifier\">function</span> A() <span class=\"synIdentifier\">{}</span>\n\n  <span class=\"synStatement\">return</span> A;\n\n<span class=\"synIdentifier\">}</span>)();\n\nB = (<span class=\"synIdentifier\">function</span>(_super) <span class=\"synIdentifier\">{</span>\n  __extends(B, _super);\n\n  <span class=\"synIdentifier\">function</span> B() <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">return</span> B.__super__.constructor.apply(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">arguments</span>);\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synStatement\">return</span> B;\n\n<span class=\"synIdentifier\">}</span>)(A);\n</pre><p>prototypeちゃんと使えるようになってるし、これで十分なのでは？って思ってたけど、<br />\nそもそも親に同名の定義があったらどうやって呼ぶのとか、諸々考えるべきことがあるらしく。<br />\nそういうわけで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>は世間を騒がせるんですね・・。</p><p>__super__とかconstructorとか、そういうもんってわかってからはだいぶスッキリしてるので、<br />\nなんかひとつかしこくなった感すらあります。</p><p>うーむ、勉強させていただきます。<br />\n<a href=\"https://twitter.com/damele0n\" target=\"_blank\">@dameleon</a>++</p>\n\n    <blockquote>\n        <p>参考：<a href=\"http://leko.jp/archives/407\" target=\"_blank\" title=\"CoffeescriptとTypescriptから学ぶjsでのクラス・継承パターン | WEB EGG\">CoffeescriptとTypescriptから学ぶjsでのクラス・継承パターン | WEB EGG</a></p>\n\n    </blockquote>\n\n</div>"
}
