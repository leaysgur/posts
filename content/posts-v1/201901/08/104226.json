{
  "title": "“Unified Plan” Transition Guide (JavaScript) の日本語訳",
  "html": "\n    <blockquote>\n        <p><a href=\"https://docs.google.com/document/d/1-ZfikoUtoJa9k-GZG1daN0BU3IjIanQ_JSscHxQesvU/edit\">&ldquo;Unified Plan&rdquo; Transition Guide (JavaScript) - Google &#x30C9;&#x30AD;&#x30E5;&#x30E1;&#x30F3;&#x30C8;</a></p>\n\n    </blockquote>\n<p>なんかそのうち仕事で見返しそうな感じがあったので訳してみた。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>背景</h3>\n    <p>WebRTCの仕様はここ数年で大きく変化してきた。`addStream()`などのStream系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>から、`addTrack()`などのTrack系の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>への移行がその一つ。これによって、再<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%CD%A5%B4%A5%B7%A5%A8%A1%BC%A5%B7%A5%E7%A5%F3\">ネゴシエーション</a>なしに設定変更が可能になった。</p><p>ただWebRTC 1.0へ向けてはまだ大きな変更が残ってて、それが今から話すSDPのフォーマット変更。</p><p>仕様の上で「Unified Plan」と呼んでるSDPのフォーマットがある。これは今の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>が利用している「Plan B」というフォーマットとは別のもの。このフォーマットの移行は、たくさんのアプリケーションに破壊的な変更をもたらす可能性がある。</p><p>そのほか、この「Unified Plan」に沿って追加される新しい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>もある。（`Transceiver`関連）</p><p>この記事は、そんなフォーマット移行の助けとなるべく書かれている。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>は既に「Unified Plan」をサポートしていて、他のブラウザも追ってそれに追従するだろう。</p>\n\n<ul>\n<li>複数のaudio/videoトラックを扱っている</li>\n<li>ローカル・リモート問わず、トラックのIDが変わらないと仮定している</li>\n<li>SDPを手動で修正している</li>\n</ul><p>あなたのアプリケーションがこれらに当てはまる場合は、注意が必要。</p>\n\n</div>\n<div class=\"section\">\n    <h3>どちらのフォーマットを使うか</h3>\n    \n<div class=\"section\">\n    <h4>アプリケーションで`sdpSemantics`を指定する</h4>\n    <p>`RTCPeerConnection`のコンスト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%AF\">ラク</a>タに`sdpSemantics`オプションを指定することで、どちらのSDPフォーマットを使うか選ぶことができる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n<span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'plan-b'</span> <span class=\"synIdentifier\">}</span>);\n</pre><p>ただしこれは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>でのみ有効で、他のブラウザでは無視される。</p><p>実装が適切に両方のフォーマットに対応していないのであれば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>の仕様変更に備える意味でも、どちらかを指定しておくことを推奨する。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a>://flags`によるデフォルト設定</h4>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のM71から`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a>://flags`にて、「WebRTC: Use Unified Plan SDP Semantics by default」というフラグが指定できるようになる。</p><p>このフラグを有効にするか、`--enable-features=RTCUnified Plan ByDefault`つきで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>を起動することでも有効にできる。</p><p>これらの指定がない場合も、デフォルトで「Unified Plan」が使われる。</p><p>ちなみに、M71未満の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>の場合は、`--enable-blink-features=RTCUnified Plan ByDefault`というフラグを指定することでも有効にできる。</p><p>これは、`sdpSemantics`をコード内で指定してない場合に、その対応をしないとどうなるのかを調べたい場合に使える。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>フォーマットの判別</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のM69から`Transceiver`関連の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が追加されたが、これらは「Unified Plan」の時のみサポートされる。</p><p>「とりあえず`addTransceiver()`を呼んでみて、例外を投げないかどうか」をチェックするのが、「Unified Plan」かどうかをチェックする方法のひとつ。</p><p>M70だと、`getConfiguration()`を呼ぶことで正式に`sdpSemantics`の値を知ることができる。（`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/chrome\">chrome</a>://webrtc-internals`と同じように）</p><p>このあたりの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A1%BC%A5%C9%A5%B9%A5%CB%A5%DA%A5%C3%A5%C8\">コードスニペット</a>はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://codepen.io/anon/pen/ZqLwWV?editors=0010\">Feature Detection</a></p>\n\n    </blockquote>\n<p>他のやり方としては、SDPをパースして`m=`行を調べることでもできる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Unified PlanとPlan Bの違い</h3>\n    \n<div class=\"section\">\n    <h4>SDP上の違い</h4>\n    <p>「Plan B」では、audio/videoごとに、1つのSDPの`m=`セクションがあり、`mid`もそれぞれ割り当てられていた。<br />\nなので複数のトラックがオファーに含まれていた場合、複数の`a=ssrc`行がそれぞれの`m=`セクションに含まれることになる。</p><p>「Unified Plan」では、1つの`m=`セクションが1つのトラックの送（受）信に割り当てられる。<br />\nなので、複数のトラックが存在する場合はその分だけ`m=`セクションが作られる。</p><p>これがSDPのフォーマットに互換性がない原因で、「Unified Plan」のピアは「Plan B」のフォーマットのオファーが来た場合、「Failed to set remote answer sdp: Media section has more than one track specified with a=ssrc lines which is not supported with Unified Plan.」といって拒否する必要がある。</p><p>また「Plan B」側のピアは、「Unified Plan」のオファーに含まれる最初の`m=`セクションだけを解釈して受け入れてもよい。</p><p>以下は2つのaudioトラックを送る場合の「Plan B」と「Unified Plan」それぞれのSDPのサンプル。</p><p>説明に必要な部分のみ抜粋してあり、`mid`や`ssrc`は簡略化してある。</p>\n\n<div class=\"section\">\n    <h5>Plan B</h5>\n    <pre class=\"code\" data-lang=\"\" data-unlink>...\na=group:BUNDLE audio\na=msid-semantic: WMS stream-id-2 stream-id-1\nm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126\n...\na=mid:audio\n...\na=rtpmap:103 ISAC/16000\n...\na=ssrc:10 cname:cname\na=ssrc:10 msid:stream-id-1 track-id-1\na=ssrc:10 mslabel:stream-id-1\na=ssrc:10 label:track-id-1\na=ssrc:11 cname:cname\na=ssrc:11 msid:stream-id-2 track-id-2\na=ssrc:11 mslabel:stream-id-2\na=ssrc:11 label:track-id-2</pre><p>`a=mid:audio`が使われ、トラックは同じ`m=audio`セクションに含まれる。</p>\n\n</div>\n<div class=\"section\">\n    <h5>Unified Plan</h5>\n    <pre class=\"code\" data-lang=\"\" data-unlink>...\na=group:BUNDLE 0 1\na=msid-semantic: WMS\nm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126\n...\na=mid:0\n...\na=sendrecv\na=msid:- &lt;track-id-1&gt;\n...\na=rtpmap:103 ISAC/16000\n...\na=ssrc:10 cname:cname\na=ssrc:10 msid: track-id-1\na=ssrc:10 mslabel"
}
