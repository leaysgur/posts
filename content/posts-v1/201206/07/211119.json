{
  "title": "0からはじめるJSX Part.5-1",
  "html": "<p>5回目でございます。<br />\n今回はちょっと長くなるので2部構成で。<br />\nあと1、2回で<a href=\"http://jsx.github.com/tutorial.html\" target=\"_blank\" title=\"JSX Tutorial\">JSX Tutorial</a>は終わるので、そこで一区切りかな？</p><p>最近は、<a href=\"http://www.slideshare.net/gorof/introduction-to-jsx\" target=\"_blank\" title=\"Introduction to JSX\">Introduction to JSX</a>の20枚目にある通り、<a href=\"http://jsx.github.com/try/#\" target=\"_blank\" title=\"JSX - Statically-typed, object-oritented programming lauguage\">JSX - Try</a>のページで試しまくりです。<br />\nこのスライド<a href=\"http://www.slideshare.net/gorof/introduction-to-jsx\" target=\"_blank\" title=\"Introduction to JSX\">Introduction to JSX</a>にもお世話になりました。</p><p>そうは言いつつ、いつも通り<a href=\"http://jsx.github.com/tutorial.html\" target=\"_blank\" title=\"JSX Tutorial\">JSX Tutorial</a>を見ていきます。</p>\n\n<div class=\"seemore\">\n    \n<div class=\"section\">\n    <h3>クラスとインターフェース</h3>\n    <p>Javaに初めて出会った時のあのイヤな感じ再来。</p>\n\n    <blockquote>\n        <p>JSX is a class-based object-oriented language, and its class model is similar to Java.</p><p>a class may extend another class (single inheritance)<br />\na class may implement multiple interfaces<br />\nall classes share a single root class: the Object class</p>\n\n    </blockquote>\n<p>JSXはJavaに似たクラスベースのオブジェクト指向言語です。</p>\n\n<ul>\n<li>クラスは他のクラスを継承することができます。(でも多重継承はしない)</li>\n<li>複数のインターフェースを実装することができます。</li>\n<li>全てのクラスは、Objectクラスというクラスを有しています。</li>\n</ul><p>JavaScriptの肝はObjectっていうのと同じイメージかな？<br />\nこのインターフェースとか継承とかいう言葉が、初学者の壁なんよなぁ・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>とりあえずサンプルソース</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">interface</span> Flyable <span class=\"synIdentifier\">{</span>\n\t<span class=\"synStatement\">abstract</span> <span class=\"synIdentifier\">function</span> fly() : void;\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">abstract</span> <span class=\"synStatement\">class</span> Animal <span class=\"synIdentifier\">{</span>\n\t<span class=\"synIdentifier\">function</span> eat() : void <span class=\"synIdentifier\">{</span>\n\t\tlog <span class=\"synConstant\">&quot;An animal is eating!&quot;</span>;\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">class</span> Bat <span class=\"synStatement\">extends</span> Animal <span class=\"synStatement\">implements</span> Flyable <span class=\"synIdentifier\">{</span>\n\toverride <span class=\"synIdentifier\">function</span> fly() : void <span class=\"synIdentifier\">{</span>\n\t\tlog <span class=\"synConstant\">&quot;A bat is flying!&quot;</span>;\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">abstract</span> <span class=\"synStatement\">class</span> Insect <span class=\"synIdentifier\">{</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">class</span> Bee <span class=\"synStatement\">extends</span> Insect <span class=\"synStatement\">implements</span> Flyable <span class=\"synIdentifier\">{</span>\n\toverride <span class=\"synIdentifier\">function</span> fly() : void <span class=\"synIdentifier\">{</span>\n\t\tlog <span class=\"synConstant\">&quot;A bee is flying!&quot;</span>;\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">class</span> _Main <span class=\"synIdentifier\">{</span>\n\n\t<span class=\"synStatement\">static</span> <span class=\"synIdentifier\">function</span> main(args : <span class=\"synType\">string</span><span class=\"synIdentifier\">[]</span>) : void <span class=\"synIdentifier\">{</span>\n\t\t<span class=\"synComment\">// fo bar</span>\n\t\t<span class=\"synIdentifier\">var</span> bat = <span class=\"synStatement\">new</span> Bat();\n\t\t\n\t\t<span class=\"synIdentifier\">var</span> animal : Animal = bat; <span class=\"synComment\">// OK. A bat is an animal.</span>\n\t\tanimal.eat();\n\t\t\n\t\t<span class=\"synIdentifier\">var</span> flyable : Flyable = bat; <span class=\"synComment\">// OK. A bat can fly</span>\n\t\tflyable.fly();\n\t\t\n\t\t<span class=\"synComment\">// for Bee</span>\n\t\t<span class=\"synIdentifier\">var</span> bee = <span class=\"synStatement\">new</span> Bee();\n\t\t\n\t\tflyable = bee; <span class=\"synComment\">// A bee is also flyable</span>\n\t\tflyable.fly();\n\t<span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre>\n    <blockquote>\n        <p>In the example, the Bat class extends the Animal class, so it inherits the Animal#eat() member function, and it can be assigned to a variable typed to Animal. The class also implements the Flyable interface overriding the Flyable#fly() member function, so it can be assigned to a variable typed Flyable. There's also another flyable class, Bee. By using the Flyable interface, it is possible to deal with both classes as a flyable being, even if the organ of a bee is completely different from that of a bat.</p>\n\n    </blockquote>\n<p>BatクラスはAnimalクラスを継承しています。<br />\nそのため、eat関数が使えると同時に、Animal型として認識されます。<br />\n同時に、Flyableインターフェースを実装しているので、fly関数を使うことができ、Flyable型も持つことになります。</p><p>他のFlyableなものとして、Beeクラスを定義しています。<br />\nBatとは別起源で定義されているBee(BatはAnimalクラスから、BeeはInsectクラスから定義)ですが、同じくFlyableインターフェースを実装しているので、Batと同じくFlyableなものとして扱うことができます。</p>\n\n    <blockquote>\n        <p>When overriding a member function, the use the override keyword is mandatory. Otherwise the compiler will report an error. In other words, you are saved from unexpected interface changes in the base classes which cause compilation errors in derived classes instead of undesirable runtime errors.</p>\n\n    </blockquote>\n<p>メンバー関数をoverrideする時は、必ずoverride function...と明示しなければなりません。さもないとコンパイルエラーです。<br />\nこうすることで、望まないエラーを回避することができます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>いわゆる他のOO言語経験者からすると、何を今更当たり前のことを！って感じなんでしょうか。<br />\nそのほか<a href=\"http://www.slideshare.net/gorof/introduction-to-jsx\" target=\"_blank\" title=\"Introduction to JSX\">Introduction to JSX</a>の16枚目から補足すると。</p>\n\n<ul>\n<li>実装を伴うインターフェース(mixin)がある</li>\n<li>HTML ElementなどのJSのクラスは、native classとしてインターフェースを記述すると使えるようになる</li>\n<li>アクセス制御はない(public, protected, private)\n<ul>\n<li>_Hogeのようにアンダースコアがついたらprivateってのはあり</li>\n</ul></li>\n</ul><p>だそうです。</p><p>きっちり書かせる＋コンパイル時にエラーは絡めとる！みたいな。<br />\n経験ないのでわかりませんが、そんなにプログラマーって自由にあれこれ書いちゃうもんなんかな？まぁやりたいようにやっちゃうんやろうけど。</p><p>プロジェクトでもちろんコーディングルールは定めるものの、それを超えてコードレベルで統制をはかることで、より良いコードを！ってのがJSXの目指すところなんでしょうねー。</p>\n\n    <blockquote>\n        <p>このクラスベースっていう考え方や使い方についてはかなりトラウマなので、別記事で自分の考えと一緒にまとめておこうと思っています。<br />\nというわけで、Part5-2へ続く。</p>\n\n    </blockquote>\n\n</div>\n</div>"
}
