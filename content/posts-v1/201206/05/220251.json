{
  "title": "0からはじめるJSX Part.4",
  "html": "<p>意外に続いております。</p><p>正直プログラミングを覚えるには、こんな風に細かい仕様を見ていくよりもとりえず目標もって動かしたいものを作る・その過程で必要な仕様を調べるっていうのが一番やと思ってます。<br />\nとは言え、私自身はおさらいの意味も込めて、これからきっちり勉強しときたいなぁと思ってるので、こうしてます。</p>\n\n<div class=\"seemore\">\n    \n<div class=\"section\">\n    <h3>Static Types</h3>\n    \n    <blockquote>\n        <p>Basic type concept will be described in this section. Primitive types, object types, variant type, and MayBeUndefined types exist in JSX.</p>\n\n    </blockquote>\n<p>今回は「型」についてのセクションだそうです。</p>\n\n<ul>\n<li>Primirive</li>\n<li>Object</li>\n<li>Variant</li>\n<li>MayBeUndefined</li>\n</ul><p>大きく分けて以上の4つがあるようです。</p>\n\n</div>\n<div class=\"section\">\n    <h3>プリミティブ型</h3>\n    \n    <blockquote>\n        <p>Primitive types, e.g. string, boolean, or number are non-nullable, immutable types.</p>\n\n    </blockquote>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> s : <span class=\"synType\">string</span> = <span class=\"synConstant\">&quot;hello&quot;</span>;\n<span class=\"synIdentifier\">var</span> n : <span class=\"synType\">number</span> = 42;\n<span class=\"synIdentifier\">var</span> b : <span class=\"synStatement\">boolean</span> = <span class=\"synConstant\">true</span>;\n</pre>\n<ul>\n<li>String</li>\n<li>Boolean</li>\n<li>Number</li>\n</ul><p>以上3つがプリミティブ型というらしく、null不可、イミュータブル。</p><p>Primitiveは初期のとか基本的なとかいう意味なので、まぁプログラミングに使える要素の基本的なやつ、っていう感じかしら。<br />\n確かに意識してなかったけど、文字型とか数値型とか、当たり前に使ってたアレなんやね。</p>\n\n<div class=\"section\">\n    <h4>nullableってなに</h4>\n    <p>またも<a href=\"http://jsx.github.com/try/#\" target=\"_blank\" title=\"JSX - Statically-typed, object-oritented programming lauguage\">JSX - Try</a>に貼り付けてRunすると・・</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Test <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">static</span> <span class=\"synIdentifier\">function</span> run() : void <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">var</span> a : <span class=\"synType\">string</span> = <span class=\"synConstant\">&quot;Hi!&quot;</span>;\n    <span class=\"synComment\">//a = null; // cannot assign a value of type 'null' to 'string'</span>\n    <span class=\"synComment\">//a = 20; // cannot assign a value of type 'number' to 'string'</span>\n    log a;\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>という具合に、nullはダメよと怒られます。<br />\n型の違う値を入れようとしても怒られます。<br />\nJavaScriptだと後勝ちでなんでもかんでも入れ放題ですが、JSXではダメなんですね。</p>\n\n</div>\n<div class=\"section\">\n    <h4>イミュータブルってなに</h4>\n    <p><strong>勘違いが多く含まれていたので削除＋後述。</strong><br />\n<del>ImmutableはMutableの反対で、Mutableは・・・ミュータント！たーとｒ・・<br />\nなんか変幻自在な感じするでしょ？それの反対なので・・変化しないものって意味だそうな。<br />\n</del></p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これは不適切なサンプルです。</span>\n\n<span class=\"synIdentifier\">var</span> a = <span class=\"synConstant\">&quot;I'm immutable string!&quot;</span>;\n<span class=\"synIdentifier\">var</span> b = a;\n\na = <span class=\"synConstant\">&quot;Immutable, but changable.&quot;</span>;\n\t\t\nconsole.log(b); <span class=\"synComment\">// I'm immutable string!</span>\n<span class=\"synComment\">// これは不適切なサンプルです。</span>\n</pre><p><del>というわけで、変数aは(というか変数aを宣言したときに確保されたメモリのデータは)不変：Immutableなので。</del></p><p><del>これは概念を理解していたといより、経験の積み重ねとしてわかってるつもりになってたが正しいですね・・。<br />\n後述のオブジェクト型はそれと反対にMutableで、それは、</del></p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これも不適切なサンプルです。</span>\n<span class=\"synIdentifier\">var</span> a = <span class=\"synIdentifier\">[</span>1,2,3,4<span class=\"synIdentifier\">]</span>;\n<span class=\"synIdentifier\">var</span> b = a;\n\na<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span> = 0;\n\t\t\nconsole.log(b); <span class=\"synComment\">// [0,2,3,4]</span>\n<span class=\"synComment\">// これも不適切なサンプルです。</span>\n</pre><p><del>ほら、変わっちゃった。<br />\nこういうのをいわゆる参照渡しとか参照型とか言うらしいです。</del></p>\n\n    <blockquote>\n        <p>JavaScriptだと、他にもnullとundefinedがデータ型としてあったと思うんやけど、JSXではどういう扱いなのかしら。<br />\n試しに宣言してみたら、どっちもエラーになったっす。</p>\n\n    </blockquote>\n<p>ちなみに</p>\n\n    <blockquote>\n        <p>参考：<a href=\"http://d.hatena.ne.jp/a_bicky/20120603/1338722363\" target=\"_blank\" title=\"JSX 私的チュートリアル - あらびき日記\">JSX 私的チュートリアル - あらびき日記</a></p>\n\n    </blockquote>\n<p>こちらを拝見する限り、int型もあるみたいです。（チュートリアルに載ってないけど<br />\nint型は整数の数値、number型は小数点含む数値を扱えるようです。<br />\nintの存在意義はわかりません・・！（たぶんメモリ的に効率が良いとかそういうの。</p>\n\n</div>\n<div class=\"section\">\n    <h4>頂いたコメントを反映してのミュータブル</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> str = <span class=\"synConstant\">&quot;Immutable&quot;</span>; <span class=\"synComment\">// str.lengthは9</span>\nstr.length = 0; <span class=\"synComment\">// String型はImmutableなので、変更不可</span>\n\n<span class=\"synIdentifier\">var</span> arr = <span class=\"synIdentifier\">[</span>1,2,3<span class=\"synIdentifier\">]</span>; <span class=\"synComment\">// arr.lengthは3</span>\narr.length = 0; <span class=\"synComment\">// Array型(Array.&lt;number&gt;)はMutableなので変更される</span>\n</pre><p>変数の値とかではなくて、そもそものオブジェクトの枠組みや性質が変化するかどうか。</p><p>String, Number, Int, Booleanがプリミティブ型でイミュータブル。<br />\nDate, RegExp, Function, Array, Mapがオブジェクト型でミュータブル。</p><p></p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>オブジェクト型</h3>\n    \n    <blockquote>\n        <p>Object types, e.g. string[] (array of string), functions or Date, are nullable, mutable types.</p>\n\n    </blockquote>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> d : <span class=\"synType\">Date</span> = <span class=\"synStatement\">new</span> <span class=\"synType\">Date</span>(); <span class=\"synComment\">// Date</span>\n<span class=\"synIdentifier\">var</span> f : <span class=\"synIdentifier\">function</span>():void = <span class=\"synIdentifier\">function</span>() : void <span class=\"synIdentifier\">{</span> log <span class=\"synConstant\">&quot;Hi!&quot;</span>; <span class=\"synIdentifier\">}</span>;\n<span class=\"synIdentifier\">var</span> a : <span class=\"synType\">string</span><span class=\"synIdentifier\">[]</span> = <span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;foo&quot;</span><span class=\"synIdentifier\">]</span>; <span class=\"synComment\">// the same as Array.&lt;string&gt;</span>\n</pre>\n<ul>\n<li>Date</li>\n<li>Function</li>\n<li>String[]</li>\n</ul><p>これらはnullありのミュータブルなもの。</p>\n\n<div class=\"section\">\n    <h4>Dateというか、オブジェクト？</h4>\n    <p>ここではDateだけ載ってるけど、RegExpとかもどっかのサンプルで見た。<br />\nというわけで、おそらくオブジェクト型としてこういうのあるよ、Dateを見本に載せとくよって理解で良いと思ってます。</p>\n\n</div>\n<div class=\"section\">\n    <h4>配列？</h4>\n    <p>あと、このstring[ ]ってのはなんでしょう。<br />\nnumber[ ]ってやっても使えたので、JavaScriptの型風に見るのであれば、ただの配列って理解で良いんかな・・？<br />\nちなみに[true, false]とか書いてもエラーにならなかったので、きっとなんでも配列なんやろな・・。</p><p>JavaScriptだと配列とは言え中身はなんでもOKでしたが、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// JavaScriptだと中身はなんでも入る</span>\n<span class=\"synIdentifier\">var</span> arr1 = <span class=\"synIdentifier\">[</span>1, <span class=\"synConstant\">&quot;2&quot;</span>, 3, <span class=\"synConstant\">&quot;よん&quot;</span>, <span class=\"synIdentifier\">{</span>a:1, b:2<span class=\"synIdentifier\">}]</span>;\n\n<span class=\"synComment\">// JSXは配列でも何型の配列かを決める必要がある。</span>\n<span class=\"synIdentifier\">var</span> arr2 = <span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;string&quot;</span>, <span class=\"synConstant\">&quot;だけでできた&quot;</span>, <span class=\"synConstant\">&quot;配列&quot;</span><span class=\"synIdentifier\">]</span> : <span class=\"synType\">string</span><span class=\"synIdentifier\">[]</span>;\n<span class=\"synIdentifier\">var</span> arr3 = <span class=\"synIdentifier\">[</span>3, 1, 4, 30<span class=\"synIdentifier\">]</span> : <span class=\"synType\">number</span><span class=\"synIdentifier\">[]</span>;\n<span class=\"synIdentifier\">var</span> arr4 = <span class=\"synIdentifier\">[</span>3, 1, 4, 30<span class=\"synIdentifier\">]</span> : <span class=\"synType\">Array</span>.&lt;<span class=\"synType\">number</span>&gt;; <span class=\"synComment\">// こう書いても一緒</span>\n</pre><p>なるほど、配列も大変なんですねー。<br />\nもちろんint<span data-unlink>もあればboolean</span>もいけるみたい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>連想配列？</h4>\n    <p>さっきの参考記事によると、Mapというものもあるそうで、これは何かというと連想配列です。<br />\nとは言えアクセスするキーが数字じゃなくなるだけで、中身としては統一する必要があるそうな。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 連想配列でも何型の配列かを決める必要がある。</span>\n<span class=\"synIdentifier\">var</span> mpp1 = <span class=\"synIdentifier\">{</span>a: 1, b: 2<span class=\"synIdentifier\">}</span>; <span class=\"synComment\">// numberの連想配列</span>\n<span class=\"synIdentifier\">var</span> mpp2 = <span class=\"synIdentifier\">{</span>a: 1, b: 2<span class=\"synIdentifier\">}</span> : Map.&lt;<span class=\"synType\">number</span>&gt;; <span class=\"synComment\">// こう書いても一緒</span>\n<span class=\"synIdentifier\">var</span> mpp3 = <span class=\"synIdentifier\">{</span>key1: <span class=\"synConstant\">&quot;string&quot;</span>, key2: <span class=\"synConstant\">&quot;連想配列&quot;</span>, key3: <span class=\"synConstant\">&quot;です！&quot;</span><span class=\"synIdentifier\">}</span>;\n\nlog mpp3<span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;key1&quot;</span><span class=\"synIdentifier\">]</span>; <span class=\"synComment\">// string</span>\n<span class=\"synComment\">// log mpp3.key1 はエラー</span>\n</pre>\n</div>\n</div>\n<div class=\"section\">\n    <h3>バリアント型</h3>\n    \n    <blockquote>\n        <p>Variant type, which means \"no static type information,\" is used for interacting with existing JavaScript APIs. Some JavaScript libraries may return a variant value, which type cannot be determined at compile time. All you can do on variant values is to check equality of a variant value to another variant value. You have to cast it to another type before doing anything else on the value.</p>\n\n    </blockquote>\n\n<ul>\n<li>バリアント型は、型情報を持たない型で、既存のJavaScriptのAPIを使う時に利用します。コンパイル時に型が決定されないバリアントな値を返すものが、既存のライブラリにはあります。</li>\n<li>バリアント型のデータでできることは、互いの同一性(色んな意味を含む)を確認する用途だけです。</li>\n<li>バリアント型のもので何かするためには、必ずキャストする必要があります。</li>\n</ul><p>さっぱりすぎるので、<a href=\"http://www.slideshare.net/gorof/introduction-to-jsx\" target=\"_blank\" title=\"Introduction to JSX\">Introduction to JSXスライド</a>の14枚目を拝借。</p>\n\n    <blockquote>\n        \n<ul>\n<li>JSとのやりとりのためにvariant型がある\n<ul>\n<li>これはCのvoid*に似た、「何もできない型」</li>\n<li>なにかするためには必ずcastが必要</li>\n</ul></li>\n<li>variantに許される操作は==, !=, typeof, as\n<ul>\n<li>typeofはJSと同じ意味だがvariantに対してのみ許可される</li>\n</ul></li>\n<li>型安全を壊すのでなるべく使うべきでないが、 やろうと思えばなんでもできる\n<ul>\n<li>(js.global[\"jQuery\"] as Map.<variant>)[\"ready\"]</li>\n</ul></li>\n</ul>\n    </blockquote>\n<p>うん、さっぱり意味がわからない・・。<br />\nまぁその内なんか関わる時がくるやろうから、今はスルーでいいか。</p><p>一応上記の記事によると、JavaScriptでやってた型混じりの自由な配列とかを実現するには、コレを使うとのこと。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> arr1 = <span class=\"synIdentifier\">[</span>1, <span class=\"synConstant\">&quot;string&quot;</span>, 3<span class=\"synIdentifier\">]</span>: variant<span class=\"synIdentifier\">[]</span>;\n<span class=\"synIdentifier\">var</span> mpp1 = <span class=\"synIdentifier\">{</span>key1: 1, key2: <span class=\"synConstant\">&quot;string&quot;</span><span class=\"synIdentifier\">}</span> : Map.&lt;variant&gt;;\n</pre><p>もう全部コレでやったら良いんじゃ・・とか思ってません！<br />\nおそらく最後の逃げ道として用意した感じかと。</p>\n\n<div class=\"section\">\n    <h4>コメントより</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// JavaScript</span>\n<span class=\"synIdentifier\">function</span> returnStrOrNum(args)<span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> (args) ? <span class=\"synConstant\">&quot;Str&quot;</span> : 10;\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synComment\">// JSX</span>\n<span class=\"synIdentifier\">function</span> returnStrOrNum(args: <span class=\"synStatement\">boolean</span>): variant <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> (args) ? <span class=\"synConstant\">&quot;Str&quot;</span> : 10;\n<span class=\"synIdentifier\">}</span>\n</pre><p>仕方ないんでしょうけど、型付言語って面倒ですね・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>キャストってなに</h4>\n    <p>一度型を決めて宣言しても、時と場合によっては型を再度変えたい場合があって・・、って時はキャスト。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>log <span class=\"synConstant\">false</span> as <span class=\"synStatement\">int</span>; <span class=\"synComment\">// 0</span>\nlog <span class=\"synConstant\">&quot;aaa&quot;</span> as <span class=\"synStatement\">int</span>; <span class=\"synComment\">// 0</span>\nlog <span class=\"synConstant\">&quot;1&quot;</span> as <span class=\"synType\">number</span>; <span class=\"synComment\">// 1</span>\nlog 1.5 as <span class=\"synStatement\">int</span>; <span class=\"synComment\">// 1</span>\nlog (<span class=\"synConstant\">false</span> as <span class=\"synType\">string</span>).split(<span class=\"synConstant\">&quot;&quot;</span>).join(<span class=\"synConstant\">&quot;,&quot;</span>); <span class=\"synComment\">// f,a,l,s,e</span>\n</pre><p>これは使いそうな予感。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>MayBeUndefined型</h3>\n    <p>なんぞそれ・・。</p>\n\n    <blockquote>\n        <p>MayBeUndefined type is a meta type which indicates a value may be undefined. For example, the return type of Array.<string>#shift() is MayBeUndefined.<string>. When you use a MayBeUndefined value, you have to make sure of the value is not undefined.</p>\n\n    </blockquote>\n<p>MayBeUndefined型は値がundefinedかもしれない時に使われる型です。例えば、Array<string>のもつshift関数の返す値は、このMayBeUndefined型のstringです。<br />\nundefinedになる可能性のある値を扱う場合は、値がundefinedにならないようにする必要があります。</p><p>MayBeUndefined型として指定するか、そもそもundefinedにならないようにするかしなさいということでしょうね。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">function</span> shiftOrReturnEmptyString(args : <span class=\"synType\">string</span><span class=\"synIdentifier\">[]</span>) : <span class=\"synType\">string</span> <span class=\"synIdentifier\">{</span>\n\t<span class=\"synStatement\">if</span> (args.length &gt; 0)\n\t\t<span class=\"synStatement\">return</span> args.shift();\n\t<span class=\"synStatement\">else</span>\n\t\t<span class=\"synStatement\">return</span> <span class=\"synConstant\">&quot;&quot;</span>;\n<span class=\"synIdentifier\">}</span>\n</pre><p><del>いちおう決まりとしては、もしかしたらundefinedかも知れないことを明示する型があって、↑のshift関数みたいなやつは、配列の中身がもう無いよ！って場合にはundefinedになりうるので、MayBeUndefined型とするってこと・・？<br />\nなので、このshiftOrReturnEmptyString関数は空の文字列を返すように設計してます、ということか。</del></p>\n\n<ul>\n<li>Array.shift関数は、配列の要素がなくなってしまうとundefinedを返すようになる。</li>\n<li>そのため、このshiftOrReturnEmptyString関数は空の文字列を返すように設計している。</li>\n<li>もしこの分岐を設けない場合は、関数の返り値の型は、stringではなくMayBeUndefinedになる。</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n    <blockquote>\n        <p>When the source code is compiled in debug mode (which is the default), the compiler will insert run-time type-checking code. An exception will be raised (or the debugger will be activated) when misuse of an undefined value as actual value is detected. Run-time type checks can be omitted by compiling the source code with the --release option.</p>\n\n    </blockquote>\n<p>コンパイル時には、デフォルトで型チェックのデバッグコードが挿入されるようになっています。<br />\n --releaseオプションを付けてコンパイルすることで、それを省くこともできます、と。</p><p>変数一つとっても何が入ってくるかわからんJavaScript。<br />\nそのままはよろしくないので、きっちり型を明記した上で使いましょう。<br />\nとりわけnullやundefinedには気を使って、明示できるシーンではきっちり明示することで後で困ることのないように。</p><p>ってことやと思う、たぶん。<br />\nJavaからプログラミング言語を勉強した人とかは納得なんやろうけど！<br />\n大規模開発向け言語は色々制約があって大変ですねー。</p><p>コツコツいきましょ。</p>\n\n</div>\n</div>"
}
