{
  "title": "iOSでWebRTCが使えないからWebSocketとWebAudioで擬似ストリーミングしてみた",
  "html": "<p>というわけで、またも会社の合宿で作ったものを紹介します。<br />\nそして前回に引き続き、なんかまた優勝しました(∩´∀｀)∩ﾜｰｲ</p><p><iframe src=\"//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fleader22%2Faudio-streaming-over-websocket\" title=\"leader22/audio-streaming-over-websocket\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe><cite class=\"hatena-citation\"><a href=\"https://github.com/leader22/audio-streaming-over-websocket\">github.com</a></cite></p><p>ざっくりでよければ社内勉強会で発表したスライドがあるのでこっちを。</p>\n\n    <blockquote>\n        <p><a href=\"http://leader22.github.io/slides/pxg_camp-2016a/\">WebSocket&#x3067;AudioStreaming&#x3057;&#x3066;&#x307F;&#x305F;</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>何を作ったのか</h3>\n    <p>具体的な利用シーンはコレです。</p>\n\n<ul>\n<li>イカしよーよ！</li>\n<li>じゃあイカデンワたてるわー</li>\n<li>あ、あたし<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iPhone\">iPhone</a>しか持ってないから無理だ・・</li>\n<li>(せめて聞くだけでもできればな・・</li>\n</ul><p>とか、</p>\n\n<ul>\n<li>イカやろうぜ！</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Skype\">Skype</a>よろー</li>\n<li>俺のPC、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Skype\">Skype</a>と相性悪いから通話なしで！</li>\n<li>(せめて携帯で聞くだけでもできたらな・・</li>\n</ul><p>とか。</p><p>そんなときのソリューションになればなーと思って作ったのがコレ。<br />\n<br />\n</p>\n\n</div>\n<div class=\"section\">\n    <h3>やってること</h3>\n    \n<div class=\"section\">\n    <h4>Pub: 配信する側</h4>\n    \n<ul>\n<li>端末マイクからAudioStreamを拾う</li>\n<li>Web Audio <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で適当にノイズ処理</li>\n<li>Web Audio <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>でサンプルデータを取得</li>\n<li>それをWorkerに立てたSocket.IOのクライアントからサーバーへ流す</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>Sub: 聞く側</h4>\n    \n<ul>\n<li>Workerに立てたSocket.IOのクライアントから音データをもらう</li>\n<li>WebAudio <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で再生する</li>\n</ul><p>これで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iPhone\">iPhone</a>しかもってない人でも、聴けるだけならチャットに参加できるように！</p>\n\n    <blockquote>\n        <p>ア<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%C7%A5%A2\">イデア</a>自体は今にはじまったものではなく、WebSocketで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4\">バイ</a>ナリが飛ばせるようになった時代からあったものです。<br />\nそんな先人のネタをかき集め、現代風に書きなおした感じです。</p>\n\n    </blockquote>\n<p>以下、個別のメモとしてインターネットに放流したいものを書いていきます。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>細かい話</h3>\n    <p>コードは参考のために雑に抜粋してます。</p>\n\n<div class=\"section\">\n    <h4>マイクの音をjsで加工するには</h4>\n    <p>WebRTC界隈ではおなじみの、Media Streaming <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/a.k.a.\">a.k.a.</a> `getUserMedia()`を使います。<br />\nで、そのストリームをWebAudioでAudioNodeにして、それで触ります。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> ctx = <span class=\"synStatement\">new</span> AudioContext();\n\n<span class=\"synComment\">// マイク取る</span>\nnavigator.getUserMedia(\n  <span class=\"synIdentifier\">{</span> audio: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">function</span>(stream) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// AudioNodeに</span>\n    <span class=\"synIdentifier\">var</span> source = ctx.createMediaStreamSource(stream);\n\n    <span class=\"synComment\">// オーディオのサンプルに触るなら</span>\n    <span class=\"synIdentifier\">var</span> processor = ctx.createScriptProcessor(BUFFER_SIZE, 1, 1);\n    processor.onaudioprocess = <span class=\"synIdentifier\">function</span>(ev) <span class=\"synIdentifier\">{</span>\n      <span class=\"synIdentifier\">var</span> inputBuffer  = ev.inputBuffer;\n      <span class=\"synIdentifier\">var</span> outputBuffer = ev.outputBuffer;\n\n      <span class=\"synComment\">// Float32なArrayBuffer</span>\n      <span class=\"synIdentifier\">var</span> inputData  = inputBuffer.getChannelData(0);\n      <span class=\"synIdentifier\">var</span> outputData = outputBuffer.getChannelData(0);\n      \n      <span class=\"synComment\">// 何もしなくてもoutputは返さないと音が出ない</span>\n      outputData.set(inputData);\n    <span class=\"synIdentifier\">}</span>;\n    \n    source.connect(processor);\n    processor.connect(ctx.destination);\n  <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">function</span>(err) <span class=\"synIdentifier\">{</span>\n    console.error(err);\n  <span class=\"synIdentifier\">}</span>\n);\n</pre><p>ポイントは、</p>\n\n<ul>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/destination\">destination</a>`までちゃんと`connect()`しないと音が流れてこない</li>\n<li>`onaudioprocess`ではoutputを返さないといけない</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>なんちゃってバンドパスフィルタ</h4>\n    <p>普段なにげに使ってる電話ですが、あいつはすごいんです。</p><p>日常にはノイズがあふれていて、パソコンのマイクで音を拾う場合には、肝心の声以外にも雑音がたくさん乗ります。<br />\nそこで、必要な周波数帯域(バンド)だけを通過(パス)させる必要があり・・。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// なんちゃってバンドパスフィルタ</span>\n<span class=\"synIdentifier\">var</span> filter = ctx.createBiquadFilter();\nfilter.type = <span class=\"synConstant\">'bandpass'</span>;\nfilter.frequency.value = (100 + 7000) / 2;\nfilter.Q.value = 0.25;\n</pre><p>WebAudio <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>にはそういうフィルタを作るAudioNodeがあるので、それで設定します。<br />\nアナログ電話は300Hz ~ 3.4kHz / <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%D2%A4%AB%A4%EA%C5%C5%CF%C3\">ひかり電話</a>は100Hz ~ 7kHzあたりが有効な帯域らしいので、それを模したい・・が、その範囲をうまいことカバーするのは大変なので固定で決め打ち。</p><p>ほんとは音声成分を解析して、選択域を随時変えたりするアクティブなフィルタにすべきなんでしょうが・・・まぁ無いよりマシです。<br />\n普通に通話してる声を拾うだけなら十分だと思います。</p>\n\n</div>\n<div class=\"section\">\n    <h4>裏タブに回ってもWebWorkerは仕事する</h4>\n    <p>WebAudio <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で音を鳴らすだけであれば、裏タブに回ろうがブラウザ自体が非アクティブになろうが問題ないんですけど・・。<br />\nWebSocketで通信するあたりの処理は間引かれてしまうっぽい？です。</p><p>そこで、それらの処理はWebWorkerにやらせることで、安定した動作が期待できました。<br />\nBrowserifyしてる中で使いたい場合は、webworkifyってのを使う。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/substack/webworkify\">GitHub - substack/webworkify: launch a web worker that can require() in the browser with browserify</a></p>\n\n    </blockquote>\n<p>呼び出し側のコード。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これを</span>\n<span class=\"synIdentifier\">var</span> worker = <span class=\"synStatement\">new</span> Worker(<span class=\"synConstant\">'./worker.js'</span>);\n\n<span class=\"synComment\">// こう</span>\n<span class=\"synIdentifier\">var</span> webworkify = require(<span class=\"synConstant\">'webworkify'</span>);\n<span class=\"synIdentifier\">var</span> worker = webworkify(require(<span class=\"synConstant\">'./worker.js'</span>));\n\n<span class=\"synComment\">// 後は一緒</span>\nworker.postMessage();\nworker.addEventListener(<span class=\"synConstant\">'message'</span>, (ev) =&gt; <span class=\"synIdentifier\">{}</span>);\n</pre><p>呼ばれる側のコード。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// これを</span>\nimportScripts(<span class=\"synConstant\">'./path/to/socket.io-client.js'</span>);\n\n<span class=\"synComment\">// こう</span>\n<span class=\"synIdentifier\">var</span> io = require(<span class=\"synConstant\">'socket.io-client'</span>);\n\nmodule.exports = <span class=\"synIdentifier\">function</span>(<span class=\"synStatement\">self</span>) <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// ココはいつもと一緒</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>書き味はほぼ一緒だと思います。<br />\nはじめてWorkerを正しい使い方で使った気がする！</p>\n\n</div>\n<div class=\"section\">\n    <h4>WebSocketで音データを飛ばして流す</h4>\n    <p>肝心のところですね。</p><p>まずは飛ばす側。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// evはonaudioprocessより</span>\n<span class=\"synIdentifier\">var</span> outputBuffer = ev.outputBuffer;\n<span class=\"synIdentifier\">var</span> outputData = outputBuffer.getChannelData(0);\n\nsocket.emit(<span class=\"synConstant\">'audio'</span>, outputData.buffer);\n</pre><p>受ける側。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">var</span> ctx = <span class=\"synStatement\">new</span> AudioContext();\n<span class=\"synIdentifier\">var</span> startTime = 0;\n\n<span class=\"synComment\">// evはonaudioprocessより</span>\nsocket.on(<span class=\"synConstant\">'audio'</span>, <span class=\"synIdentifier\">function</span>(buffer) <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// バッファはFloat32</span>\n  <span class=\"synIdentifier\">var</span> f32Audio = <span class=\"synStatement\">new</span> Float32Array(buffer);\n\n  <span class=\"synIdentifier\">var</span> source = ctx.createBufferSource();\n  <span class=\"synIdentifier\">var</span> audioBuffer = ctx.createBuffer(1, BUFFER_SIZE, ctx.sampleRate);\n  audioBuffer.getChannelData(0).set(f32Audio);\n  source.buffer = audioBuffer;\n  source.connect(ctx.destination);\n\n  <span class=\"synComment\">// 再生タイミングに注意</span>\n  <span class=\"synIdentifier\">var</span> currentTime = ctx.currentTime;\n  <span class=\"synStatement\">if</span> (currentTime &lt; startTime) <span class=\"synIdentifier\">{</span>\n    source.start(startTime);\n    startTime += audioBuffer.duration;\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n    source.start(startTime);\n    startTime = currentTime + audioBuffer.duration;\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>大事なポイントは2つ。</p>\n\n<ul>\n<li>AudioBufferのPCMデータはFloat32Arrayなので、受け側もあわせる</li>\n<li>ソケットの到着順に随時再生だと、自然に聞こえないのでこちらでスケジューリングが必要</li>\n</ul>\n    <blockquote>\n        <p>調べてもぜんぜん例がなくて苦労したけど、できてみたらあっさりしたコードで拍子抜けした(˘ω˘ </p>\n\n    </blockquote>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>性能について</h3>\n    <p>結論から書くと、</p>\n\n<ul>\n<li>ハードウェア性能は問わなそう\n<ul>\n<li>iOS7の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/iPhone\">iPhone</a>でも普通に動く</li>\n<li>古い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Android\">Android</a>は知らん</li>\n</ul></li>\n<li>ネットワークは狭い・速いにこしたことない\n<ul>\n<li>ただLANでもWANでも品質にそこまで差はない</li>\n</ul></li>\n<li>別に遅くはない\n<ul>\n<li>遅延は1秒あるかないかとか</li>\n<li>が、長いことやってるとズルズル遅れていくような？</li>\n<li>まぁ定期的に繋ぎ直せば良い</li>\n</ul></li>\n<li>音質は通話レベルなら問題ない\n<ul>\n<li>音楽を聞くとなると音質が気になる</li>\n</ul></li>\n</ul><p>というわけで、割と良い気がしてます。<br />\nパフォーマンスって意味では2−3人しかつなげた状態までしか試せてないので、誰か試してくれないかなーと思ってるところ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>とりあえずWeb屋として出来る限りのことをやってみた感があって、これ以上のチューニングを諦めてる感があります。<br />\n音質をもうちょい調整できれば、家ネットワークで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Bluetooth\">Bluetooth</a>に頼らずともワイヤレスで聞けたりするのになー。<br />\nそういう感じのラジオシステムみたいな使い方もできちゃうのになー。</p><p>というわけで、WebAudioガチ勢の人とか、TypedArrayマニアの人とか、音声通話のフィルタ作ったことあるよって人とか、何かとフィードバックあれば嬉しいです！</p>\n\n    <blockquote>\n        <p>そのままは使えんけど、コードを適当にコピーしてつなぎこめばイカ○ンワの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%E9%A5%B0%A5%A4%A5%F3\">プラグイン</a>的にも！</p>\n\n    </blockquote>\n\n</div>"
}
