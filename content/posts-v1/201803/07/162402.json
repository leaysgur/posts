{
  "title": "動画切り出しアプリをElectronで作った",
  "html": "<p>in 弊社の開発合宿。</p><p>発表資料こちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://leader22.github.io/slides/pxg_camp-2018a/\">&#x52D5;&#x753B;&#x5207;&#x308A;&#x51FA;&#x3057;&#x30A2;&#x30D7;&#x30EA;&#x3092;Electron&#x3067;&#x4F5C;&#x3063;&#x305F;</a></p>\n\n    </blockquote>\n<p>ここに載せてない細かいことを、忘れないようにメモっておきます。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>作ったもの</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/leader22/movie-slicer/\">GitHub - leader22/movie-slicer: Slice your favorite scenes from movie file.</a></p>\n\n    </blockquote>\n<p>動画ファイルから、任意の秒数を切り出して、新たに動画ファイルを作成するアプリです。</p><p>別途インストールされてる前提の`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ffmpeg\">ffmpeg</a>`をElectronから呼び出してるので、いわば豪華な`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ffmpeg\">ffmpeg</a>`ラッパーです。</p><p>完全に自分用で作ったので、用途としてはいわゆる`mp4`を`mp4`に切り出すだけに限定してます。<br />\n他のフォーマットも`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ffmpeg\">ffmpeg</a>`が対応してれば対応できると思うけど、手元に素材もなかったのでやってません。</p><p>Electronを使っててパッケージングもちゃんとやったので、今も手元で元気にアプリとして動いてます。</p><p>というわけで、せっかくなのでElectron開発Tipsをいくつかメモっておく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Mainプロセス</h3>\n    \n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%B4%C4%B6%AD%CA%D1%BF%F4\">環境変数</a>のパス</h4>\n    \n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2018/03/05/171036\">Electron&#x3067;Main&#x30D7;&#x30ED;&#x30BB;&#x30B9;&#x304B;&#x3089;child_process&#x3067;&#x30B3;&#x30DE;&#x30F3;&#x30C9;&#x3092;&#x53E9;&#x304F;&#x3068;&#x30A8;&#x30E9;&#x30FC;&#x30B3;&#x30FC;&#x30C9;: 127 - console.lealog();</a></p>\n\n    </blockquote>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mac\">mac</a>だけの問題っぽいけど、ハマった。</p>\n\n</div>\n<div class=\"section\">\n    <h4>スペース入りのパス</h4>\n    <p>ElectronというかNode.jsでファイルパスを扱うときの問題かな？<br />\n`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ffmpeg\">ffmpeg</a>`を`child_process.exec`するときにハマった。</p><p>たとえば、`/Users/leader22/Desktop/Sample directory/テスト.mp4`みたく、パスの中にスペースが含まれる時。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> path = <span class=\"synConstant\">'/Users/leader22/Desktop/Sample directory/テスト.mp4'</span>;\nexec(`ffprobe -i $<span class=\"synIdentifier\">{</span>path<span class=\"synIdentifier\">}</span>`, (err, stdout, stderr) =&gt; <span class=\"synIdentifier\">{}</span>);\n</pre><p>これだとダメ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> path = <span class=\"synConstant\">'/Users/leader22/Desktop/Sample directory/テスト.mp4'</span>;\nexec(`ffprobe -i <span class=\"synConstant\">&quot;${path}&quot;</span>`, (err, stdout, stderr) =&gt; <span class=\"synIdentifier\">{}</span>);\n</pre><p>手っ取り早いのは、`\"`で囲っちゃう。<br />\nこうすると<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%B9\">エス</a>ケープがいい感じに回避できる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ipcMain経由でchild_process.exec</h4>\n    <p>Rendererプロセスとやり取りする時に使うコレで、シェルを叩いて結果を得る一連の流れ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>ipcMain.on(evName, (<span class=\"synIdentifier\">{</span> sender <span class=\"synIdentifier\">}</span>, arg) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> cmd = getCommandByEvName(evName, arg);\n  exec(cmd, (err, stdout, stderr) =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">if</span> (err || stderr) <span class=\"synIdentifier\">{</span>\n      <span class=\"synStatement\">return</span> sender.send(`$<span class=\"synIdentifier\">{</span>evName<span class=\"synIdentifier\">}</span>:result`, <span class=\"synIdentifier\">{</span>\n        type: <span class=\"synConstant\">'err'</span>,\n        payload: err || stderr,\n      <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span>\n\n    <span class=\"synStatement\">return</span> sender.send(`$<span class=\"synIdentifier\">{</span>evName<span class=\"synIdentifier\">}</span>:result`, <span class=\"synIdentifier\">{</span>\n      type: <span class=\"synConstant\">'ok'</span>,\n      payload: stdout,\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>てな感じの関数を用意しておいて、コマンドを実行して結果を返すまでを一連の流れにしておくと便利だった。<br />\nRenderer側の流れは後述。</p>\n\n</div>\n<div class=\"section\">\n    <h4>menuのクセ: submenu編</h4>\n    <p>どうせElectronでアプリ作るなら、メニューもちゃんと作りたい。<br />\nというわけであれこれ眺めてたけど、この`Menu`のテンプレートの書式のクセを把握するのに時間がかかった。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// このmenuTemplateがクセもの</span>\n<span class=\"synStatement\">const</span> menu = Menu.buildFromTemplate(menuTemplate);\nMenu.setApplicationMenu(menu);\n</pre><p>オブジェクトの配列で構成されてて、`label`と`submenu`が必要。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> menuTemplate = <span class=\"synIdentifier\">[</span>\n  <span class=\"synIdentifier\">{</span>\n    label: <span class=\"synConstant\">'メニュー1'</span>,\n    submenu: <span class=\"synIdentifier\">[]</span>,\n  <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">{</span>\n    label: <span class=\"synConstant\">'メニュー2'</span>,\n    submenu: <span class=\"synIdentifier\">[</span>\n      <span class=\"synIdentifier\">{</span>\n        label: <span class=\"synConstant\">'メニュー2-1'</span>,\n      <span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">]</span>,\n  <span class=\"synIdentifier\">}</span>,\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">]</span>;\n</pre><p>で、このように独自で`label`を指定する他にも、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/mac\">mac</a>の基本的なメニュー機能を拝借できる便利なのがある。</p><p>例えばこういうの。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> menuTemplate = <span class=\"synIdentifier\">[</span>\n  <span class=\"synIdentifier\">{</span>\n    label: app.getName(),\n    submenu: <span class=\"synIdentifier\">[</span>\n      <span class=\"synIdentifier\">{</span>role: <span class=\"synConstant\">'about'</span><span class=\"synIdentifier\">}</span>,\n      <span class=\"synIdentifier\">{</span>type: <span class=\"synConstant\">'separator'</span><span class=\"synIdentifier\">}</span>,\n      <span class=\"synIdentifier\">{</span>role: <span class=\"synConstant\">'quit'</span><span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">]</span>,\n  <span class=\"synIdentifier\">}</span>,\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">]</span>;\n</pre><p>`role: 'about'`で、「このアプリについて」が出るようになるし、`role: 'quit'`で「終了」が使えるようになる。<br />\nしかもキーボードショートカット付きで。</p><p>`type: 'separator'`はその名の通り、仕切り線が出せる。</p><p>もちろんメニュー出すだけじゃ意味なくて、選択された時にハンドラを指定することになるけどそれと併せてやりたいことがあるので次へ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>menuのクセ: キーボードショートカット編</h4>\n    <p>Electronでキーボードショートカット対応するには2パターンやり方がある。</p>\n\n<ul>\n<li>Rendererプロセス側で、`addEventListener('keydown')`とかする</li>\n<li>Mainプロセス側で、メニュー経由で仕込む</li>\n</ul><p>個人的には全部Main側に寄せたほうが良いかなーと思った。アプリなので。</p><p>実装はめっちゃ簡単で、さっきのメニューのテンプレにそれ用の記述を足すだけ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> menuTemplate = <span class=\"synIdentifier\">[</span>\n  <span class=\"synIdentifier\">{</span>\n    label: app.getName(),\n    submenu: <span class=\"synIdentifier\">[</span>\n      <span class=\"synIdentifier\">{</span>role: <span class=\"synConstant\">'about'</span><span class=\"synIdentifier\">}</span>,\n      <span class=\"synIdentifier\">{</span>\n        label: <span class=\"synConstant\">'Preferences...'</span>,\n        click() <span class=\"synIdentifier\">{</span> win.webContens.send(<span class=\"synConstant\">'shortcut:openSettings'</span>); <span class=\"synIdentifier\">}</span>,\n        accelerator: <span class=\"synConstant\">'CommandOrControl+,'</span>,\n      <span class=\"synIdentifier\">}</span>,\n      <span class=\"synIdentifier\">{</span>type: <span class=\"synConstant\">'separator'</span><span class=\"synIdentifier\">}</span>,\n      <span class=\"synIdentifier\">{</span>role: <span class=\"synConstant\">'quit'</span><span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">]</span>,\n  <span class=\"synIdentifier\">}</span>,\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">]</span>;\n</pre><p>`accelerator`と`click`がソレ。<br />\nキーボードショートカットいらないなら`click`だけでいい。</p><p>さてさてキーボードショートカットが押されたことをRenderer側に伝えるためにイベントを通知したいけど、`ipcMain.send()`なんてメソッドは存在しない。<br />\nなのでRendererにメッセージを送りたい場合は、`webContents.send()`する必要がある。</p><p>本当は、Renderer側の状態にあわせてファイルメニュー自体を非活性にしたりするべき。<br />\n今回はそれに気付いてなくて、Main -> Rendererの一方向的な実装にしちゃったのが少し反省点。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Rendererプロセス</h3>\n    \n<div class=\"section\">\n    <h4>onloadを待たないと何も出ない</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">window</span>.addEventListener(<span class=\"synConstant\">'load'</span>, () =&gt; <span class=\"synIdentifier\">{}</span>);\n</pre><p>普段`body`の最後に`script`タグを書いてる身としては、コレいらんやろ的な気持ちで省いてたけど、Electronだと必要だった。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ipcRenderer.once -> send</h4>\n    <p>先述した`ipcMain`へイベントを送るための仕組み。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synIdentifier\">function</span> execCommand(name, options) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> <span class=\"synStatement\">new</span> Promise((resolve, reject) =&gt; <span class=\"synIdentifier\">{</span>\n    ipcRenderer.once(`$<span class=\"synIdentifier\">{</span>name<span class=\"synIdentifier\">}</span>:result`, (_ev, <span class=\"synIdentifier\">{</span> type, payload <span class=\"synIdentifier\">}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n      <span class=\"synStatement\">if</span> (type === <span class=\"synConstant\">'err'</span>) <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">return</span> reject(payload);\n      <span class=\"synIdentifier\">}</span>\n      resolve(payload);\n    <span class=\"synIdentifier\">}</span>);\n\n    ipcRenderer.send(name, options);\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>\n</pre><p>`once`で一度きり実行結果を待つようにして、`ipcRenderer.send()`する流れを`Promise`でラップしておく。</p><p>すると、シェルの実行を`await`できてコードの見通しが大変よろしい感じになった。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>開発環境</h3>\n    \n<div class=\"section\">\n    <h4>sindresorhus/electron-reloader が惜しい</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">if</span> (process.env.NODE_ENV === <span class=\"synConstant\">'development'</span>) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">try</span> <span class=\"synIdentifier\">{</span>\n    require(<span class=\"synConstant\">'electron-reloader'</span>)(module, <span class=\"synIdentifier\">{</span>\n      ignore: <span class=\"synIdentifier\">[</span>`$<span class=\"synIdentifier\">{</span>__dirname<span class=\"synIdentifier\">}</span>/src/renderer`<span class=\"synIdentifier\">]</span>,\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">catch</span> (err) <span class=\"synIdentifier\">{</span>\n    err;\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>根っこのモジュールで呼んでおくと、依存ファイルに変更があった場合によしなにしてくれる。</p>\n\n<ul>\n<li>Renderer関連の場合はリロード</li>\n<li>Main関連の場合はアプリごと再起動</li>\n</ul><p>という感じで最高。</p><p>裏で`webpack -w`しておけば、Renderer関連はバンドルされたファイルが吐かれる度にリロードしてくれる。<br />\n元ソースは無視するように指定しておけばいい。最高。</p><p>ただ一つ惜しい点を上げると、Main関連に変更があってアプリが再起動すると、そのプロセスが行方不明になるところ・・。（うちの環境だけ？）</p><p>なのでMainプロセス側を<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>する時に`console.log`とかしても、再起動されるとプロセスがどっか行って見えなくなって困るｗ<br />\n結局Mainプロセスの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D0%A5%C3%A5%B0\">デバッグ</a>時には手動でアプリを再起動してた・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>webpack</h4>\n    <p>`target`に`electron-renderer`を指定しないと、`ipcRenderer`とかそういうモジュールがバンドルされなくて色々困る。<br />\nむしろコレさえ指定すれば、他はまったく普段の開発と同じにできるので、他に何も必要なくなる。</p><p>`electron-main`も指定できるけど、バンドルしたところでなぁって感じ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>electron-userland/electron-packager</h4>\n    <p>ほんと便利。<br />\nアプリにした時のサイズを減らすために、`ignore`の指定をきちんとするのが面倒なくらい。</p>\n<pre class=\"code lang-sh\" data-lang=\"sh\" data-unlink>electron-packager ./ MovieSlicer <span class=\"synSpecial\">--platform=darwin</span> <span class=\"synSpecial\">--arch=x64</span> <span class=\"synSpecial\">--icon=./assets/app_icon/MovieSlicer.icns</span> <span class=\"synSpecial\">--overwrite</span> <span class=\"synSpecial\">--ignore=\\</span>&quot;^/node_modules<span class=\"synSpecial\">\\&quot;</span> <span class=\"synSpecial\">--ignore=\\</span>&quot;^/assets<span class=\"synSpecial\">\\&quot;</span> <span class=\"synSpecial\">--ignore=\\</span>&quot;^/src/renderer<span class=\"synSpecial\">\\&quot;</span>\n</pre><p>`node_modules`は、デフォルトで`devDeps`にあるのだけは無視してくれるっぽい。<br />\nただ今回はRendererプロセスで使ってるやつはwepackでビルドするので、`deps`も不要なため無視するように。</p><p>Mainで使ってるやつまで無視されたら困るのでは？と最初思ったけど、パッケージ化の際によしなにしてくれてるぽく、`node_modules`自体いらない感じになった。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>総じて</h3>\n    <p>Electron良かった。<br />\n特にハマりどころもなく、割と思い通りに作りたいものを作れたので不満はないかなーという感じ。</p><p>また違うものを作ったときに違う不満が出て来ることはあると思うけど・・。（<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Windows\">Windows</a>でも動くようにとか）</p>\n\n</div>"
}
