{
  "title": "miniflare@tre のコードを読む",
  "html": "<p>`miniflare`のコードを読むシリーズもこれで3本目。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2021/07/26/105807\">miniflare &#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; - console.lealog();</a><br />\n<a href=\"https://lealog.hateblo.jp/entry/2021/12/14/142643\">miniflare@next &#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; - console.lealog();</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3 id=\"Overview\">Overview</h3>\n    <p>そもそも`@tre`ってのは、`miniflare`の`tre`ブランチにあるコードのこと。</p><p>これは現状の`wrangler`の最新バージョンであるv3系で内部的に使われてるバージョン。GitHubのデフォルトブランチは`master`のままで、こいつはv2系で使われてたもの。</p><p>v2からv3になった最大の差異は、`workerd`を内部的に使うようになって、`miniflare`のレイヤーでがんばってエミュレートしてた処理がごっそり消えたこと。（さよなら俺たちのコントリビューション）</p><p>というわけで、最新の`wrangler dev`では、`workerd`を使った`miniflare@tre`がデフォルトになったけど、</p>\n\n<ul>\n<li>`--remote`をつけたときは`miniflare`を一切使ってないの？</li>\n<li>そもそも`workerd`とはどういう役割分担になってる？</li>\n<li>たとえばKVなんかをpersistしてるあの処理はどこで？</li>\n</ul><p>などなど気になったので、読んでみた。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"wrangler-devのおさらい\">`wrangler dev`のおさらい</h3>\n    <p>まず、内部的に`workerd`を使うようになったとはいえ、`wrangler`自体が`workerd`を直接使っているわけではない。</p><p>ということで、まずは`wrangler dev`が何をやってるのかを調べておく。</p>\n\n<div class=\"section\">\n    <h4 id=\"リモート\">リモート</h4>\n    <p>`--remote`で起動したときの流れ。</p><p>この場合、ローカルではなくCloudflare WorkersのプレビューWorkerが実際にデプロイされて、そこに一時的にアクセスできるようになる。</p><p>内部的な処理としては、</p>\n\n<ul>\n<li>`previewToken`（プレビューWorkerのURLや認証トークンなど）の取得\n<ul>\n<li>`wrangler.toml`をパースして、各バインディングやフラグを取得</li>\n<li>Workerスクリプトのパース</li>\n<li>REST APIのカタログには載ってない、`edge-preview`のエンドポイントに対してアップロード\n<ul>\n<li>Workerコードはすべて`FormData`に載せられる</li>\n</ul></li>\n<li>`prewarm`なる処理のためにPOSTを1発</li>\n</ul></li>\n<li>プレビューWorkerへとつながるProxyサーバーの起動\n<ul>\n<li>ローカルに立つのは`node:http(s)`のサーバー</li>\n<li>このサーバーはHTTP/1だが、プレビューサーバーはHTTP/2なのでその変換</li>\n</ul></li>\n<li>`<a href=\"http://127.0.0.1:8787\">http://127.0.0.1:8787</a>`がready</li>\n</ul><p>って感じ。</p><p>コードはこのあたりから。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/blob/main/packages/wrangler/src/dev/remote.tsx#L64\">https://github.com/cloudflare/workers-sdk/blob/main/packages/wrangler/src/dev/remote.tsx#L64</a></p>\n\n    </blockquote>\n<p>実際にデプロイされるので、KVやらR2なんかも実際のCloudflareネットワークにある実際の値にアクセスできるってこと。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"ローカル\">ローカル</h4>\n    <p>`--remote`がないとき。aka `--experimental-local`だった挙動。</p><p>この場合、`workerd`が`miniflare`経由で利用される。</p><p>内部的な処理としては、</p>\n\n<ul>\n<li>`miniflare`をラップしたサーバーを立てる\n<ul>\n<li>モジュールとしての`miniflare`を初期化</li>\n<li>以後、アップデートの度に`mf.setOptions(newOptions)`してリロード</li>\n</ul></li>\n<li>`<a href=\"http://127.0.0.1:8787\">http://127.0.0.1:8787</a>`がready</li>\n</ul><p>って感じ。</p><p>コードはこのあたりから。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/blob/main/packages/wrangler/src/dev/local.tsx#L131\">https://github.com/cloudflare/workers-sdk/blob/main/packages/wrangler/src/dev/local.tsx#L131</a></p>\n\n    </blockquote>\n<p>さて、ここで立ててる`miniflare`のインスタンスが、内部的に`workerd`を抱えてるってことは予想できる。</p><p>けど、`workerd`自体にKVみたいなストレージの機能はないので、そこを`miniflare`が引き続きNode.jsでがんばって実装してるはず。<br />\nそしてその実装を`workerd`の設定がどうやってリンクしてるのか。</p><p>みたいなことを引き続き調べていく。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"miniflaretre\">`miniflare@tre`</h3>\n    <p>というわけで本題。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/tree/tre\">https://github.com/cloudflare/miniflare/tree/tre</a></p>\n\n    </blockquote>\n<p>根本のモジュールで`export`されてる`Miniflare`クラスから追っていく。</p>\n\n<div class=\"section\">\n    <h4 id=\"Miniflare\">`Miniflare`</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/index.ts#L393\">https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/index.ts#L393</a></p>\n\n    </blockquote>\n<p>コンストラクタでやってること。</p>\n\n<ul>\n<li>`#initPlugins()`: KVなど各種バインディングの実装の初期化</li>\n<li>`#init()`: ランタイムの初期化\n<ul>\n<li>ループバックサーバーの起動</li>\n<li>ランタイムの起動</li>\n<li>ランタイムに渡す設定のアップデート</li>\n</ul></li>\n</ul><p>ここでいうループバックサーバーは、ランタイムと同じホストに立っていて、`miniflare`側でやってるストレージの永続化まわりに一役買ってるらしい。</p><p>ランタイムは、`workerd`を抱えたクラスで、`workerd`に渡す設定は、`.capnp`フォーマットの文字列ではなく、それのバイナリ表現になってた。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"Runtime\">`Runtime`</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/runtime/index.ts#L71\">https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/runtime/index.ts#L71</a></p>\n\n    </blockquote>\n<p>ついに本丸である。</p>\n\n<ul>\n<li>`#command`に、`workerd`のバイナリへのパスがある</li>\n<li>`#args`がGetterになっていて、`workerd serve`を呼ぶための引数が並んでる\n<ul>\n<li>`serve --binary --experimental`</li>\n<li>`--external-addr`でさっきのループバックサーバーを指定</li>\n</ul></li>\n<li>`updateConfig(newConfig)`されると、新たな設定で`workerd`のプロセスが`spawn()`される</li>\n</ul><p>というわけで、仕組みとしてはとてもシンプルだった。</p><p>KVなど各種バインディングの指定なんかは、バイナリの`.capnp`の中に記述されていて、`updateConfig()`で反映されるってわけ。</p><p>少し横道にそれるけど、`workerd`のコードを読んでみた限り、内部的にKVのKVSやR2のBLOBストレージの実装を持っているわけではなさそうだった。<br />\nそれらも結局は外部サービスのバインディングとして、`.capnp`で設定されてるだけ。</p><p>詳細はこっち。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2023/07/21/123425\">cloudflare/workerd &#x3092;&#x30BB;&#x30EB;&#x30D5;&#x30DB;&#x30B9;&#x30C8;&#x76EE;&#x7684;&#x3067;&#x4F7F;&#x3046; - console.lealog();</a></p>\n\n    </blockquote>\n<p>つまりは実装が別のどこかにあるわけで、それを`workerd`がホストしてるメインのWorkerスクリプトから呼び出してるだけ。<br />\nD1なんかにいたっては、JSで実装されたAPIを経由して、どこぞのSQLiteを呼び出しているっぽい。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workerd/blob/main/src/cloudflare/internal/d1-api.ts\">https://github.com/cloudflare/workerd/blob/main/src/cloudflare/internal/d1-api.ts</a></p>\n\n    </blockquote>\n<p>というわけで、`miniflare`には引き続きがっっっっっっっつりKVSやストレージの実装が残ってるし、そのあたりの連携を設定バイナリにまとめてる処理は、それぞれのプラグイン側でやってる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"各プラグイン\">各プラグイン</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/plugins/index.ts\">https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/plugins/index.ts</a></p>\n\n    </blockquote>\n<p>`Plugin`の実装は共通の型に沿うようになっていて、概ね以下の実装を持ってるイメージ。</p>\n\n<ul>\n<li>`router`: 各プラグインネームスペースごとに、オペレーションするハンドラ</li>\n<li>`gateway`: ハンドラが呼び出す実装の正体で、ストレージに直結してるやつ</li>\n<li>`getBindings()`: `.capnp`で定義されたスキーマに基づくデータ構造</li>\n<li>`getServices()`: `.capnp`で定義されたスキーマに基づくデータ構造</li>\n</ul><p>各プラグインの実装も、`workerd`がホストするメインのスクリプトから見ると、それぞれ単なるWorkerとして登録されてるだけ。</p>\n\n<ul>\n<li>cache</li>\n<li>d1</li>\n<li>do</li>\n<li>kv</li>\n<li>queues</li>\n<li>r2</li>\n</ul><p>このあたり全部そう。その実態は、さっきのループバックサーバーから、各プラグインのハンドラを`fetch()`するようになってるだけ。</p><p>`workerd`がホストするメインのスクリプトはココにある。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/workers/core/entry.worker.ts#L167\">https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/workers/core/entry.worker.ts#L167</a></p>\n\n    </blockquote>\n<p>さすが何度となくリライトされてるだけのことはあって、すごい正規化されてるし読みやすい・・・。勉強になる・・・。</p>\n\n<div class=\"section\">\n    <h4 id=\"ストレージ\">ストレージ</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/storage/storage.ts\">https://github.com/cloudflare/miniflare/blob/tre/packages/miniflare/src/storage/storage.ts</a></p>\n\n    </blockquote>\n<p>オンメモリか、FS上で永続化するかの2通りの実装がある。</p><p>内部的には`node:fs`と、`better-sqlite3`で成り立っていて、それぞれのプラグインが設定に応じて使い分けるようになってる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"まとめ\">まとめ</h3>\n    <p>`workerd`を使うことで実際のランタイムとのギャップは減った！という見方ができる一方で、実際にはグローバルオブジェクトの実装やらランタイムのAPIが`node:vm`から置き換わっただけって見方をすると、引き続きそれを取り巻くバインディング関連は依然としてオリジナルな実装のまま。</p><p>しかも残ってるやつらのほうが実装としてトリッキーになりやすい気がしていて、`miniflare`のコードもキレイではあるけどそれ相応に複雑なので、メンテするの大変そうやな・・・って。</p><p>ここまで一本化される日がくるとすれば、それはもうCloudflareのランタイムで実際に動いてるKVやR2やD1やDOやらの実装がローカルで動かせるようになる日ということで、「ポータブルなランタイムがついに全部入りになって、ローカルでも動くようになったぜ！」みたいな事態ってこと。</p><p>果たしてそんな日はくるのだろうか・・・。</p>\n\n</div>"
}
