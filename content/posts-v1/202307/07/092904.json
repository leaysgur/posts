{
  "title": "Cloudflare WorkersのService bindingsの現状整理",
  "html": "<p>2023年7月版ってことで。</p>\n\n    <blockquote>\n        <p><a href=\"https://developers.cloudflare.com/workers/platform/bindings/about-service-bindings/\">About Service bindings &middot; Cloudflare Workers docs</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3 id=\"これなに\">これなに</h3>\n    <p>とあるWorkerから、別のWorkerを呼び出せる仕組み。</p><p>前にも書いてるけど、デプロイしたWorkerAから別のWorkerBを呼びたいときがあったとしても、HTTP経由でさえそれができない場合があった。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2021/11/04/214157\">Cloudflare Workers&#x3067;&#x3001;Worker&#x304B;&#x3089;&#x5225;&#x306E;Worker&#x3092;&#x547C;&#x3073;&#x305F;&#x3044; - console.lealog();</a></p>\n\n    </blockquote>\n<p>複数のWorkerでマイクロサービス的な構成をしたい場合にもれなく不便やったけど、それができるようになる。<br />\n加えて、HTTP（インターネット）経由じゃなく、Cloudflare内の特別な経路を通るため、パフォーマンスも安定するよって触れ込み。</p><p>KVや他のバインディングと同じように登録しておくと、さもそこにWorkerがあるかのように`fetch()`できる。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synStatement\">&lt;</span>ExportedHandler<span class=\"synStatement\">&lt;</span><span class=\"synIdentifier\">{</span> MY_SVC: Fetcher <span class=\"synIdentifier\">}</span><span class=\"synStatement\">&gt;&gt;</span> <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">async</span> <span class=\"synSpecial\">fetch</span><span class=\"synStatement\">(</span>req<span class=\"synStatement\">,</span> env<span class=\"synStatement\">)</span> <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">return</span> <span class=\"synStatement\">await</span> env.MY_SVC.<span class=\"synSpecial\">fetch</span><span class=\"synStatement\">(</span>req<span class=\"synStatement\">);</span>\n  <span class=\"synIdentifier\">}</span><span class=\"synStatement\">,</span>\n<span class=\"synIdentifier\">}</span><span class=\"synStatement\">;</span>\n</pre>\n</div>\n<div class=\"section\">\n    <h3 id=\"制限と特徴\">制限と特徴</h3>\n    <p>Service bindingsをアーキテクチャに加えるか判断するために、知っておくべきことたちを、ドキュメントからサマリしておく。</p>\n\n<ul>\n<li>CPUリソースは、親（呼び出し元）のWorkerと共通\n<ul>\n<li>サービス側でのサブリクエストも、親の上限50と共通</li>\n<li>同時リクエスト数の6並列も親と共通</li>\n</ul></li>\n<li>`waitUntil()`か`await`しないと、親と共に消える</li>\n<li>サービスのネストは32層まで</li>\n</ul><p>などなど、基本的な理解として、呼び出し元の親Workerのリソースを消費するってところがポイント。</p><p>つまり、こういうサービスを書いたとして、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Sub</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synIdentifier\">{</span>\n  fetch: async () =&gt; <span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Service!&quot;</span>),\n<span class=\"synIdentifier\">}</span>\n</pre><p>それをService bindingsで呼び出す場合も、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Main</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synIdentifier\">{</span>\n  fetch: async (req, env) =&gt; env.MY_SVC.fetch(req),\n<span class=\"synIdentifier\">}</span>\n</pre><p>そのサービスのコードをモジュールとして使う場合も、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Main</span>\n<span class=\"synStatement\">import</span> MY_SVC from <span class=\"synConstant\">&quot;...&quot;</span>;\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> <span class=\"synIdentifier\">{</span>\n  fetch: async (req) =&gt; MY_SVC.fetch(req),\n<span class=\"synIdentifier\">}</span>\n</pre><p>できることは一緒ってことかと。（ネットワーキングのルートは違う）</p><p>つまり、CPUヘビーな処理を逃がす目的では使えない！<br />\nHTTP経由じゃない分のパフォーマンス向上はあるかもしれないが、そういう意味での違いは、Workerごとのバンドルサイズ制限（free: 1MB / Paid: 10MB）を回避できるってことくらい？</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"wrangler-devの対応状況\">`wrangler dev`の対応状況</h3>\n    <p>良し悪しはさておき、これを採用する場合は、ローカルで`wrangler dev`することになるはず。</p><p>手順としては、</p>\n\n<ul>\n<li>呼び出されるサービスを`wrangler dev`</li>\n<li>呼び出すメインのWorkerを`wrangler dev`</li>\n</ul><p>というように、複数のプロセスを立ち上げると自動で連携されて、ローカルで確認できるようになる。</p><p>注意点としては、メインの呼び出す側をどう起動したかによって、その挙動が変わるってところ・・・。</p><p>呼び出す側の親のWorkerの状態としては、この3つのパターンがあって、</p>\n\n<ul>\n<li>`wrangler dev`: dev@ローカル</li>\n<li>`wrangler dev --remote`: dev@リモート</li>\n<li>実際にデプロイされてる状態</li>\n</ul><p>それぞれこんな感じの対応だった。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>- O: main:dev@local  - sub:dev@local\n- X: main:dev@local  - sub:dev@remote\n- X: main:dev@local  - sub:deployed\n- X: main:dev@remote - sub:dev@remote\n- X: main:dev@remote - sub:dev@local\n- O: main:dev@remote - sub:deployed\n- O: main:deployed   - sub:deployed</pre><p>つまり、親がローカルだとローカルにあるサービスにしかつなげられないし、親がリモートだと実際にデプロイされてるサービスにしかつなげられない。</p>\n\n<ul>\n<li>`dev --remote`でサービスを立てても、それにアクセスする術がない</li>\n<li>`dev --remote`と`dev --local`を混ぜることもできない</li>\n</ul><p>という、かなりわかりにくい上に厳しい感じで、Issueもお察し。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/issues/1182\">RFC: Multi-worker development &middot; Issue #1182 &middot; cloudflare/workers-sdk &middot; GitHub</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h4 id=\"wranglerの内部実装について\">`wrangler`の内部実装について</h4>\n    <p>実は、`wrangler dev`すると、こっそり`:6284`ポートにも`express`のWebサーバーが起動してる。<br />\nこれが、ローカルで`wrangler dev`してるプロセスを中央管理する役目を負っていて、それによってローカルでもService bindingsが動くようになってるのである。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/cloudflare/workers-sdk/blob/9ae3d93e6070ab37e4261b2c5d6e8d91a4b1bcd7/packages/wrangler/src/dev-registry.ts\">https://github.com/cloudflare/workers-sdk/blob/9ae3d93e6070ab37e4261b2c5d6e8d91a4b1bcd7/packages/wrangler/src/dev-registry.ts</a></p>\n\n    </blockquote>\n<p>あれ、`workerd`さん・・・？</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"その他\">その他</h3>\n    \n<div class=\"section\">\n    <h4 id=\"TypeScriptの型\">TypeScriptの型</h4>\n    <p>`env.MY_SVC`をどういう型にすればいいかというと、`Fetcher`っていう型らしい。<br />\n（ただし`env.MY_SVC.constructor.name`は、ローカルでは`Object`のまま）</p><p>`Fetcher`は`fetch()`のほかに`connect()`っていうメソッドもあって、わかる人にはそういうことかって感じ。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"requrlどうなる\">`req.url`どうなる</h4>\n    <p>サービスは`fetch()`で呼び出すわけではあるが、そのリクエストの行き先はそのサービスって決まってるわけで。</p><p>ならリクエストされた側として、URLのオリジンとかどうなってんの？って思ったので調べてみたところ、</p>\n\n<ul>\n<li>リモートでは、呼び出し元と同じオリジンが入る（親と同じ）</li>\n<li>ローカルでは、そのサービスの起動オリジンのまま・・・</li>\n<li>オリジン以降のパスやらは、`env.MY_SVC.fetch()`時に渡した内容になる</li>\n</ul><p>サービスを呼び分けたい場合は、リクエストのパスか、ヘッダーか、ボディで。<br />\nブラウザでは許されるが、CFWの`fetch()`（というか`Request`もか）は、フルのURLでしか指定できないので、そこは注意。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// NG</span>\nenv.MY_SVC.fecth(<span class=\"synConstant\">&quot;/foo/bar?x=1&amp;yy&quot;</span>);\n\n<span class=\"synComment\">// OK</span>\nenv.MY_SVC.fecth(<span class=\"synConstant\">&quot;http://fake-host.example.com/foo/bar?x=1&amp;yy&quot;</span>);\n<span class=\"synComment\">// OK</span>\n<span class=\"synStatement\">const</span> req = <span class=\"synStatement\">new</span> Request(request, <span class=\"synIdentifier\">{</span> body: <span class=\"synConstant\">&quot;...&quot;</span> <span class=\"synIdentifier\">}</span>)\nenv.MY_SVC.fecth(req);\n</pre><p>なんでインターフェースを`fecth()`にしたんや？って気持ちはある。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"おわりに\">おわりに</h3>\n    \n<ul>\n<li>バンドルサイズの制限を回避したい</li>\n<li>チームの都合などで、モジュールでの共有は難しい</li>\n<li>HTTP経由になんらかの懸念がある</li>\n</ul><p>って場合にだけ（というかまぁ、マイクロサービスしたいときだけ？）、（なんかいろいろ不安定なのを）がんばって使えばいいけど、そうでないなら使わないやつかな・・・。</p><p>それでもがんばりたいあなたのために、拙作の`wrangler dev`ブリッジでは、local/remoteを混ぜて使えるようにしておきました。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/cfw-bindings-wrangler-bridge\">https://github.com/leader22/cfw-bindings-wrangler-bridge</a></p>\n\n    </blockquote>\n\n</div>"
}
