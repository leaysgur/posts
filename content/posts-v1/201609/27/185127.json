{
  "title": "0からはじめる MobX Part.3",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/mobxjs/mobx\">GitHub - mobxjs/mobx: Simple, scalable state management.</a></p>\n\n    </blockquote>\n<p>MobXの普及活動、Part.3です。</p><p>でもそもそもそんなに書くことないのでそろそろ終わってしまいそう・・！<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>ObseravableArray</h3>\n    <p>MobXでObservableにした値は、いちおう元の型っぽく振る舞うけど微妙に違う。<br />\nその代表例がコイツ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> arr = observable(<span class=\"synIdentifier\">[]</span>);\n\n<span class=\"synType\">Array</span>.isArray(arr); <span class=\"synComment\">// false</span>\n</pre><p>こういうの。</p><p>そして、Array.prototypeのメソッドはぜんぶ使えるけど、加えて以下も追加されてる。</p>\n\n<ul>\n<li>`clear()`: その名の通り、空っぽにする</li>\n<li>`replace()`: 渡した配列でまるっと置き換え</li>\n<li>`find()`: Array.findと一緒</li>\n<li>`remove()`: 渡したvalueを見つけて削除するやつ</li>\n<li>`peek()`: `slice()`と基本的には同じだが、以降の配列操作が認められなくなる</li>\n</ul><p>`peek()`について補足すると、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> x = y = mobx.observable(<span class=\"synIdentifier\">[</span>1, 2, 3<span class=\"synIdentifier\">]</span>);\n\nx.peek().push(4);\nx.push(4); <span class=\"synComment\">// throw error</span>\n\ny.slice().push(4);\ny.push(4); <span class=\"synComment\">// 問題ない</span>\n</pre><p>というわけで、</p>\n\n<ul>\n<li>`slice()`がコピーを返すのに対して、`peek()`はMobXが内部的に保持してる参照をそのまま返す（速度的に有利）</li>\n<li>そうして得た配列を変更しちゃうと、辻褄を保証できなくなってエラーになる</li>\n<li>なので使う時は注意して、パフォーマンスに困ってないなら`slice()`でだいたいなんとかなる</li>\n</ul><p><br />\nまぁいわゆるObservable系なライブラリとしてはお馴染みなインターフェースかなーと。<br />\nもちろん`push()`とか`pop()`とかおなじみのメソッドでデータを更新しても拾ってくれます。</p>\n\n    <blockquote>\n        <p>`Array.isArray()`したい派の人のために、v2.6.2から`isArrayLike()`ってメソッドが追加されました。</p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>ObservableMap</h3>\n    <p>MobXの最初のつまづきポイントであるオブジェクトに途中からキーを追加するやつ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 渡されたオブジェクトをただ表示するマン</span>\n<span class=\"synStatement\">const</span> Foo = observer((<span class=\"synIdentifier\">{</span> data <span class=\"synIdentifier\">}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> (\n    &lt;div&gt;<span class=\"synIdentifier\">{</span>JSON.stringify(data)<span class=\"synIdentifier\">}</span>&lt;/div&gt;\n  );\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// でも最初が空だと</span>\n<span class=\"synStatement\">const</span> data = observable(<span class=\"synIdentifier\">{}</span>);\n\n<span class=\"synComment\">// あれ？反映されない？</span>\ndata1.foo = <span class=\"synType\">Date</span>.now();\n</pre><p>`data`を宣言してる時点で存在しないキーは、後から追加しても反応してくれません。（他のキーの更新に紛れて反応してるように見えたりはする）</p><p>まぁそういう時に使うのがObservableMap。<br />\nふつうにオブジェクトを渡したときはObservableObjectといって別物なのでご注意。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// const data = observable({});</span>\n<span class=\"synComment\">// ではなく</span>\n<span class=\"synStatement\">const</span> data = observable(asMap(<span class=\"synIdentifier\">{}</span>));\n\n<span class=\"synComment\">// 反映される！</span>\ndata.set(<span class=\"synConstant\">'foo'</span>, <span class=\"synType\">Date</span>.now());\n</pre><p>ES6のMapに準拠してるとのことで、メソッドも同じものが使えます。ObservableArrayと同じく、追加のメソッドもあります。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Modifiers</h3>\n    <p>↑の例でもしれっとでてきた`asMap`みたいなやつのこと。<br />\nObservableな値を作るときに、その振る舞いを変えられる機能です。</p><p>他にもいくつかあるのでそれらを。</p>\n\n<div class=\"section\">\n    <h4>asFlat</h4>\n    <p>自分はObservable、配下はObservableにしない場合に。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Store <span class=\"synIdentifier\">{</span>\n  constructor() <span class=\"synIdentifier\">{</span>\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      arr1: <span class=\"synIdentifier\">[]</span>,\n      arr2: asFlat(<span class=\"synIdentifier\">[]</span>),\n      obj1: <span class=\"synIdentifier\">{}</span>,\n      obj2: asFlat(<span class=\"synIdentifier\">{}</span>),\n    <span class=\"synIdentifier\">}</span>);\n\n    <span class=\"synIdentifier\">this</span>.arr1.push(1);\n    <span class=\"synIdentifier\">this</span>.arr2.push(1);\n\n    <span class=\"synIdentifier\">this</span>.arr1.push(<span class=\"synIdentifier\">{</span> a: 1 <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">this</span>.arr2.push(<span class=\"synIdentifier\">{</span> a: 1 <span class=\"synIdentifier\">}</span>);\n\n    <span class=\"synIdentifier\">this</span>.obj1 = <span class=\"synIdentifier\">{</span> a: 1, b: <span class=\"synIdentifier\">{</span> c: 1 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>;\n    <span class=\"synIdentifier\">this</span>.obj2 = <span class=\"synIdentifier\">{</span> a: 1, b: <span class=\"synIdentifier\">{</span> c: 1 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>;\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> store = <span class=\"synStatement\">new</span> Store();\n\n<span class=\"synComment\">// true false true</span>\nconsole.log(isObservable(store.arr1), isObservable(store.arr1<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span>), isObservable(store.arr1<span class=\"synIdentifier\">[</span>1<span class=\"synIdentifier\">]</span>));\n<span class=\"synComment\">// true false false</span>\nconsole.log(isObservable(store.arr2), isObservable(store.arr2<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span>), isObservable(store.arr2<span class=\"synIdentifier\">[</span>1<span class=\"synIdentifier\">]</span>));\n\n<span class=\"synComment\">// true false true</span>\nconsole.log(isObservable(store.obj1), isObservable(store.obj1.a), isObservable(store.obj1.b));\n<span class=\"synComment\">// true false false</span>\nconsole.log(isObservable(store.obj2), isObservable(store.obj2.a), isObservable(store.obj2.b));\n</pre><p>というわけで、`asFlat()`で作ったオブジェクトの「配下のオブジェクト」が、Observableじゃなくなる。<br />\nサーバーからjsonデータをfetchしてぶっこんで表示用に使う、みたいなケースではコレを付けることが多いのではないかなーと。</p><p>個人的には一番よく使うModifierです。</p>\n\n</div>\n<div class=\"section\">\n    <h4>asReference</h4>\n    <p>そのまんまですが、Observableにしない場合。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Store <span class=\"synIdentifier\">{</span>\n  constructor() <span class=\"synIdentifier\">{</span>\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      data1: <span class=\"synIdentifier\">{}</span>,\n      data2: asReference(<span class=\"synIdentifier\">{}</span>),\n      data3: asFlat(<span class=\"synIdentifier\">{}</span>)\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> s = <span class=\"synStatement\">new</span> Store();\n\n<span class=\"synComment\">// Observableなのは</span>\ns.data1 = <span class=\"synIdentifier\">{</span> a: 1, b: <span class=\"synIdentifier\">{</span> x:2 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>; <span class=\"synComment\">// `data1`とその配下すべて</span>\ns.data2 = <span class=\"synIdentifier\">{</span> a: 1, b: <span class=\"synIdentifier\">{</span> x:2 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>; <span class=\"synComment\">// なし</span>\ns.data3 = <span class=\"synIdentifier\">{</span> a: 1, b: <span class=\"synIdentifier\">{</span> x:2 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>; <span class=\"synComment\">// `data3`だけ</span>\n</pre><p>ドキュメントには最も一般的とか書いてあったけど、まあならそもそもObservableにしなくて良いやんって感じではある。<br />\n<br />\n</p>\n\n</div>\n<div class=\"section\">\n    <h4>asStructure</h4>\n    <p>その名の通り、構造的にデータが変化したときだけ反応するようになる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Store <span class=\"synIdentifier\">{</span>\n  constructor() <span class=\"synIdentifier\">{</span>\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      screenSize: <span class=\"synIdentifier\">{</span>\n        width: 0,\n        height: 0\n      <span class=\"synIdentifier\">}</span>,\n      viewPortSize: asStructure(() =&gt; <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">return</span> <span class=\"synIdentifier\">{</span>\n          width:  Math.max(<span class=\"synIdentifier\">this</span>.screenSize.width,  1000),\n          height: Math.max(<span class=\"synIdentifier\">this</span>.screenSize.height, 800)\n        <span class=\"synIdentifier\">}</span>;\n      <span class=\"synIdentifier\">}</span>),\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> s = <span class=\"synStatement\">new</span> Store();\n\n<span class=\"synStatement\">window</span>.onresize = () =&gt; <span class=\"synIdentifier\">{</span>\n  transaction(() =&gt; <span class=\"synIdentifier\">{</span>\n    s.screenSize.width  = <span class=\"synStatement\">window</span>.innerWidth;\n    s.screenSize.height = <span class=\"synStatement\">window</span>.innerHeight;\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>普通にやってると、画面の`width`が1000↓、`height`が800↓のときでも`onresize()`が動いて、いっつも`{ width: 1000, height: 800 }`が返ってきちゃう。<br />\nでもそんな時は反応して欲しくない！ときに使うのがこのModifier。</p><p>もひとつ例を。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Store <span class=\"synIdentifier\">{</span>\n  constructor() <span class=\"synIdentifier\">{</span>\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      x: 0,\n      y: 0,\n      <span class=\"synComment\">// さっきと違う座標の時だけ反応</span>\n      ponit: asStructure(() =&gt; <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">return</span> <span class=\"synIdentifier\">[this</span>.x, <span class=\"synIdentifier\">this</span>.y<span class=\"synIdentifier\">]</span>;\n      <span class=\"synIdentifier\">}</span>),\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> s = <span class=\"synStatement\">new</span> Store();\n\n<span class=\"synStatement\">window</span>.onclick = (ev) =&gt; <span class=\"synIdentifier\">{</span>\n  transaction(() =&gt; <span class=\"synIdentifier\">{</span>\n    s.x = ev.x;\n    s.y = ev.y;\n  <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>`transaction()`はまとめてアップデートするための機能で、また次回以降に紹介します。</p><p>というわけで、</p>\n\n    <blockquote>\n        <p>入れ子のプロパティーを作ろうとするとasStructureという専用の構築子を要求されたりしだして、だるい感じ。</p><p><a href=\"http://qiita.com/mizchi/items/2b6de4e5a853f7a578a6\">MobX&#x3067;React&#x306E;&#x30B9;&#x30C6;&#x30FC;&#x30C8;&#x7BA1;&#x7406;&#x3092;&#x3059;&#x308B; - Qiita</a>より</p>\n\n    </blockquote>\n<p>これは何かの勘違いですね・・。</p><br />\n<p>ちなみに、`computed`とか`action`もModifierの仲間らしいけど、これもまぁまた次回以降に。</p>\n\n</div>\n</div>"
}
