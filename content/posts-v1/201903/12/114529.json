{
  "title": "addTransceiver() と addTrack() の使い分け",
  "html": "<p>`addStream()`は死にました。<br />\n5バージョンくらい前のChromeをサポートしたいとか理由がない限り、忘れてしまってよいです。</p><p>他人のコードを読んでてコレが出てきたら、メンテされてない or 古いバージョンをサポートしようとしてるの2択です。</p><p>これからのWebRTCでメディアを送りたい場合は、`addTrack()`か、`addTransceiver()`を使います。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>addTrack()</h3>\n    <p>一番よくあるであろう、`getUserMedia()`で取得したストリームをセットする場合のコードはこう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevieces.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span>, audio: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n  stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));\n<span class=\"synIdentifier\">}</span>());\n</pre><p>第2引数でその`MediaStreamTrack`が属する`MediaStream`を渡すのを忘れずに。<br />\n忘れるとFirefoxでエラーになります。</p><p>ほとんどのユースケースなら、オファー側もアンサー側もこれだけ使ってれば問題ないはず。</p><p>では`addTransceiver()`なんてAPIはいつ使うのか？</p>\n\n</div>\n<div class=\"section\">\n    <h3>addTransceiver()</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.addTrack(track, stream);\npc.addTransceiver(track, <span class=\"synIdentifier\">{</span> streams: <span class=\"synIdentifier\">[</span>stream<span class=\"synIdentifier\">]</span> <span class=\"synIdentifier\">}</span>);\n</pre><p> 実はこれ、ここだけ見ると同義のコードで、発行されるオファーSDPも同一です。<br />\n `addTransceiver()`の第2引数の渡し方がちょっと特殊なだけ。</p><p>ちなみにこっちを使う場合は、`streams`の指定を忘れてもFirefoxでエラーにならない。</p><p>つまり`addTrack()`は内部的に`addTransceiver()`してると、基本的には考えてしまっておっけー。</p><p>ただし注意すべき点があって、それに迫るのがこの記事の本旨です。</p>\n\n</div>\n<div class=\"section\">\n    <h3>受信のみ・送信のみモードのオファー</h3>\n    <p>`addTransceiver()`だからこそできることがあって、それが受信のみ・送信のみモードを実現したい場合。</p><p>だいたいのWebRTCのユースケースは送受信（`sendrecv`）だが、1:N配信などの場合にはそうしたくない。<br />\n受信のみとか送信のみとかがそれで、`recvonly`とか`sendonly`とかいう単語が出てくるやつ。</p><p>そこで、こういうコードを書くことになります。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 送信のみモードでオファー</span>\n(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevieces.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span>, audio: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n  stream.getTracks().forEach(track =&gt; pc.addTransceiver(track, <span class=\"synIdentifier\">{</span>\n    streams: <span class=\"synIdentifier\">[</span> stream <span class=\"synIdentifier\">]</span>,\n    direction: <span class=\"synConstant\">'sendonly'</span>\n  <span class=\"synIdentifier\">}</span>));\n\n  await pc.createOffer().then(offer =&gt; pc.setLocalDescription(offer));\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>());\n\n<span class=\"synComment\">// 受信のみモードでオファー</span>\n(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  pc.addTransceiver(<span class=\"synConstant\">'video'</span>, <span class=\"synIdentifier\">{</span> direction: <span class=\"synConstant\">'recvonly'</span> <span class=\"synIdentifier\">}</span>);\n  pc.addTransceiver(<span class=\"synConstant\">'audio'</span>, <span class=\"synIdentifier\">{</span> direction: <span class=\"synConstant\">'recvonly'</span> <span class=\"synIdentifier\">}</span>);\n\n  await pc.createOffer().then(offer =&gt; pc.setLocalDescription(offer));\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>());\n</pre><p>この書き方・挙動を実現するためには、`addTrack()`ではなく`addTransceiver()`を使うしかないというわけ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>受信のみ・送信のみモードのアンサー</h3>\n    <p>さっきのはオファー側で、今度はアンサー側の話。</p><p>1:1の場合、受信のみ・送信のみのユースケースの組み合わせは以下の通り。<br />\nOがオファー側、Aがアンサー側。</p>\n\n<ul>\n<li>O: 送信のみ x A: 受信のみ</li>\n<li>O: 受信のみ x A: 送信のみ</li>\n</ul><p>送信のみどうし・受信のみどうしのケースは、実際にはやる意味がない・・というか、やってみると`inactive`として扱われるので割愛。</p>\n\n<div class=\"section\">\n    <h4>受信のみのアンサー</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 受信のみモードでアンサー</span>\n(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synComment\">// ...</span>\n\n  await pc.setRemoteDescription(offer);\n  await pc.createAnswer().then(answer =&gt; pc.setLocalDescription(answer));\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>());\n</pre><p>受信のみで何も送らないのでもちろん`addTrack()`は不要。<br />\nそして書き忘れたとかではなく、`addTransceiver()`も不要です。</p><p>というのも、`RTCRtpTransceiver`が作られるタイミングがこの3つ。</p>\n\n<ul>\n<li>`addTrack()`したとき\n<ul>\n<li>後述しますが少し条件がある</li>\n</ul></li>\n<li>`addTransceiver()`したとき</li>\n<li>`setRemoteDescription()`したとき</li>\n</ul><p>このケースだと最後の`setRemoteDescription()`のタイミングで自動的に作られるから不要というわけ。<br />\nそして、その際に作られる`RTCRtpTransceiver`は`recvonly` = 受信のみモード。</p><p>むしろ自分で用意してしまうと、思ったように動かずなんで？ってなるはずです。（より正確には、自分で用意したやつは使われずに余ってるはず）</p>\n\n</div>\n<div class=\"section\">\n    <h4>送信のみのアンサー</h4>\n    <p>`setRemoteDescription()`で`RTCRtpTransceiver`が作られるという前提で読んでください。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 送信のみモードでアンサー</span>\n(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synComment\">// ...</span>\n\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevieces.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span>, audio: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n\n  await pc.setRemoteDescription(offer);\n\n  pc.getTransceivers().forEach(transceiver =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> kind <span class=\"synIdentifier\">}</span> = transceiver.receiver.track;\n    <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">[</span> track <span class=\"synIdentifier\">]</span> = kind === <span class=\"synConstant\">'video'</span> ? stream.getVideoTracks() : stream.getAudioTracks();\n    transceiver.sender.replaceTrack(track);\n    transceiver.direction = <span class=\"synConstant\">'sendonly'</span>;\n  <span class=\"synIdentifier\">}</span>);\n\n  await pc.createAnswer().then(answer =&gt; pc.setLocalDescription(answer));\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>());\n</pre><p>`setRemoteDescription()`で作られた`recvonly`な`RTCRtpTransceiver`を、送信のみ用に使い回すコードです。<br />\nなんで突然こんな複雑なコードに・・って感じですが、そういう仕様です。</p><p>`setRemoteDescription()`の前に、`sendonly`で`addTransceiver()`すればOKと思いがちですが、そうではないです。</p><p>その場合、送ろうと思っていた`MediaStreamTrack`は、SDPに紐付かない`RTCRtpTransceiver`として残ります。<br />\nそして、`setRemoteDescription()`で作成された`RTCRtpTransceiver`を使って、受信のみモードでP2Pがはじまります。</p><p>うーん、罠っぽい！けど、仕様としては正しい・・。<br />\nまぁご安心を。送信のみではなく、送受信モードで別にいい場合は、`addTrack()`が使えます。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 送受信モードでアンサー</span>\n(async <span class=\"synIdentifier\">function</span>() <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// sdpSemantics for Chrome M72未満</span>\n  <span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> sdpSemantics: <span class=\"synConstant\">'unified-plan'</span> <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synComment\">// ...</span>\n\n  <span class=\"synStatement\">const</span> stream = await navigator.mediaDevieces.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span>, audio: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n  stream.getTracks().forEach(track =&gt; pc.addTrack(track, stream));\n\n  await pc.setRemoteDescription(offer);\n  await pc.createAnswer().then(answer =&gt; pc.setLocalDescription(answer));\n\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>());\n</pre><p>`addTrack()`した上で`setRemoteDescription()`したら、余分な`RTCRtpTransceiver`が作られるのでは？と思ったあなたは勘がいいです。</p><p>が、実はこの`addTrack()`、「それ用の`RTCRtpTransceiver`が存在しなければ新規作成し、既に再利用可能な`RTCRtpTransceiver`があればそれを使い回す」ので、余分なやつは作られません。</p><p>ちなみに、`setRemoteDescription()`と`addTrack()`の呼び出し順も関係なく、いい感じになります。</p><p>もうひとつちなむと、送受信モードでアンサーしたところで意味がないです。<br />\nオファー側が受信のみモードのため、アンサー側としても受信するものがなく、結果的には送信のみモードでアンサーと同じ挙動になります。<br />\n（`RTCRtpTransceiver`の`direction`が`sendrecv`なままになるけど、実情を表す`currentDirection`が`sendonly`になる）</p><p>上の方で少し書いた、`sendonly`なオファーに対して`sendonly`でアンサーしようとすると`inactive`になるのと同じように、アンサーはあくまでオファーに対するアンサーなので、オファーを鑑みていい感じになる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n    <blockquote>\n        <p><a href=\"https://blog.mozilla.org/webrtc/rtcrtptransceiver-explored/\">Exploring RTCRtpTransceiver. - Advancing WebRTC</a></p>\n\n    </blockquote>\n<p>「addTrack (even addStream) is just a tweaked version of addTransceiver these days.」って言われてる通り、</p>\n\n<ul>\n<li>`addTrack()`がよしなにやってくれるAPI\n<ul>\n<li>ただし細かい指定はできない</li>\n</ul></li>\n<li>`addTransceiver()`は事細かに挙動をコントロールしたい場合に使うAPI\n<ul>\n<li>ただし`RTCRtpTransceiver`のことを知らないとハマる</li>\n</ul></li>\n</ul><p>という話でした。</p><p>今回はアンサー側を厚くあれこれ書きましたが、もちろんオファー側でも、`addTrack()`はよしなにやってくれます。<br />\n（`inactive`な`RTCRtpTransceiver`は使い回さないようになってたり）</p><p>まあ結局は、</p>\n\n<ul>\n<li>最終的なSDPに何が載るか</li>\n<li>適切な`RTCRtpTransceiver`とDOMにある`MediaStream(Track)`がちゃんと紐付いてるか</li>\n</ul><p>だけが全てなので、そこに至るまでのAPI呼び出しはなんでもいいです。</p><p>`addTrack()`だけを使って無駄なく`RTCRtpTransceiver`を作って、あとは`direction`を手動で修正するとか。<br />\nコードの統一感のために、`addTrack()`も`ontrack`も使わないとか。</p><p>まぁこんな細かいAPIの使い方はだいたいSDKがいい感じにしてくれてるはずで、だいたいのWebRTC使うぜ！って人には関係ないんですけど・・。</p>\n\n</div>"
}
