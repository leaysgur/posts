{
  "title": "OSSのWebRTC SFU mediasoup v3のコードを読む（サーバー/NodeJS編）",
  "html": "<p>クライアントは読んだので、次はサーバーを。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/02/25/144511\">OSS&#x306E;WebRTC SFU mediasoup v3&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080;&#xFF08;&#x30AF;&#x30E9;&#x30A4;&#x30A2;&#x30F3;&#x30C8;&#x7DE8;&#xFF09; - console.lealog();</a></p>\n\n    </blockquote>\n<p>こっちもまだ未リリースですが、読むだけなら損はないだろうという話。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>コードの入手</h3>\n    <p>先日`master`に入ったので、そのまま読めます。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/versatica/mediasoup/\">GitHub - versatica/mediasoup: Cutting Edge WebRTC Video Conferencing</a></p>\n\n    </blockquote>\n<p>`mediasoup`はNodeJSで書かれてる部分と、C++で書かれてる部分から成っているので、<br />\nとりあえずNodeで書かれてるパートを読んで、そこから察しつつ必要なら別記事でC++も見ていこうかと。</p><p>Nodeは`/lib`に、C++は`/worker/src`がメインのソースが置いてある。</p>\n\n</div>\n<div class=\"section\">\n    <h3>コードの雰囲気</h3>\n    <p>ファイルはこのように。（Node側だけ）</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── AudioLevelObserver.js\n├── Channel.js\n├── Consumer.js\n├── EnhancedEventEmitter.js\n├── Logger.js\n├── PipeTransport.js\n├── PlainRtpTransport.js\n├── Producer.js\n├── Router.js\n├── RtpObserver.js\n├── Transport.js\n├── WebRtcTransport.js\n├── Worker.js\n├── errors.js\n├── index.js\n├── ortc.js\n├── supportedRtpCapabilities.js\n└── utils.js</pre><p>というわけでクライアントよりも規模は大きい（C++側はもっと多い）ので、片っ端から読んでいくパターンはあまり効率がよくなさそう。</p><p>なので、先日デモ用途で用意した最低限の実装を足がかりにしていくことにする。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/mediasoup-demo-v3-simple\">GitHub - leader22/mediasoup-demo-v3-simple</a></p>\n\n    </blockquote>\n<p>サーバーサイドでやってることはざっくりこう。</p>\n\n<ul>\n<li>クライアントが接続してきたら\n<ul>\n<li>`Room`を作ってそこにいれる</li>\n<li>以後やりとりできるようWebSocketを張る</li>\n</ul></li>\n<li>WebSocket上での各種I/O\n<ul>\n<li>RtpCapabilitiesの連携</li>\n<li>WebRTCセッションの確立</li>\n<li>`Room`への参加</li>\n<li>`Room`へのメディアの送信・受信</li>\n</ul></li>\n</ul><p>詳細はサーバーサイドのコードを読むとして、登場するAPIやら概念を軽く追う。</p>\n\n</div>\n<div class=\"section\">\n    <h3>クライアントが接続してきたら</h3>\n    <p>まずはじめの処理、このリポジトリの`/server/server.js`でやってるだいたいの流れが以下。</p>\n\n<ul>\n<li>指定された数だけ、`meidasoup`の`Worker`を起動</li>\n<li>クライアントが接続してきたら、`Room`の概念を用意する\n<ul>\n<li>`mediasoup`ではなくアプリ側で</li>\n</ul></li>\n<li>各`Room`には単一の`Worker`をアサインする\n<ul>\n<li>その際、`Worker`の`createRouter()`を呼んで、以後はそれを`Room`内で扱う</li>\n<li>`Router`が実際の本丸</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>WebSocket上での各種I/O</h3>\n    <p>WebSocketは、`protoo`という作者謹製のWebSocketラッパーが使われてる。<br />\n送ったメッセージに対するレスポンスを`await`して待てるAPIが特徴的。</p><p>そんなWebSocketでやり取りされるメッセージの最低限が以下の通り。</p>\n\n<ul>\n<li>getRouterRtpCapabilities</li>\n<li>createWebRtcTransport</li>\n<li>connectWebRtcTransport</li>\n<li>join</li>\n<li>produce</li>\n</ul><p>これはあくまでデモのコードで使ってる切り口なのに注意。必要最低限ではあるけど。</p>\n\n<div class=\"section\">\n    <h4>getRouterRtpCapabilities</h4>\n    <p>これは`mediasoup`のお作法として必要なステップ。</p><p>サーバー側で対応しているメディアのコーデックやパラメータを、いったんクライアントに理解させるAPI。</p><p>`mediasoup-client`の`Device`クラスが`load()`する時にコレを使う。</p>\n\n</div>\n<div class=\"section\">\n    <h4>createWebRtcTransport / connectWebRtcTransport</h4>\n    <p>次にWebRTC的なセッションを確立する。</p><p>`Router`の`createWebRtcTransport()`で作っておいて、`transport.connect()`する。</p><p>`mediasoup`の用語で、メディアを送信することを`produce`といって、受信することを`consume`という。<br />\nそれぞれ`Producer`と`Consumer`が対応する概念で、それができるのが`Transport`という概念。</p>\n\n</div>\n<div class=\"section\">\n    <h4>join</h4>\n    <p>`Room`に入ってきたクライアントに対して、既に`Room`にいてメディアを送信しているピアの情報を伝える処理。</p><p>既に`Room`にいてメディアを送信しているピアの数だけ、`Consumer`を用意してメディアを受信してる。</p><p>APIとしては、`transport.consume()`が該当の処理。</p>\n\n</div>\n<div class=\"section\">\n    <h4>produce</h4>\n    <p>クライアントから送信されたメディアを扱う処理。</p><p>ここではサーバー側の`transport.produce()`を呼びつつ、`Room`内の他のピアのために`Consumer`を用意してる。</p><p>カンファレンスアプリのデモの場合、その`Room`に入った = 受信の意思があるとして`Consumer`を用意できることになる。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>どこから追うか</h3>\n    <p>以上の流れを踏まえると、コードリーディングのきっかけとして適当なのはこんな感じかなーと。</p>\n\n<ul>\n<li>`index.js`</li>\n<li>`Router.js`</li>\n<li>`WebRTCTransport.js`</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>`lib/index.js`</h3>\n    <p>まずはこの部分から。</p><p>エクスポートしてるのは、</p>\n\n<ul>\n<li>`version`\n<ul>\n<li>ただのバージョン番号</li>\n</ul></li>\n<li>`createWorker()`\n<ul>\n<li>さっきの`Worker`を作って返す処理で、`Promise`で`Worker`を返す</li>\n</ul></li>\n<li>`getSupportedMediaCodecs()`\n<ul>\n<li>起動時に指定できる対応コーデックやパラメータのリスト</li>\n</ul></li>\n<li>`observer`\n<ul>\n<li>各種イベントを拾える専用の`EventEmitter`</li>\n</ul></li>\n</ul><p>というわけで、もちろん`createWorker()`からスタート。</p><p>これは初期化した`Worker`の`@success`イベントを待って`resolve()`される。</p>\n\n<div class=\"section\">\n    <h4>`lib/Worker.js`</h4>\n    <p>`@success`が発火するまでを追う。</p>\n\n<ul>\n<li>`this._channel.once(this._pid)`で受けているイベント内で発火</li>\n<li>`this._channel`は、`this._child`で初期化される`Channel`クラス\n<ul>\n<li>`this._pid`が渡されてる</li>\n</ul></li>\n<li>`this._child`は、`child_process.spawn()`した子プロセス\n<ul>\n<li>`this._pid`は、この子プロセスの`pid`</li>\n<li>実行されるのはC++のmediasoupの`Worker`</li>\n<li>`worker/src/main.cpp`</li>\n</ul></li>\n<li>この子プロセスの`stdio[3]`が`Channel`クラスに渡ってる</li>\n</ul>\n<div class=\"section\">\n    <h5>`child_process.spawn()`のオプション</h5>\n    <p>`detached`と`stdio`の2つが重要。</p><p>`detached`は親プロセスとの関係性を定義してて、`false`の場合は`detach`しない = 親プロセスと生涯を共にする。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodejs.org/api/child_process.html#child_process_options_detached\">Child Process | Node.js v11.12.0 Documentation</a></p>\n\n    </blockquote>\n<p>`stdio`は親子間での入出力を制御するために指定するもの。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodejs.org/api/child_process.html#child_process_options_stdio\">Child Process | Node.js v11.12.0 Documentation</a></p>\n\n    </blockquote>\n<p>基本的には`stdin`、`stdout`、`stderr`の3種類に対して設定し、デフォルトはすべて`pipe`。</p><p>しかしここでは4つ目を指定してるのがミソで、そのFile Descriptorを介してNodeとC++がやり取りをする。<br />\nそれを担ってるのが`Channel`クラスという話。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>`lib/Channel.js`</h4>\n    \n<ul>\n<li>C++側と会話するためのクラス\n<ul>\n<li>`request()`で送信</li>\n<li>`this._socket.on('data')`で受信</li>\n</ul></li>\n<li>`request()`時は、`this._socket.write()`して書き込み\n<ul>\n<li>`this._sents`に送った内容を保持する</li>\n<li>いったん`Promise`を返す</li>\n</ul></li>\n<li>そして`this._socket.on('data')`で受け取る\n<ul>\n<li>C++側から書き込まれるのはJSONかログの2択</li>\n<li>JSONの場合は`this._sents`とレスを照合してさっきの`Promise`を`resolve()`する</li>\n<li>ログはそのまま出力</li>\n</ul></li>\n</ul><p>そういう意味での連絡チャンネルであり、深く追う必要はなさそう。</p><p>ともあれ無事にC++側の`Worker`が初期化されると、この`Channel`を通じて最初のメッセージが返ってくる。<br />\nそれを受けて`Worker`が`@success`を発火するという流れ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>`lib/Router.js`</h3>\n    <p>`Room`ごとにアサインされるNode側の`Worker`は、</p>\n\n<ul>\n<li>Node側に`Router`をつくり</li>\n<li>C++側に`Worker`を（子プロセスで）つくり</li>\n<li>両者を`Channel`でつなぐ</li>\n</ul><p>という感じで、Node側の窓口であるこの`Router`に生えてるのは次のとおり。</p>\n\n<ul>\n<li>`createXxxTransport()`\n<ul>\n<li>`WebRtcTransport`だけでなく、`PlainRtpTransport`と`PipeTransport`の3つある</li>\n</ul></li>\n<li>`pipeToRouter()`\n<ul>\n<li>`Router`と別の`Router`をつなげられるっぽい</li>\n</ul></li>\n<li>`createAudioLevelObserver()`\n<ul>\n<li>RTPからセッション内の音声のレベルを検知する仕組み</li>\n<li>`volume`/`silence`の2つのイベントが発行される</li>\n<li>実態はC++側</li>\n</ul></li>\n<li>`canConsume()`\n<ul>\n<li>クライアントが`consume()`したいといっても、実際にコーデックなどの条件を満たしてるか確認</li>\n</ul></li>\n</ul><p>`createXxxTransport()`で作ることのできる3種類を見ていく。</p>\n\n<div class=\"section\">\n    <h4>`WebRtcTransport`</h4>\n    \n<ul>\n<li>extends `Transport`</li>\n<li>WebRTC用でありブラウザとメディアを送受信する用</li>\n<li>`connect()`\n<ul>\n<li>DTLSのRoleとFingerprintで接続</li>\n</ul></li>\n<li>`restartIce()`\n<ul>\n<li>その名の通りICEのリスタート</li>\n</ul></li>\n</ul><p>などなど、APIはいろいろあるが基本的に`Channel`を経由していて、実態はC++側にある。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`PlainRtpTransport`</h4>\n    \n<ul>\n<li>extends `Transport`</li>\n<li>RTP用</li>\n<li>`connect()`\n<ul>\n<li>RTPを飛ばすIPとポートで接続</li>\n</ul></li>\n</ul><p>これを使うと、`ffmpeg`と連携してあれこれしたりできる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`PipeTransport`</h4>\n    \n<ul>\n<li>extends `Transport`</li>\n<li>`pipeToRouter()`する用\n<ul>\n<li>v3から追加された</li>\n</ul></li>\n</ul><p>`Router`どうしをつなぐユースケースって、データセンター間とかそういう感じかな？</p>\n\n</div>\n<div class=\"section\">\n    <h4>`Transport`</h4>\n    <p>すべての`XxxTransport`が継承するこいつ。</p>\n\n<ul>\n<li>`Producer`を返す`produce()`\n<ul>\n<li>`pause()`/`resume()`</li>\n</ul></li>\n<li>`Consumer`を返す`consume()`\n<ul>\n<li>`pause()`/`resume()`</li>\n<li>`setPreferredLayers()`</li>\n<li>`requestKeyFrame()`</li>\n</ul></li>\n</ul><p>これも結局の実態はC++側にある。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p>ファイルの一覧と、その用途のおさらい。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── AudioLevelObserver.js: RTPから直接音声の入力を調べて返す用\n├── Channel.js: NodeとC++の連絡用\n├── Consumer.js: メディア受信用のクラス\n├── EnhancedEventEmitter.js: Promiseが返せるEventEmitter\n├── Logger.js: ロギング用\n├── PipeTransport.js: RouterどうしをつなげるTransport\n├── PlainRtpTransport.js: RTPをやり取りするTransport\n├── Producer.js: メディア送信用のクラス\n├── Router.js: Node側の本丸\n├── RtpObserver.js: RTPを直接さわるときの基底クラス\n├── Transport.js: 各Transportの基底クラス\n├── WebRtcTransport.js: ブラウザとやり取りするTransport\n├── Worker.js: C++の子プロセスを抱えるクラスで、Routerを生み出す\n├── errors.js: エラー用のutils\n├── index.js: モジュールとしてのエクスポート\n├── ortc.js: RTPで使うパラメータや送受信の際のマッチングなどのutils\n├── supportedRtpCapabilities.js: サポートしているコーデックやパラメータの一覧\n└── utils.js: utils</pre><p>ぜんぶ同じディレクトリにいるけど、これでうっすら関係性が見えるはず・・！</p>\n\n<ul>\n<li>`Room`の概念は`mediasoup`本体にはない\n<ul>\n<li>v2まではあったらしいが、v3にはない</li>\n</ul></li>\n<li>基本的にC++側に実装の本体はある\n<ul>\n<li>Node側はブラウザや外界とのI/Oしか担当しない</li>\n<li>内部的な`Channel`で非同期にやりとりする</li>\n</ul></li>\n<li>ブラウザだけではなく、IP/ポートでRTPを直接やり取りすることもできる</li>\n<li>Node側では`Worker`と`Router`を作って、そこに各エンドポイントと`Transport`を確立\n<ul>\n<li>あとは`Transport`上で、`Producer`と`Consumer`を任意に用意してメディアを流す</li>\n</ul></li>\n</ul><p>細かいユースケースまで見ていけば、ここでこういう処理をしてるのにはこういう理由がある！とかまで追えるけど、あくまでOverviewがこのシリーズの目的なので、詳細度はこれくらいで。</p><p>さて・・、C++側も読むしかないなーという感じ。（ただ実際すらすら読めないので、社内の優秀な若者に代読してもらって相槌を打って理解したい気持ち）</p>\n\n</div>"
}
