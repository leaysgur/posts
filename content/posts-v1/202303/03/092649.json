{
  "title": "ブラウザで動くSQLite alternativesとしてのLovefield",
  "html": "<p>タイトルはさておき、LovefieldというSQLライクなAPIが使えるライブラリがあって、個人的に便利だったので。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3 id=\"Lovefieldとは\">Lovefieldとは</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/google/lovefield\">https://github.com/google/lovefield</a></p>\n\n    </blockquote>\n\n<ul>\n<li>Google製で</li>\n<li>Pure JSの</li>\n<li>クロスブラウザーで動作する</li>\n<li>SQLライクなAPIが使えるリレーショナルデータベース</li>\n</ul><p>っていうライブラリ。</p><p>実績としてはGmailで使われてたらしい。（現在もそうなのかは不明）</p>\n\n    <blockquote>\n        <p>Is Lovefield production quality?<br />\nYes. As of May 2016, Inbox by GMail heavily relies on Lovefield to perform complex client-side structural data queries.<br />\n<a href=\"https://github.com/google/lovefield/blob/master/docs/FAQ.md#is-lovefield-production-quality\">https://github.com/google/lovefield/blob/master/docs/FAQ.md#is-lovefield-production-quality</a></p>\n\n    </blockquote>\n<p>（コードが書かれたのは主に2015年頃らしいなので、今さらも今さらなネタではある。けど、そもそも日本でそんなに話題になってなかった気がする？）</p>\n\n<div class=\"section\">\n    <h4 id=\"Public-archiveだが\">Public archiveだが</h4>\n    <p>リポジトリがアーカイブ状態になってるやん！って思いますよね？私は思いました。</p><p>これも中の人によると、</p>\n\n    <blockquote>\n        <p>Lovefield is under long-term maintenance but there will be no new features (i.e. feature freeze). G-Mail is using it and as long as G-Mail is still using it we'll keep supporting it. There are not many updates because Lovefield has very few bugs (G-Mail only managed to find 7 bugs during their whole usage, and they are all fixed of course).<br />\n<a href=\"https://github.com/google/lovefield/issues/266#issuecomment-678883485\">https://github.com/google/lovefield/issues/266#issuecomment-678883485</a></p>\n\n    </blockquote>\n<p>という感じで、機能追加の予定がないからアーカイブってだけで、バグってるとかメンテされてないとかそういうわけではないとのこと。</p><p>（このコメントは2020年なので、しれっとGmailは2020年でもLovefieldを使ってた情報が更新されてる）<br />\n<br />\n</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"Lovefield-TS\">Lovefield-TS</h3>\n    <p>さっきのコメントにもあるけど、GoogleとしてのLovefieldの開発は終わってるけど、中の人が個人的にTypeScriptにポートしたリライト版がある。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/arthurhsu/lovefield-ts\">https://github.com/arthurhsu/lovefield-ts</a></p>\n\n    </blockquote>\n<p>サポートブラウザがよりモダンに限定されてたりNode.jsでも動くようになってたり、本家とは微妙にAPIが変わったりしてるらしいけど、今から使うならこっちでよさそう。</p><p>というわけで、`lovefield-ts`をnpmからいつもどおりインストールして使えばよい。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"モチベーション\">モチベーション</h3>\n    <p>そもそもなぜブラウザでSQL？ってところに関しては、まあそうしたい理由があったからってだけなので割愛するとして。</p><p>最近ならSQLiteのWASM版を動かすっていう選択肢もあるし、Lovefieldの他にも似たようなライブラリはある。そんな中での差別化ポイントとしては、やはり軽いことと依存がないってところ。</p><p>SQLiteのWASM版はbr圧縮でも最低300KBくらいかかるし、他のライブラリたちもそれなりに重い。インメモリでだけ使いたいのに、そう設定してもIndexedDB（FirefoxのPrivateモードで使えない）が必要だったりと、いまいちハマらなかった。その点Lovefield-TSだと依存なしで最大50KB（Tree-shakingされたらもっと小さい）で済む。</p><p>SQLite互換なAPIが必要というよりは、単にRDBライクなシンタックスであればなんでもよかった。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"基本的な使い方\">基本的な使い方</h3>\n    <p>Lovefield本家はドキュメントがとにかくわかりにくい（個人の感想です）しコードのシンタックスも古いので、Lovefield-TSのリポジトリの`docs`配下を参照するのがもっともよいかと。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/arthurhsu/lovefield-ts/blob/master/docs/index.md\">https://github.com/arthurhsu/lovefield-ts/blob/master/docs/index.md</a></p>\n\n    </blockquote>\n<p>いちおう最低限のコードも載せておくと。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> schema<span class=\"synStatement\">,</span> Type<span class=\"synStatement\">,</span> DataStoreType <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">from</span> <span class=\"synConstant\">&quot;lovefield-ts/dist/es6/lf&quot;</span>\n\n<span class=\"synComment\">// 1. Create tables</span>\n<span class=\"synType\">const</span> builder <span class=\"synStatement\">=</span> schema.create<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;my-db&quot;</span><span class=\"synStatement\">,</span> <span class=\"synConstant\">1</span><span class=\"synStatement\">);</span>\nbuilder\n  .createTable<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;items&quot;</span><span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;id&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;title&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">,</span> Type.NUMBER<span class=\"synStatement\">)</span>\n  .addColumn<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;url&quot;</span><span class=\"synStatement\">,</span> Type.STRING<span class=\"synStatement\">)</span>\n  .addNullable<span class=\"synStatement\">(</span><span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;url&quot;</span><span class=\"synIdentifier\">]</span><span class=\"synStatement\">)</span>\n  .addPrimaryKey<span class=\"synStatement\">(</span><span class=\"synIdentifier\">[</span><span class=\"synConstant\">&quot;id&quot;</span><span class=\"synIdentifier\">]</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// 2. Connect to instance(default is `INDEXED_DB`)</span>\n<span class=\"synType\">const</span> db <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> builder.connect<span class=\"synStatement\">(</span><span class=\"synIdentifier\">{</span> storeType: DataStoreType.MEMORY <span class=\"synIdentifier\">}</span><span class=\"synStatement\">);</span>\n\n<span class=\"synComment\">// 3. Insert data</span>\n<span class=\"synType\">const</span> items <span class=\"synStatement\">=</span> db.getSchema<span class=\"synStatement\">()</span>.table<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;items&quot;</span><span class=\"synStatement\">);</span>\n<span class=\"synType\">const</span> itemsRows <span class=\"synStatement\">=</span> <span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n<span class=\"synStatement\">for</span> <span class=\"synStatement\">(</span><span class=\"synType\">const</span> data <span class=\"synStatement\">of</span> DATA<span class=\"synStatement\">)</span> <span class=\"synIdentifier\">{</span>\n  itemsRows.push<span class=\"synStatement\">(</span>items.createRow<span class=\"synStatement\">(</span>data<span class=\"synStatement\">));</span>\n<span class=\"synIdentifier\">}</span>\n<span class=\"synStatement\">await</span> db.insert<span class=\"synStatement\">()</span>.into<span class=\"synStatement\">(</span>items<span class=\"synStatement\">)</span>.values<span class=\"synStatement\">(</span>itemsRows<span class=\"synStatement\">)</span>.exec<span class=\"synStatement\">();</span>\n\n<span class=\"synComment\">// 4. Query</span>\n<span class=\"synType\">const</span> rows <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> db\n  .select<span class=\"synStatement\">(</span>\n    items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;title&quot;</span><span class=\"synStatement\">),</span>\n    items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">)</span>\n  <span class=\"synStatement\">)</span>\n  .<span class=\"synStatement\">from(</span>items<span class=\"synStatement\">)</span>\n  .where<span class=\"synStatement\">(</span>items.col<span class=\"synStatement\">(</span><span class=\"synConstant\">&quot;count&quot;</span><span class=\"synStatement\">)</span>.gt<span class=\"synStatement\">(</span><span class=\"synConstant\">4</span><span class=\"synStatement\">))</span>\n  .exec<span class=\"synStatement\">()</span>\n  .then<span class=\"synStatement\">((</span>rows<span class=\"synStatement\">)</span> <span class=\"synStatement\">=&gt;</span> <span class=\"synComment\">/** @type {{ title: string; count: number }[]} */</span> <span class=\"synStatement\">(</span>rows<span class=\"synStatement\">));</span>\n</pre><p>という感じ。直感的でよい。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"気になったところ\">気になったところ</h3>\n    \n<div class=\"section\">\n    <h4 id=\"importまわり\">importまわり</h4>\n    <pre class=\"code\" data-lang=\"\" data-unlink>├── LICENSE\n├── README.md\n├── dist\n│   ├── es5\n│   │   ├── lf.d.ts\n│   │   ├── lf.d.ts.map\n│   │   ├── lf.js\n│   │   └── lf.js.map\n│   ├── es6\n│   │   ├── lf.d.ts\n│   │   ├── lf.d.ts.map\n│   │   ├── lf.js\n│   │   └── lf.js.map\n│   └── lf.ts\n├── index.js\n└── package.json</pre><p>npmへはこういうファイル構成で配布されてて、`from \"lovefield-ts\"`で`import`すると全部いりの`dist/es5/lf`が降ってくるようになってる。</p><p>なのでTree-shakingのためには、`from \"lovefield-ts/dist/es6/lf\"`ってやるか、`\"lovefield-ts/dist/lf\"`のTSを直で参照してこっちでコンパイルするかになる。</p><p>このへんの挙動はバンドラの設定とかでも微妙に変わるはずで、なんしか試行錯誤が少し必要になってなんだかな・・ってちょっとなった。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"型のサポート\">型のサポート</h4>\n    <p>TSで書かれてるけど、ジェネリクスで定義されてないAPIが結構あって、利用者サイドの型を楽につけられないことが多かった。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synComment\">// これとか</span>\nitems.createRow<span class=\"synStatement\">(</span>data<span class=\"synStatement\">);</span> <span class=\"synComment\">// Table.createRow(value?: object | undefined): Row</span>\n\n<span class=\"synComment\">// これとか</span>\n<span class=\"synType\">const</span> rows <span class=\"synStatement\">=</span> <span class=\"synStatement\">await</span> db\n  .select<span class=\"synStatement\">()</span>\n  .<span class=\"synStatement\">from(</span>items<span class=\"synStatement\">)</span>\n  .exec<span class=\"synStatement\">();</span> <span class=\"synComment\">// QueryBuilder.exec(): Promise&lt;unknown&gt;</span>\n</pre><p>別にキャストすればいいけど、ちょっと物足りない。あとはカラム名の入力補完も効かない。</p>\n\n</div>\n<div class=\"section\">\n    <h4 id=\"あくまでSQLライク\">あくまでSQLライク</h4>\n    <p>そこまで使い込んだわけではないけど、いわゆるSQLでいうアレ、できないの？ってなったところ。</p>\n\n<ul>\n<li>`JOIN`は`INNER`と`LEFT OUTER`だけ</li>\n<li>`DISTINCT`で対象にできるカラムが1つだけ</li>\n<li>`HAVING`はサポートされてない</li>\n</ul><p>でもまあこれくらいかも。ヘビーなクエリは書いてないので。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3 id=\"おわりに\">おわりに</h3>\n    <p>ここで書いてるほかにも、</p>\n\n<ul>\n<li>import/export</li>\n<li>バージョンニングとマイグレーション</li>\n<li>トランザクション</li>\n</ul><p>などなど、いろいろサポートされてるので、また別の機会で使ってみたい一品だったという話でした。</p>\n\n</div>"
}
