{
  "title": "Cleaner, more elegant, and ... の、例外とエラーの話",
  "html": "\n<ul>\n<li><a href=\"https://devblogs.microsoft.com/oldnewthing/20040422-00/?p=39683\">Cleaner, more elegant, and wrong - The Old New Thing</a></li>\n<li><a href=\"https://devblogs.microsoft.com/oldnewthing/20050114-00/?p=36693\">Cleaner, more elegant, and harder to recognize - The Old New Thing</a></li>\n</ul><p>という、似たようなタイトルの記事が2つありまして。<br />\nどちらもマイクロソフト社のレイモンド・チェン氏が書いたもの。</p>\n\n    <blockquote>\n        <p>氏は、「キーボードが動かない！（本当は刺さってないから）」っていうクレームに対して、「ちゃんとつながってます？」って聞くのではなく、「接点にゴミがついて接続が弱くなることがあるので、一回抜き差ししてもらえます？」って聞くと、結果どうあれうまくいくよ〜っていう逸話のあの人です。</p>\n\n    </blockquote>\n<p>少し古い記事やけど、そうそう自分が最近考えてたのもこういうことなんですよ・・・って思ったので、その備忘としても要点をメモっておく。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>Cleaner, more elegant, and wrong</h3>\n    \n    <blockquote>\n        <p><a href=\"https://devblogs.microsoft.com/oldnewthing/20040422-00/?p=39683\">Cleaner, more elegant, and wrong - The Old New Thing</a></p>\n\n    </blockquote>\n<p>とあるC#のプログラミング本で紹介されてたスニペットが、クリーンでエレガント・・・かもしれないが、間違ってる！っていう話。</p><p>その疑惑のコードがこちら。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink><span class=\"synStatement\">try</span> {\n  AccessDatabase accessDb = <span class=\"synStatement\">new</span> AccessDatabase();\n  accessDb.GenerateDatabase();\n} <span class=\"synStatement\">catch</span> (Exception e) {\n  <span class=\"synComment\">// ここで例外を処理</span>\n}\n\n<span class=\"synType\">public</span> <span class=\"synType\">void</span> GenerateDatabase()\n{\n  CreatePhysicalDatabase();\n  CreateTables();\n  CreateIndexes();\n}\n</pre><p>本では、こうすればなにかあってもいい感じに例外を処理できる！例外ってすばらしい！って紹介されてるが、実際は、そんなことないじゃろ、と。</p><p>というのも、`GenerateDatabase()`がやってる3つの処理のうち、2つ目とか3つ目で例外が起きたらどうするの？<br />\nDBつくって、テーブルつくったけど、インデックスを張ろうとして失敗したらどうなるの？</p><p>このコードの通りに呼び出し元で例外をキャッチしたとしても、どの時点までロールバックが必要なのかもわからない。</p><p>そういうわけで、\"いつどこで起きるかわからない\"例外を、エラーハンドリングに使うのは、難易度が高いことだと割り切ったほうがよいという話。</p><p>これも良くないコードの例。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>Guy AddNewGuy(<span class=\"synType\">string</span> name)\n{\n  Guy guy = <span class=\"synStatement\">new</span> Guy(name);\n  AddToLeague(guy);\n  guy.Team = ChooseRandomTeam();\n  <span class=\"synStatement\">return</span> guy;\n}\n</pre><p>このコードにもさっきの考え方は流用できて、まだこうするほうがマシ。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>Guy AddNewGuy(<span class=\"synType\">string</span> name)\n{\n  Guy guy = <span class=\"synStatement\">new</span> Guy(name);\n  guy.Team = ChooseRandomTeam();\n  AddToLeague(guy);\n  <span class=\"synStatement\">return</span> guy;\n}\n</pre><p>つまり、「コードは副作用がない順に実行していって、状態の確定は最後にまとめてやれ」ということ。<br />\nそうすれば最初のほうで例外があっても、ロールバックは必要なくて良くなる（と見なせる）。</p><p>ただまあ実際はそんな単純ではなく、さっきのコードにもいつの間にか修正が入って、こうなってしまったりする・・・。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>Guy AddNewGuy(<span class=\"synType\">string</span> name)\n{\n  Guy guy = <span class=\"synStatement\">new</span> Guy(name);\n  guy.Team = ChooseRandomTeam();\n  guy.Team.Add(guy);\n  AddToLeague(guy);\n  <span class=\"synStatement\">return</span> guy;\n}\n</pre><p>言いたいことはわかりますね？</p>\n\n</div>\n<div class=\"section\">\n    <h3>Cleaner, more elegant, and harder to recognize</h3>\n    \n    <blockquote>\n        <p><a href=\"https://devblogs.microsoft.com/oldnewthing/20050114-00/?p=36693\">Cleaner, more elegant, and harder to recognize - The Old New Thing</a></p>\n\n    </blockquote>\n<p>前回の記事を、例外への批難のようなメッセージだと解釈した人たちがいる。<br />\nけどそうは言ってないのである。</p><p>例外を正しく扱った良いコードを書くことは、可能だけれども難しいことだと言っただけ。<br />\nそして難易度が高いからといって、やってはいけない・やれないことではない。（そういうことは世の中にもいっぱいあるので）</p><p>そして、例外を使わず、エラーを返してコードをチェックする方式にしたとしても、良いコードになる保証はない。</p><p>ただ例外を使う場合は、ほんとに全ての行で例外が発生しないかどうか、そしてどんな対応が必要かを常に意識しながらコードを書く必要があって、それが難しいと思っている。</p><p>エラー（とコード）を、それが生まれる可能性がある場所でだけチェックするほうがまだ簡単。</p><p>エラー（とコード）を使ったコードの良し悪しを見分けることに比べると、例外を使ったコードの良し悪しを見分けることは、もっと難しい。</p><p>例えばこれは、エラー（とコード）を使った悪いコードの例。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>BOOL ComputeChecksum(LPCTSTR pszFile, DWORD* pdwResult)\n{\n  HANDLE h = CreateFile(\n    pszFile, GENERIC_READ, FILE_SHARE_READ,　NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL\n  );\n  HANDLE hfm = CreateFileMapping(h, NULL, PAGE_READ, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, NULL);\n  <span class=\"synType\">void</span> *pv = MapViewOfFile(hfm, FILE_MAP_READ, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>);\n  DWORD dwHeaderSum;\n  CheckSumMappedFile(pvBase, GetFileSize(h, NULL), &amp;dwHeaderSum, pdwResult);\n  UnmapViewOfFile(pv);\n  CloseHandle(hfm);\n  CloseHandle(h);\n  <span class=\"synStatement\">return</span> TRUE;\n}\n</pre><p>何が悪いかというと、一切エラーをチェックしてないから。一目瞭然である。</p><p>チェックするようにしたら、こうなる。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>BOOL ComputeChecksum(LPCTSTR pszFile, DWORD* pdwResult)\n{\n  BOOL fRc = FALSE;\n  HANDLE h = CreateFile(\n    pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL\n  );\n  <span class=\"synStatement\">if</span> (h != INVALID_HANDLE_VALUE) {\n    HANDLE hfm = CreateFileMapping(h, NULL, PAGE_READ, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, NULL);\n    <span class=\"synStatement\">if</span> (hfm) {\n      <span class=\"synType\">void</span> *pv = MapViewOfFile(hfm, FILE_MAP_READ, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>, <span class=\"synConstant\">0</span>);\n      <span class=\"synStatement\">if</span> (pv) {\n        DWORD dwHeaderSum;\n        <span class=\"synStatement\">if</span> (\n          CheckSumMappedFile(pvBase, GetFileSize(h, NULL), &amp;dwHeaderSum, pdwResult)\n        ) {\n          fRc = TRUE;\n        }\n        UnmapViewOfFile(pv);\n      }\n      CloseHandle(hfm);\n    }\n    CloseHandle(h);\n  }\n  <span class=\"synStatement\">return</span> fRc;\n}\n</pre><p>もちろん改善の余地はあるけど、悪くないコードだとわかる。</p><p>それに対して、この（急いで書いたであろう）例外ベースのコードに、前回の記事の考え方を適用した状態のコードがある。</p>\n<pre class=\"code lang-cs\" data-lang=\"cs\" data-unlink>NotifyIcon CreateNotifyIcon()\n{\n NotifyIcon icon = <span class=\"synStatement\">new</span> NotifyIcon();\n icon.Text = <span class=\"synConstant\">&quot;Blah blah blah&quot;</span>;\n icon.Icon = <span class=\"synStatement\">new</span> Icon(GetType(), <span class=\"synConstant\">&quot;cool.ico&quot;</span>);\n icon.Visible = <span class=\"synConstant\">true</span>;\n <span class=\"synStatement\">return</span> icon;\n}\n</pre><p>さて、これは悪いコードか、悪くないコードかわかりますか？見分けるのはとても困難のはず。（この見える範囲でキャッチされてないだけで、どこか上層でキャッチされてるかもしれないけど、それはここではわからない）</p><p>なので例外を使ってコードを書く場合、あとでリファクタしようと思ってはいけない。</p>\n\n</div>\n<div class=\"section\">\n    <h3>例外を投げるか、エラー（とコード）を返すか</h3>\n    <p>という感じで、言いたいことはわかるけど、正解は教えてくれないんですね〜は〜んって感じの2記事だったｗ</p><p>まぁこの2つの記事で、氏が言いたかったことはたぶんこういうことかなー。</p>\n\n<ul>\n<li>（往々にしてロールバックが必要になるような）エラーは、そのスコープで即座に処理されているべき\n<ul>\n<li>見えるところにそのコードが書かれているべき</li>\n</ul></li>\n<li>エラー（とコード）を返す場合、その場で処理してる or NOTは明確にわかる\n<ul>\n<li>この場合は型としても不定にできるはず</li>\n</ul></li>\n<li>例外を投げる場合は、一見してそれが処理されてるのかはわからない\n<ul>\n<li>トップレベルのコードならまだしもだいたいは下層のコードのはず</li>\n</ul></li>\n</ul><p>`await`を見たら`catch`してるか確認する癖をつけろ！みたいな話でもありつつ、どの行からも例外が投げられる可能性があるがゆえに、すべてのコードパスを把握する必要があり、それが人類には難しいことである、と。</p><p>それはすごいわかるなーと思ったし、例外がないGoみたいな言語がわかりやすいって言われる側面の一つでもありそう。もちろん反対意見があるのも承知の上で、でも個人的には割と好感を持ってるところ。</p><p>こと例外が言語仕様として存在してしまってるJavaScript界隈に身をおいてる身としては、例外を禁止することができない（すべてのローレベルなオペレーションをラップする気概はないので）以上、難しいことであるのは受け入れつつ、がんばって注意して扱うしかないのかなーと。</p><p>ちなみに最近の個人的なポリシーは、</p>\n\n<ul>\n<li>自分で生成した`Error`は、`throw`せずに`return`する</li>\n<li>`catch`されるのは、本当に例外的に発生してしまったものだけ\n<ul>\n<li>つまりネットワークが不通であるとか、事前に保証できない+どうしようもない異常系だけ</li>\n<li>それ以外の準正常系は`return`して対処する</li>\n</ul></li>\n<li>ローレベルな処理では引き続き`throw`することもある\n<ul>\n<li>この線引が難しいってことやね・・</li>\n</ul></li>\n</ul><p>という感じでやってることが多いかも。<br />\n少なくとも自分で`throw`を書いてない以上、どこかで`catch`することがあれば、それは完全にバグであると断定できるようになるはずなので。</p><p>言ってしまえば例外（というか`throw`）って、ラベルのないGOTO文みたいなもんやし、扱いが難しいのはまあ当然というか・・。<br />\nならエラーを返すように徹したほうが、脳内メモリは少なくて済むってのもごもっともで。</p><p>まぁ昨今のJavaScript界隈は、`Promise`を`throw`するとかいう事態になってるけどな・・・！</p>\n\n</div>"
}
