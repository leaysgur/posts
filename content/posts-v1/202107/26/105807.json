{
  "title": "miniflare のコードを読む",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/mrbbot/miniflare\">https://github.com/mrbbot/miniflare</a></p>\n\n    </blockquote>\n<p>Cloudflare Workers（以下、CFW）相当の実行環境をローカルで再現できるアレです。</p><p>そんなんは公式が出してほしいな〜と思い続けてはや1年弱、いつまで経っても出てこない！<br />\nというわけで、コード読んでみたシリーズです。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>そもそも、なぜローカルで動かしたいのか</h3>\n    <p>これはひとえに、現状のCFWはローカルで開発できないから。</p><p>いちおう本家のCLIに`wrangler dev`という開発用のコマンドはあるけど、インターネットにプライベートなやつがデプロイされてそれを`localhost`にトンネルするだけで、実質ローカルではない。</p><p>そのうえ、</p>\n\n<ul>\n<li>（インターネットに上げるからか）動作も速くない</li>\n<li>そしてとにかくクラッシュする</li>\n<li>変更も反映されたりされなかったり謎</li>\n<li>そのくせしっかり課金対象（無料枠の圧迫）</li>\n</ul><p>という感じで、あまり快適な開発体験とは言えないかなーというのが正直なところ。<br />\nもちろんあらゆるものが本番想定のインフラで動かせるというところにやや便利さはあるけど・・。</p><p>で、なんとかしたいなーとは思うものの、CFWの実行環境は「V8 Isolate + Cloudflare独自API」というちょっと特殊な感じになっていて、もちろんNodeでそのまま動くわけもなく。<br />\nってなところで、力ずくでそれをやり遂げてNodeで動いちゃってるこの`miniflare`はすごいのである！</p><p>というわけで、読んでいきます。<br />\nコードはTypeScriptで書かれてるので、気合さえあれば読めるやつ。</p><p>この記事を書いた時点のバージョンは`1.3.2`でした。</p>\n\n</div>\n<div class=\"section\">\n    <h3>外観</h3>\n    <p>`miniflare`は、CLIとしても使えるほか、プログラムからも利用できる。</p><p>CLIなら`miniflare worker.js`のようにするし、プログラムからならこのように。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> Miniflare <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;miniflare&quot;</span>;\n\n<span class=\"synStatement\">const</span> mf = <span class=\"synStatement\">new</span> Miniflare(<span class=\"synIdentifier\">{</span>\n  script: `\n  addEventListener(<span class=\"synConstant\">&quot;fetch&quot;</span>, (<span class=\"synStatement\">event</span>) =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">event</span>.respondWith(<span class=\"synStatement\">new</span> Response(<span class=\"synConstant\">&quot;Hello Miniflare!&quot;</span>));\n  <span class=\"synIdentifier\">}</span>);\n  `,\n<span class=\"synIdentifier\">}</span>);\n<span class=\"synStatement\">const</span> res = await mf.dispatchFetch(<span class=\"synConstant\">&quot;http://localhost:8787/&quot;</span>);\nconsole.log(await res.text()); <span class=\"synComment\">// Hello Miniflare!</span>\n</pre><p>CLIは結局ラッパーなはずで、`Miniflare`クラスのために便利な初期設定をしてるだけと予想。</p>\n\n</div>\n<div class=\"section\">\n    <h3>CLI</h3>\n    <p>まず、`package.json`の`bin`に、`src/bootstrap`へのrefがあった。</p>\n\n<div class=\"section\">\n    <h4>bootstrap.ts</h4>\n    <p>`--experimental-vm-modules`をつけて、`cli.ts`をキックしてるだけ。</p><p>このフラグを有効にすると、Nodeの`vm`モジュールから、</p>\n\n<ul>\n<li>`Module`</li>\n<li>`SourceTextModule`</li>\n<li>`SyntheticModule`</li>\n</ul><p>この3つがさらに使えるようになるとのこと。</p>\n\n    <blockquote>\n        <p><a href=\"https://nodejs.org/api/vm.html#vm_class_vm_module\">VM (executing JavaScript) | Node.js v16.5.0 Documentation</a></p>\n\n    </blockquote>\n<p>これらは、CFWのコードをES Modulesの形式で書くスタイルの場合に必要らしい。</p>\n\n</div>\n<div class=\"section\">\n    <h4>cli.ts</h4>\n    \n<ul>\n<li>CLIとしてのI/Oは、`yargs`を使ってる\n<ul>\n<li>特別な処理はなく、引数パースしてるだけ</li>\n</ul></li>\n<li>`export default`はおそらくテスト用</li>\n<li>`if (module === require.main)`のブロックが本題\n<ul>\n<li>`Miniflare`クラスを、パースしたオプションで初期化</li>\n<li>リクエストを処理するHTTP(S)のサーバーを立てる</li>\n<li>実行時に最新バージョンをnpmに確認して、アップデートあるよって知らせる</li>\n</ul></li>\n</ul><p>というわけで、想定どおり。メインはやはり本体の`index.ts`へ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>本体</h3>\n    \n<ul>\n<li>`Miniflare`クラスがいるところ\n<ul>\n<li>それ以外にも`export`されてるけどとりあえず無視</li>\n</ul></li>\n<li>主要そうなプロパティ\n<ul>\n<li>`#modules`</li>\n<li>`#watcher`</li>\n<li>`#sandbox`</li>\n<li>`#environment`</li>\n</ul></li>\n<li>`#httpRequestListener()`\n<ul>\n<li>ローカルに立てるサーバーのハンドラ</li>\n<li>CFW独自の`Request`オブジェクトも、`@mrbbot/node-fetch`で用意されててさすがだった</li>\n<li>ScheduledEventか、FetchEventかを判定</li>\n<li>前者の場合は、`dispatchScheduled()`で処理</li>\n<li>後者の場合は、`dispatchFetch()`で処理</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>Modules, Sandbox, Environment</h4>\n    \n<ul>\n<li>Moduleは、`Miniflare`のコンストラクタで`#modules`にアサインされるものたち</li>\n<li>CFWの実行環境を構成する要素を、モジュールという名で関心ごとに実装してある</li>\n<li>たとえば、\n<ul>\n<li>`EventsModule`の場合、グローバルな`addEventListener()`とか、`FetchEvent`とか</li>\n<li>`StandardsModule`の場合、`fetch()`とか`crypto`とか</li>\n</ul></li>\n<li>Moduleごとに、SandboxとEnvironmentを用意するようになってる</li>\n<li>Sandboxは、Workerのグローバルスコープそのもの\n<ul>\n<li>どこのWorkerでもすべからく同じもの</li>\n</ul></li>\n<li>Environmentは、シークレットや環境変数など\n<ul>\n<li>人それぞれで違うかもしれないもの</li>\n<li>KVなどもこっち扱い</li>\n</ul></li>\n<li>NodeのAPIとnpm資産によって、CFWの独自APIまでぜんぶ実装してある・・・\n<ul>\n<li>しゅごい</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>OptionsWatcher</h4>\n    \n<ul>\n<li>`Miniflare`のコンストラクタで`#watcher`にアサインされるやつ</li>\n<li>実行スクリプトや、設定ファイルなどの変更を監視する役割\n<ul>\n<li>`wrangler.toml`とかも</li>\n<li>監視自体は`chokidar`がやってる</li>\n</ul></li>\n<li>変更があったら、`#watchCallback()`が呼ばれる\n<ul>\n<li>コール結果としての`await #watcher.initPromise`が、各所でチェックされる仕組み</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>#watchCallback()</h4>\n    \n<ul>\n<li>初回起動時および、上述のファイル変更が検知されたら動く</li>\n<li>初期化された`#modules`を使って、`#sandbox`と`#environment`を構築する\n<ul>\n<li>つまり実行コンテキストはココで決まる</li>\n</ul></li>\n<li>その後、`#reloadScheduled()`と`#reloadWorker()`が呼ばれる</li>\n<li>コールバックを呼ぶときは、パース済のオプションで呼び出す\n<ul>\n<li>その中には、実行指定されたスクリプト本体も含まれる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>#reloadWorker()</h4>\n    \n<ul>\n<li>`ScriptLinker`の初期化\n<ul>\n<li>モジュールWorker用の依存関係のトラッキング</li>\n</ul></li>\n<li>各モジュールのリセット</li>\n<li>さっき用意した実行コンテキストを使って、実行スクリプトをインスタンス化\n<ul>\n<li>`buildModule()` or `buildScript()`</li>\n</ul></li>\n<li>そしてインスタンスの実行\n<ul>\n<li>インスタンスの`run()`</li>\n<li>たいていのWorkerは、これで`fetch`イベントを待ち受けるようになる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>scripts.ts</h4>\n    \n<ul>\n<li>`ScriptBlueprint`クラス\n<ul>\n<li>実行対象のスクリプトの入れ物でありそのインスタンス</li>\n</ul></li>\n<li>`_createContext()`\n<ul>\n<li>用意したコンテキストのsandboxを使って、`vm.createContext()`</li>\n<li><a href=\"https://nodejs.org/api/vm.html#vm_vm_createcontext_contextobject_options\">https://nodejs.org/api/vm.html#vm_vm_createcontext_contextobject_options</a></li>\n</ul></li>\n<li>`buildScript()`\n<ul>\n<li>実行スクリプトを`vm.Script`クラスにして、`runInContext()`できるようにする</li>\n<li><a href=\"https://nodejs.org/api/vm.html#vm_script_runincontext_contextifiedobject_options\">https://nodejs.org/api/vm.html#vm_script_runincontext_contextifiedobject_options</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>`dispatchFetch()`</h4>\n    \n<ul>\n<li>上述のくだりでスクリプトが実行されて、イベントを待ち受けてるインスタンスがあるはず</li>\n<li>そこに`localhost`で受けたHTTPを、イベントとして横流しする</li>\n<li>さっきの`EventsModule`の`dispatchFetch()`を呼ぶ\n<ul>\n<li>実行スクリプト側で呼んだはずの`addEventListener()`で対応</li>\n</ul></li>\n</ul><p>というのが一連の流れ。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>`modules/*`の各モジュールが、NodeでCFW相当の環境を実装してる要たち\n<ul>\n<li>WorkerGlobalScopeをNodeで実装してるだけですごいのに</li>\n<li>KVとかDOとかのCFW独自APIまで全てが再実装されてる</li>\n</ul></li>\n<li>実行スクリプトは、Nodeの`vm`モジュールでV8 Isolate相当を再現\n<ul>\n<li>というか独自コンテキストでコード実行するならこうするしかない？</li>\n</ul></li>\n<li>初回起動時、依存ファイルの更新時に、コンテキストを再生成</li>\n<li>あとは任意のリクエストを`localhost`で受けて、実行スクリプトのインスタンスで実行</li>\n</ul><p>という感じ。うーむ、わかりやすい！</p>\n\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    \n<ul>\n<li>コードがすごく読みやすくて感動した\n<ul>\n<li>`#sandbox`みたいなプライベートプロパティも使われてるモダンなコード</li>\n</ul></li>\n<li>間違いなくプロの犯行\n<ul>\n<li>というか精錬されすぎててもしや2周目ですか？ってなった</li>\n</ul></li>\n<li>モジュールWorkerのためのコードが結構行数を取ってるのが少し気になる\n<ul>\n<li>けど、これから先のデファクトになるならまあ・・</li>\n</ul></li>\n</ul><p>存在は知っててもNodeの`vm`モジュールとか使ったこともなかったし、とっても勉強になった。</p><p>その恩返しも兼ねて、めちゃめちゃ小さいPRを出したら無事にマージされた 😆</p><p>ただもちろんCFW本家と100%同等ではないし、微妙な違いはあるっぽいけど、まあローカルで開発するだけなら便利に使えるやつなのかなーと。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/mrbbot/miniflare/issues/18#issuecomment-886252773\">Missing EventTarget and Event &middot; Issue #18 &middot; mrbbot/miniflare &middot; GitHub</a></p>\n\n    </blockquote>\n\n</div>"
}
