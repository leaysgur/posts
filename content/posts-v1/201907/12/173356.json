{
  "title": "WebRTCのDataChannelをもっと手軽に",
  "html": "<p>使いたかったので、ライブラリを書きました。</p><p>`enhanced-datachannel`という名前でnpmからインストールできます。</p><p>リポジトリはこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/enhanced-datachannel\">GitHub - leader22/enhanced-datachannel: Wanna `enhance(RTCDataChannel)` for general usage.</a></p>\n\n    </blockquote>\n<p>以下、ざっくり紹介と、DataChannelそのものについて書きます。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>enhanced-datachannel</h3>\n    <p>3つの関数をエクスポートしてます。</p>\n\n<ul>\n<li>`based()`</li>\n<li>`promised()`</li>\n<li>`chunked()`</li>\n</ul><p>型はこの通り。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synStatement\">export</span> <span class=\"synStatement\">declare</span> <span class=\"synIdentifier\">function</span> based<span class=\"synStatement\">(</span>dc: RTCDataChannel<span class=\"synStatement\">)</span>: BasedDataChannel<span class=\"synStatement\">;</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">declare</span> <span class=\"synIdentifier\">function</span> promised<span class=\"synStatement\">(</span>dc: RTCDataChannel<span class=\"synStatement\">)</span>: PromisedDataChannel<span class=\"synStatement\">;</span>\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">declare</span> <span class=\"synIdentifier\">function</span> chunked<span class=\"synStatement\">(</span>dc: RTCDataChannel<span class=\"synStatement\">)</span>: ChunkedDataChannel<span class=\"synStatement\">;</span>\n</pre><p>`RTCDataChannel`のインスタンスを受け取って、ラップして返します。</p><p>つまり、WebRTCのシグナリングには関与しないです。</p>\n\n<div class=\"section\">\n    <h4>モチベーション</h4>\n    \n<ul>\n<li>WebRTCといったらビデオチャットでしょ感</li>\n<li>ただデータもあれこれ送れるなら、他の用途でも使い込んでみたいなーと思った</li>\n<li>しかしそのままのAPIだと使い勝手が微妙</li>\n</ul><p>というわけで、用途別にラップするものを作りました。</p>\n\n</div>\n<div class=\"section\">\n    <h4>BasedDataChannel</h4>\n    <p>`EventEmitter`でラップしただけです。</p><p>`send()`は、`RTCDataChannel#send()`にそのまま流れ、`on(\"message\")`で、`RTCDataChannel#onmessage`が拾えます。</p><p>その他のプロパティもそのままアクセスできるようになってます。</p><p>基本的には後述する2クラスのベースとなるものであり、直接使うモチベーションはないかなーと思ってます。</p>\n\n</div>\n<div class=\"section\">\n    <h4>PromisedDataChannel</h4>\n    <p>`extends BasedDataChannel`です。</p><p>その名の通り、メッセージの送受信が`Promise`で扱えます。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// recv</span>\npromisedDC.on(<span class=\"synConstant\">&quot;message&quot;</span>, (data, resolve, reject) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">try</span> <span class=\"synIdentifier\">{</span>\n    console.log(data); <span class=\"synComment\">// &quot;Take this!&quot;</span>\n    resolve(<span class=\"synConstant\">&quot;Thank you!&quot;</span>);\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">catch</span> (err) <span class=\"synIdentifier\">{</span>\n    reject(err);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// send</span>\n<span class=\"synStatement\">const</span> res = await promisedDC.send(<span class=\"synConstant\">&quot;Take this!&quot;</span>);\nconsole.log(res); <span class=\"synComment\">// &quot;Thank you!&quot;</span>\n</pre><p>この例では文字列を送ってますが、JavaScriptのオブジェクトそのまま送れます。<br />\n内部的にJSON文字列にして送信して、受信時にオブジェクトに戻します。</p><p>これ、地味に便利だと思います。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ChunkedDataChannel</h4>\n    <p>おなじく`extends BasedDataChannel`です。</p><p>これもその名の通り、1回の`send()`で送れないような大きなファイルをチャンクに分けて送信してくれるやつ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// recv</span>\nchunkedDC.on(<span class=\"synConstant\">&quot;message&quot;</span>, (blob, meta) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// download it</span>\n  <span class=\"synStatement\">const</span> $downloadLink = <span class=\"synStatement\">document</span>.createElement(<span class=\"synConstant\">&quot;a&quot;</span>);\n  $downloadLink.href = URL.createObjectURL(blob);\n  $downloadLink.download = meta.name;\n  $downloadLink.textContent = meta.name;\n  <span class=\"synStatement\">document</span>.body.append($downloadLink);\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// send</span>\nawait chunkedDC.send(file, <span class=\"synIdentifier\">{</span> name: <span class=\"synConstant\">&quot;prof.png&quot;</span> <span class=\"synIdentifier\">}</span>);\n</pre><p>ファイル名やらメタ情報は、オプショナルな第2引数で渡すようにしてます。</p><p>受信側では`Blob`形式になってるので、その後はよしなにします。</p>\n\n</div>\n<div class=\"section\">\n    <h4>まとめ</h4>\n    \n<ul>\n<li>`npm i enhanced-datachannel`してね</li>\n<li>`promised()`と`chunked()`を用途にあわせて使ってね</li>\n<li>それぞれ用途別の`sned()`と`on(\"message\")`ができるようになるよ</li>\n</ul><p>以上でした！</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>DataChannelよもやま</h3>\n    <p>あとは開発Tipsとしてのメモです。</p><p>前提として、WebRTCのブラウザのAPIはほぼほぼFixしてきた感もある + まあだいたいのケースでは問題なく動きます。</p><p>が、すごい細かいとこまで見ていくとイコールではないし、実装差異ももちろんあるし、まあこんなもんやろマインドで接するが吉です。</p>\n\n<div class=\"section\">\n    <h4>消された`reliable`</h4>\n    <p>DataChannel（というかSCTP）では、データ送信の特性をある程度コントロールできるようになっていてます。</p>\n\n<ul>\n<li>信頼性</li>\n<li>配送順序</li>\n</ul><p>これをそれぞれいじれて、2人は排他で別々に設定できます。</p><p>信頼性については、`maxRetransmits`と`maxPacketLifeTime`というプロパティ、配送順序は`ordered`というプロパティです。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> dc = pc.createDataChannel(<span class=\"synConstant\">&quot;ch&quot;</span>, <span class=\"synIdentifier\">{</span>\n  ordered: <span class=\"synConstant\">false</span>,\n  maxRetransmits: 1,\n  maxPacketLifeTime: 1000,\n<span class=\"synIdentifier\">}</span>);\n</pre><p>デフォルトだと信頼性も配送順序も保証されるモード、このプロパティを1つでもいじったら、いじったものが保証されないモードに。</p><p>・・・的なことは、実は1年前に記事にしてたらしい。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2017/11/28/162541\">WebRTC&#x306E;DataChannel&#x3092;unreliable&#x30E2;&#x30FC;&#x30C9;&#x3067;&#x4F7F;&#x3046; - console.lealog();</a></p>\n\n    </blockquote>\n<p>というのが建前で。</p><p>この古い記事内でも言ってるけど`reliable`プロパティの扱いに困ったという話です。</p>\n\n<ul>\n<li>Specにはない</li>\n<li>Chrome / Firefoxには生えてる</li>\n<li>Safariにない</li>\n</ul><p>今回のケースだと`reliable`なものを引数に受けたかったので、そのバリデーションをしたかった。</p><p>しかしSafariでその値が取れない！</p><p>`maxRetransmits`と`maxPacketLifeTime`が、`createDataChannel()`した側と、`ondatachannel`された側で異なります。</p>\n\n<ul>\n<li>した側はどちらも`null`</li>\n<li>された側はどちらも`65536`</li>\n</ul><p>もちろん未指定で。</p><p>`65535`を無理やり指定してごまかす手もあったんですが、そうするとChromeとFirefoxで`reliable: false`になって気持ち悪い・・。</p><p>まあ基本的にこんなオプションをいじるマニアックな人は、このライブラリを使うこともないやろということで、バリデーションは諦めた。</p><p>`reliable`が消えた経緯は、それぞれの指定値を見ればわかるやろ？ってことかもですが、</p>\n\n<ul>\n<li>Firefoxはどちらも`null`</li>\n<li>Chromeはどちらも`65535`</li>\n</ul><p>という感じで差があって、Specにはないけど`reliable`を見れるほうが楽なんやが・・という感じ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`maxRetransmitTime`は古い</h4>\n    <p>古いんですが、Chromeではまだ生きてます・・。</p><p>つまり、Chrome（少なくとも現在のM75）では、`dc.maxPacketLifeTime`が`undefined`です。<br />\n代わりに`dc.maxRetransmitTime`なら取れます。</p><p>しかし作成時の引数では、`maxPacketLifeTime`を指定することを要求されます。<br />\n間違って古い`maxRetransmitTime`を指定すると・・。</p>\n\n    <blockquote>\n        <p>[Deprecation] maxRetransmitTime is deprecated and will be removed in M70, around October 2018. Please use maxPacketLifeTime instead. See <a href=\"https://www.chromestatus.com/features/5198350873788416\">https://www.chromestatus.com/features/5198350873788416</a> for more details.</p>\n\n    </blockquote>\n<p>だそうです。お察しです。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`binaryType`</h4>\n    \n<ul>\n<li>Specによると初期値は`blob`</li>\n<li>Firefoxの初期値は`blob`</li>\n<li>Chrome / Safariだと`arraybuffer`</li>\n</ul><p>この時点でお察しなんですが、Chrome / Safariで`blob`を指定しようとすると・・・。</p>\n\n    <blockquote>\n        <p>Chrome: M75<br />\nUncaught DOMException: Failed to set the 'binaryType' property on 'RTCDataChannel': Blob support not implemented yet</p><p>Safari: 12.1.1<br />\nNotSupportedError: The operation is not supported.</p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>チャンクのサイズ</h4>\n    \n    <blockquote>\n        <p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels#Understanding_message_size_limits\">Using WebRTC data channels - Web APIs | MDN</a></p>\n\n    </blockquote>\n<p>1度の`dc.send()`で送信できるデータのサイズについて。</p><p>今回の実装でも`16KB`単位で区切るようにしてますが、このへんはまあ込み入った事情がいろいろあるようで、簡単にはいかないよってことですね。</p><p>ちゃんとやるならBackPressureとかちゃんと考えてストリーミングすべきなのよね・・。</p>\n\n</div>\n</div>"
}
