{
  "title": "Jestを使ってみてのハマりどころメモ",
  "html": "<p><iframe src=\"https://hatenablog-parts.com/embed?url=http%3A%2F%2Ffacebook.github.io%2Fjest%2F\" title=\"Jest · 🃏 Delightful JavaScript Testing\" class=\"embed-card embed-webcard\" scrolling=\"no\" frameborder=\"0\" style=\"display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;\"></iframe></p><p>JestいいですよねJest。<br />\nあれこれプラグインとかライブラリとか入れなくてもだいたいのことができて。</p><p>さて、この1ヶ月くらいひたすらJestでテストを書き続けて、ハマったとこをメモ。<br />\n逆に言えば、ここに書いてないことでは一切困ってなくて、Jest最高って感じ。</p><p>Karmaみたいなブラウザでテストする機能さえつけばもう一生ついていきます感すらある。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>before / afterでもasync</h3>\n    <p>Docsにそれらしいコードはないけどできる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>beforeAll(done =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// some async tasks</span>\n  done();\n<span class=\"synIdentifier\">}</span>);\nbeforeEach(async () =&gt; <span class=\"synIdentifier\">{</span>\n  await asyncTask();\n<span class=\"synIdentifier\">}</span>);\nafterEach(async done =&gt; <span class=\"synIdentifier\">{</span>\n  await asyncTask();\n  asyncTask2(done);\n<span class=\"synIdentifier\">}</span>);\nafterAll(() =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// some sync tasks</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>Mochaとかだと`before` / `after`やけど、Jestは`beforeAll` / `afterAll`である。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Matcherあれこれ</h3>\n    \n<div class=\"section\">\n    <h4>`toHaveProperty`のキー</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> obj = <span class=\"synIdentifier\">{</span>\n  arr: <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{</span> x: 1 <span class=\"synIdentifier\">}</span>,\n    <span class=\"synIdentifier\">{</span> x: 2 <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">]</span>,\n  <span class=\"synConstant\">'hyp-hen'</span>: <span class=\"synConstant\">'Hello'</span>\n<span class=\"synIdentifier\">}</span>;\n\nexpect(obj).toHaveProperty(<span class=\"synConstant\">'arr.1.x'</span>, 2);\nexpect(obj).toHaveProperty(<span class=\"synConstant\">'hyp-hen'</span>, <span class=\"synConstant\">'Hello'</span>);\n</pre><p>ってな感じで数値なプロパティもそのまま書けばいい。<br />\nハイフンも気にせず書ける。</p>\n\n</div>\n<div class=\"section\">\n    <h4>`toHaveBeenCalledWith`</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> spy = jest.fn();\nspy(1);\nspy(3);\nspy(5);\n\nexpect(spy).toHaveBeenCalledWith(3);\nexpect(spy).toHaveBeenCalledWith(5);\nexpect(spy).toHaveBeenCalledWith(1);\n</pre><p>続けて呼べば次の`mock.calls`を見てくれる・・のではなく、そのモックがテストを通してその引数で呼ばれたかどうかがわかる（順不同）。<br />\nどれかひとつでも呼ばれてれば、パスする。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>`mockReturnValue`と`mockImplementation`</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> foo1 = jest.fn().mockReturnValue(<span class=\"synConstant\">'foo'</span>);\n<span class=\"synStatement\">const</span> foo2 = jest.fn().mockImplementation(() =&gt; <span class=\"synConstant\">'foo'</span>);\n</pre><p>この2つは同じではないことに気づかずドハマりしてた。<br />\n`mockReturnValue()`のほうが短く書けていいやん、と。</p><p>このコードに限っていえば同じ結果になるけど、用途としては間違ってることを知るのが大事。<br />\n例えばこんな場合にハマる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> err1 = jest.fn().mockReturnValue(Promise.reject(<span class=\"synStatement\">new</span> Error(<span class=\"synConstant\">'err'</span>)));\n<span class=\"synStatement\">const</span> err2 = jest.fn().mockImplementation(() =&gt; Promise.reject(<span class=\"synStatement\">new</span> Error(<span class=\"synConstant\">'err'</span>)));\n</pre><p>前者は、関数を呼ぶまでもなくエラーなので、テストがコケて「なんで？？？」ってなります。</p><p>その名の通り、</p>\n\n<ul>\n<li>`mockReturnValue()`は値を返すだけでいいとき</li>\n<li>`mockImplementation()`は関数を返したいとき\n<ul>\n<li>引数をさわりたいとき</li>\n</ul></li>\n</ul><p>に使いましょう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`spyOn`するだけではダメ</h3>\n    \n    <blockquote>\n        <p>Note: By default, jest.spyOn also calls the spied method. This is different behavior from most other test libraries.</p>\n\n    </blockquote>\n<p>って、 <a href=\"http://facebook.github.io/jest/docs/en/jest-object.html#jestspyonobject-methodname\">The Jest Object &middot; Jest</a> に思いっきり書いてある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> obj = <span class=\"synIdentifier\">{</span>\n  foo() <span class=\"synIdentifier\">{</span> console.log(<span class=\"synConstant\">'foo!'</span>); <span class=\"synIdentifier\">}</span>,\n<span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// spyOnしただけだと</span>\njest.spyOn(obj, <span class=\"synConstant\">'foo'</span>);\n<span class=\"synComment\">// 呼ばれちゃう</span>\nobj.foo(); <span class=\"synComment\">// foo!</span>\n\n<span class=\"synComment\">// 呼びたくないなら実装を用意する</span>\njest.spyOn(obj, <span class=\"synConstant\">'foo'</span>).mockImplementation();\nobj.foo(); <span class=\"synComment\">// 何も起きない</span>\n</pre>\n</div>\n<div class=\"section\">\n    <h3>`useFakeTimers`はDateをモックしない</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/facebook/jest/issues/2684\">Jest useFakeTimers should also handle Date &middot; Issue #2684 &middot; facebook/jest &middot; GitHub</a></p>\n\n    </blockquote>\n<p>なので、`setTimeout`とかには使えるけど、`Date`で時間を見て・・みたいな処理には使えない。<br />\n現時点でJestとしては対応しないらしいので、どうにかしてモックする。</p><p>おすすめは <a href=\"https://github.com/sinonjs/lolex\">https://github.com/sinonjs/lolex</a> です。というか、これしか選択肢なさそう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>`proxyquire`的なことがしたい</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// api.js</span>\n<span class=\"synStatement\">const</span> request = require(<span class=\"synConstant\">'request-promise-native'</span>);\n\nmodule.exports = <span class=\"synIdentifier\">{</span>\n  getFoo() <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">return</span> request.get(<span class=\"synConstant\">'/foo'</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>;\n</pre><p>こういうモジュールをテストしたい場合にどうするか。<br />\n選択肢はいくつかある。</p>\n\n<div class=\"section\">\n    <h4>`jest.mock`するパターン</h4>\n    <p>`node_modules`なやつなので、`__mocks__`ディレクトリでモックを定義する。<br />\nそうじゃないなら、`jest.mock()`でモックする。</p><p>個人的には、影響範囲が広すぎてあまり好きではないパターンかも。</p>\n\n    <blockquote>\n        <p><a href=\"http://facebook.github.io/jest/docs/en/manual-mocks.html\">Manual Mocks &middot; Jest</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>`spyOn`で凌ぐパターン</h4>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">let</span> getSpy;\nbeforeEach(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> request = require(<span class=\"synConstant\">'request-promise-native'</span>);\n  getSpy = jest.spyOn(request, <span class=\"synConstant\">'get'</span>);\n<span class=\"synIdentifier\">}</span>);\nafterEach(() =&gt; <span class=\"synIdentifier\">{</span>\n  getSpy.mockRestore();\n<span class=\"synIdentifier\">}</span>);\n\ntest(<span class=\"synConstant\">'should get foo'</span>, async () =&gt; <span class=\"synIdentifier\">{</span>\n  getSpy.mockImplementationOnce(() =&gt; Promise.resolve(<span class=\"synConstant\">'foo'</span>));\n\n  <span class=\"synStatement\">const</span> foo = await api.getFoo();\n  expect(foo).toBe(<span class=\"synConstant\">'foo'</span>);\n  expect(getSpy).toHaveBeenCalledTimes(1);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>このように、実際にテストが走る前に、中で使ってるモジュールを`spyOn`でモックする。<br />\n（`require()`する度に違う参照が返ってくるモジュールは無理やけどそんなんは稀なはず）</p><p>基本的に、</p>\n\n<ul>\n<li>準備段階では`mockImplementation()`</li>\n<li>各テスト段階では`mockImplementationOnce()`</li>\n</ul><p>って感じの使い分けにするのが好き。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>autoMockはデフォルトでオフ</h3>\n    <p>インターネット情報だと古い記事が引っかかることも多くて、無駄な情報で混乱する。</p><p>かつてのJestは、`require()`したモジュールが基本的に全部モックだったらしい。<br />\nなのでテスト対象のモジュールを呼ぶたびに`unmock()`しないといけなくて・・みたいな記事がいっぱい出てくる。</p><p>が、v15からはそんなこともなく、他のテストフレームワークと同じように、普段のコードと同じように何もしなくなってる。</p>\n\n    <blockquote>\n        <p><a href=\"https://facebook.github.io/jest/blog/2016/09/01/jest-15.html#disabled-automocking\">Jest 15.0: New Defaults for Jest &middot; Jest</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>jest.xxx()はファイルスコープ</h3>\n    <p>`jest.mock()`とか、`jest.useFakeTimers()`とか。</p><p>そして、記述はそのファイルの先頭に巻き上げられる。<br />\nこの挙動が本当にキモで、これを知らないとドハマリするはず。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// a.test.js</span>\ntest(<span class=\"synConstant\">'caseA-1'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n  jest.useFakeTimers();\n<span class=\"synIdentifier\">}</span>);\n\ntest(<span class=\"synConstant\">'caseA-2'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// use FakeTimers</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>ファイルをまたぐと関係ない。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// b.test.js</span>\ntest(<span class=\"synConstant\">'caseB-1'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// use RealTimers</span>\n<span class=\"synIdentifier\">}</span>);\n</pre>\n</div>\n<div class=\"section\">\n    <h3>CircleCIでコケる</h3>\n    <p>シリアルで実行させないと都合の悪いテストがあるとコケるので、`--runInBand`か`-i`のどちからをつけて実行する。</p>\n\n</div>"
}
