{
  "title": "Svelteコンパイラのコードを読む Part.2",
  "html": "<p>Svelteのソースコードリーディング記事の続編。</p><p>`compiler`がエクスポートしてる3つの主な関数のうち、`preprocess()`と`parse()`を読んだのが前回の記事。</p><p>今回は残りの1つであり、最大の山場でもある`compile()`を追っていく。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>TL;DR</h3>\n    <p>ざっと雰囲気をつかみたい場合は、Svelteのコントリビューターが書いたまとめ記事があるので、そちらを読むほうが絶対に良いです。</p>\n\n    <blockquote>\n        <p><a href=\"https://lihautan.com/the-svelte-compiler-handbook/\">The Svelte Compiler Handbook | Tan Li Hau</a></p>\n\n    </blockquote>\n<p>動画がいい場合はこっち。</p>\n\n    <blockquote>\n        <p><a href=\"https://www.youtube.com/watch?v=e2pGS1eqja8\">https://www.youtube.com/watch?v=e2pGS1eqja8</a></p>\n\n    </blockquote>\n<p>ここからは、この記事のアウトラインに沿ってコードを1行ずつ読んでいく・・ってことをやります。</p>\n\n</div>\n<div class=\"section\">\n    <h3>コンパイル結果</h3>\n    <p>先に、この単純なコンポーネントである`App.svlete`を、`compile()`に渡すとどうなるかを見ておく。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> compile <span class=\"synIdentifier\">}</span> = require(<span class=\"synConstant\">&quot;svelte/compiler&quot;</span>);\n\n<span class=\"synStatement\">const</span> result = compile(\n  `\n  &lt;script&gt;\n    <span class=\"synIdentifier\">let</span> name = <span class=\"synConstant\">&quot;svelte&quot;</span>;\n  &lt;/script&gt;\n  &lt;p&gt;Hello <span class=\"synIdentifier\">{</span>name<span class=\"synIdentifier\">}</span>&lt;/p&gt;\n`,\n  <span class=\"synIdentifier\">{</span>\n    generate: <span class=\"synConstant\">&quot;dom&quot;</span>, <span class=\"synComment\">// or &quot;ssr&quot;</span>\n  <span class=\"synIdentifier\">}</span>\n);\n\nconsole.log(result);\n</pre><p>というイメージのコード。</p><p>`dom`つまりCSR用の場合の結果はこうなる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">/* App.svelte generated by Svelte v3.23.2 */</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span>\n  SvelteComponent,\n  detach,\n  element,\n  init,\n  insert,\n  noop,\n  safe_not_equal,\n<span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;svelte/internal&quot;</span>;\n\n<span class=\"synIdentifier\">function</span> create_fragment(ctx) <span class=\"synIdentifier\">{</span>\n  <span class=\"synIdentifier\">let</span> p;\n\n  <span class=\"synStatement\">return</span> <span class=\"synIdentifier\">{</span>\n    c() <span class=\"synIdentifier\">{</span>\n      p = element(<span class=\"synConstant\">&quot;p&quot;</span>);\n      p.textContent = `Hello $<span class=\"synIdentifier\">{</span>name<span class=\"synIdentifier\">}</span>`;\n    <span class=\"synIdentifier\">}</span>,\n    m(target, anchor) <span class=\"synIdentifier\">{</span>\n      insert(target, p, anchor);\n    <span class=\"synIdentifier\">}</span>,\n    p: noop,\n    i: noop,\n    o: noop,\n    d(detaching) <span class=\"synIdentifier\">{</span>\n      <span class=\"synStatement\">if</span> (detaching) detach(p);\n    <span class=\"synIdentifier\">}</span>,\n  <span class=\"synIdentifier\">}</span>;\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synIdentifier\">let</span> name = <span class=\"synConstant\">&quot;svelte&quot;</span>;\n\n<span class=\"synStatement\">class</span> App <span class=\"synStatement\">extends</span> SvelteComponent <span class=\"synIdentifier\">{</span>\n  constructor(options) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">super</span>();\n    init(<span class=\"synIdentifier\">this</span>, options, <span class=\"synStatement\">null</span>, create_fragment, safe_not_equal, <span class=\"synIdentifier\">{}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> App;\n</pre><p>コンポーネントのクラスがそのまま返る。<br />\n`fragment`は剥き身のコンポーネントのようなイメージで、コードでも度々出てくる。</p><p>`ssr`の場合はこうなる。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">/* App.svelte generated by Svelte v3.23.2 */</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> create_ssr_component, <span class=\"synStatement\">escape</span> <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;svelte/internal&quot;</span>;\n\n<span class=\"synIdentifier\">let</span> name = <span class=\"synConstant\">&quot;svelte&quot;</span>;\n\n<span class=\"synStatement\">const</span> App = create_ssr_component(($$result, $$props, $$bindings, $$slots) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">return</span> `&lt;p&gt;Hello $<span class=\"synIdentifier\">{</span><span class=\"synStatement\">escape</span>(name)<span class=\"synIdentifier\">}</span>&lt;/p&gt;`;\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">default</span> App;\n</pre><p>コンポーネントを返す関数を含んだオブジェクトが返る。DOMはもちろんただの文字列の表現。</p><p>というように、コンポーネントを実行可能なコードにコンパイルする処理なのである。</p><p>ちなみにこの様子は、公式のREPLでオプションをいじればすぐ見れるのでおすすめ。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/repl\">https://svelte.dev/repl</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3>svelte.compile()</h3>\n    <p>さて本題のコードへ。</p><p>`parse()`で得たSvelte流のASTを元に、Svelteのランタイムに変換していくステップ。</p><p>コンパイラの肝であり、ここを読めばコンパイル時に何が成されているのかのすべてがわかるはず・・！</p>\n\n<div class=\"section\">\n    <h4>compiler/compile/index.ts</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/index.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/index.ts</a></p>\n\n    </blockquote>\n<p>毎度のざっくりシグネチャーはこちら。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink><span class=\"synIdentifier\">function</span> compile<span class=\"synStatement\">(</span>\n  source: <span class=\"synType\">string</span><span class=\"synStatement\">,</span>\n  options: CompileOptions\n<span class=\"synStatement\">)</span>: <span class=\"synIdentifier\">{</span>\n  js: <span class=\"synIdentifier\">{</span> code: <span class=\"synType\">string</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">;</span>\n  css: <span class=\"synIdentifier\">{</span> code: <span class=\"synType\">string</span> <span class=\"synIdentifier\">}</span><span class=\"synStatement\">;</span>\n  ast: Ast<span class=\"synStatement\">;</span>\n  warnings: Warning<span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  vars: Var<span class=\"synIdentifier\">[]</span><span class=\"synStatement\">;</span>\n  stats: Stats<span class=\"synStatement\">;</span>\n<span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">{}</span>\n</pre>\n<ul>\n<li>`source`は受け取った`*.svelte`ファイルの文字列そのもの</li>\n<li>返り値にある`js.code`と`css.code`が実際に実行されるコード\n<ul>\n<li>REPLで見れたやつ</li>\n<li>バンドラー経由でファイルに書き出されるやつ</li>\n</ul></li>\n<li>`warnings`はまんま注意</li>\n<li>`vars`はプラグイン向けのメタデータ</li>\n<li>`stats`は各ステップの実行時間などを取ってある</li>\n</ul><p>オプションの詳細は、APIのDocsを見るべし。</p>\n\n<ul>\n<li>`dom`か`ssr`か対象とする環境</li>\n<li>`esm`か`cjs`かフォーマット</li>\n<li>CustomElementにするかどうか</li>\n<li>コメントを残すか</li>\n</ul><p>などなど、コンパイラっぽい設定項目がある。</p>\n\n    <blockquote>\n        <p><a href=\"https://svelte.dev/docs#svelte_compile\">https://svelte.dev/docs#svelte_compile</a></p>\n\n    </blockquote>\n<p>で、この関数でやってる処理は大きく4つ。</p>\n\n<ul>\n<li>`parse()`を使ったAST化</li>\n<li>ASTを元に、`Component`クラスへの変換\n<ul>\n<li>変数の参照や、依存関係の洗い出し</li>\n</ul></li>\n<li>その`Component`をターゲット環境向けにレンダリング\n<ul>\n<li>ランタイムコードのレンダリング</li>\n<li>必要なときに必要な部分がアップデートされるように</li>\n</ul></li>\n<li>コード文字列として生成</li>\n</ul><p>察するに、`Component`とレンダリングまわりの2本柱って感じ。</p><p>最初の`parse()`は前回見たやつなので割愛して、2つ目から見ていく。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>compiler/compile/Component.ts</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/Component.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/Component.ts</a></p>\n\n    </blockquote>\n<p>`*.svelte`ファイルはそれぞれがコンポーネントという単位で扱われて、その実態がこのクラス。<br />\nコンストラクタでASTを受け取って、それを再帰で歩きながら精査する。</p><p>コンストラクタでやってることはこんな感じ。</p><p>まずはCSSまわりからはじまる。</p>\n\n<ul>\n<li>各コンポーネントでscopedなCSSを実現するための`Stylesheet`クラスの初期化\n<ul>\n<li><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/css/Stylesheet.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/css/Stylesheet.ts</a></li>\n<li>`css`のASTを受け取る</li>\n<li>`.svelte-1tyk8gu`みたいなハッシュ作ってるのもココ（使うのは少し先）</li>\n</ul></li>\n<li>CSSのルール（セレクタと`{}`）単位でチェックしていく\n<ul>\n<li>ASTの`Atrule` -> `Rule` -> `Declaration`を、それぞれのクラスに変換</li>\n<li>あとでunusedなものを見つけられるようなマーキングも</li>\n</ul></li>\n<li>`stylesheet.validate()`\n<ul>\n<li>`:global()`を変な位置で宣言してないかなどを検証</li>\n</ul></li>\n</ul><p>つぎに、`markup`と`script`の部分。</p>\n\n<ul>\n<li>`svelte:option`要素があればそれのパース\n<ul>\n<li>コンポーネント全体へ関係するオプションなので</li>\n<li>`CustomElement`としての指定があるかどうかも</li>\n</ul></li>\n<li>`context=module`な`script`部の精査\n<ul>\n<li>変数名に`$`を使ってたらエラーにする</li>\n<li>Writableな変数の宣言のマーキング</li>\n</ul></li>\n<li>通常の`script`部の精査\n<ul>\n<li>同様に変数名の精査や、`writable`な変数のマーキング</li>\n<li>リアクティブな変数のマーキングも</li>\n<li>再代入による値の更新部分のマーキング</li>\n</ul></li>\n<li>`markup`部を表現する`Fragment`クラスの初期化\n<ul>\n<li>`html`のASTを受け取る</li>\n<li>再帰でASTの`type`からそれぞれのクラスに仕分けていく\n<ul>\n<li><a href=\"https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/nodes\">https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/nodes</a></li>\n</ul></li>\n<li>Svelteで利用できるテンプレートの構文は、すべてここで定義されてる</li>\n<li>不正な記述があったらここで弾かれる（a11y的にこの属性をつけろとかもここであわせてみてる）</li>\n<li>`{#if}`とか`{#each}`とか、ブロックごとにスコープを区切りながら</li>\n<li>参照されてたら、変数に`referenced`とマーク</li>\n</ul></li>\n</ul><p>そして最後にまとめの処理。</p>\n\n<ul>\n<li>再び`script`部の精査\n<ul>\n<li>この時点ですべての変数やその用途がわかってる</li>\n<li>`markup`部で新たに参照されてたりするのでそれをアップデート</li>\n<li>存在しない変数を参照してたら警告するなども</li>\n<li>リアクティブな宣言を抽出して、依存グラフを作る</li>\n<li>`import`してるものがあればそれもココでチェックしておく</li>\n</ul></li>\n<li>scopedなCSSの`class`属性の付与\n<ul>\n<li>最初の方で用意したハッシュ</li>\n</ul></li>\n<li>unusedなCSSセレクタの警告</li>\n</ul><p>まずは`script`部と`markup`部のASTを掘っていって、リアクティブな依存関係や参照の関係を明らかにして、最後に最適化するってのがメインの処理だった。</p><p>これでASTを元に必要な情報を持った`Component`のインスタンスを作るところまでできたので、次はそれをレンダリングしていく。<br />\nこの時点ではまだ書き出しできる文字列にはなってない。</p>\n\n<div class=\"section\">\n    <h4>プロパティ / メソッド</h4>\n    <p>そのほか、`Component`クラスに生えてるめぼしいプロパティたち。</p>\n\n<ul>\n<li>`stylesheet`\n<ul>\n<li>CSSに関するもの</li>\n</ul></li>\n<li>`vars` / `var_lookup`\n<ul>\n<li>コンポーネント内で使われてる変数のリスト</li>\n<li>実際に使われてるかとか、Writableかとか、`props`として受け取るかなどのフラグがある</li>\n</ul></li>\n<li>`imports`\n<ul>\n<li>`import`してるもの</li>\n</ul></li>\n<li>`fragment`\n<ul>\n<li>`markup`部を表すツリー</li>\n</ul></li>\n<li>`instance_scope` / `instance_scope_map`\n<ul>\n<li>`script`部</li>\n</ul></li>\n<li>`reactive_declarations` / `reactive_declarations_nodes`\n<ul>\n<li>リアクティブな定義</li>\n</ul></li>\n<li>`slots`\n<ul>\n<li>`slot`要素を使ってれば</li>\n</ul></li>\n<li>`used_names` / `globally_used_names`\n<ul>\n<li>使用された変数名、新たに割り振った変数名</li>\n<li>`t0`とか`h1`とか</li>\n</ul></li>\n</ul><p>メソッドとしては、`get_unique_name_maker()`みたく、一時的な変数名を衝突しないように割り当てるやつとかもある。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>`compile()`を経てJavaScriptやCSSは実行可能な文字列になる</li>\n<li>`compile()`は、まず`parse()`を使ってSvelteのASTを用意する</li>\n<li>そのASTを使って、`Component`クラスを初期化する\n<ul>\n<li>ここでやってるのは、変数とその依存関係の精査</li>\n<li>ASTを使って、ASTを変換しながらそれをプロパティに持つクラスに置き換えてってる感じ</li>\n</ul></li>\n</ul><p>さて、この`Component`を使ってランタイムのコードをレンダリングするのが次にやること。</p><p>次回へ続く。</p>\n\n</div>"
}
