{
  "title": "Svelteコンパイラのコードを読む Part.3",
  "html": "<p>Svelte<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%BD%A1%BC%A5%B9%A5%B3%A1%BC%A5%C9\">ソースコード</a>リーディング記事の続編の続編。</p><p>`svelte/compiler`の`compile()`を追っている途中。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>前回までのあらすじ</h3>\n    \n<ul>\n<li>`compiler.parse()`によって得られるのがSvelteのAST</li>\n<li>それを使って`Component`クラスを初期化した\n<ul>\n<li>ASTを元に、どのように振る舞う<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>なのかがまとまった</li>\n</ul></li>\n</ul><p>そしてその`Component`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>を使って、環境ごとの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>をやっていくのが今回。</p>\n\n</div>\n<div class=\"section\">\n    <h3>render_dom() と render_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a>()</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_dom\">https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_dom</a><br />\n<a href=\"https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_ssr\">https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_ssr</a></p>\n\n    </blockquote>\n<p>DOMと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>という2つの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>方法があって、引数に`Component`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>を渡す。<br />\nどっちが使われるかは、`compile()`に渡された`generate`オプション次第。</p><p>どちらも返り値は、`js`と`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>`という2つのプロパティがあるオブジェクト。</p>\n\n<ul>\n<li>js: ASTで表現された、Svelteのランタイムに変換されたあとのコード</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>: Scopedになった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSS\">CSS</a>のテキストと、ソースマップ</li>\n</ul><p>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>`は同じものが返ってくるみたい。<br />\n`js`のほうはDOMと<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SSR\">SSR</a>で結果が異なる。（具体的な違いは、前回の記事を参照）</p><p>というわけで繰り返しになるけど、ランタイムで動くコードを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>するのが、この関数たちの仕事。</p>\n\n</div>\n<div class=\"section\">\n    <h3>render_dom()</h3>\n    <p>やってることの流れ。</p>\n\n<ul>\n<li>`Renderer`クラスの初期化\n<ul>\n<li>（後述）</li>\n</ul></li>\n<li>`body`という配列の用意\n<ul>\n<li>ここに、最終的な実行コードをASTで組み上げたものを積んでいく</li>\n</ul></li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>\n<ul>\n<li>`Component`の`Stylesheet`から</li>\n<li>ここでScopedになった<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/CSS\">CSS</a>文字列になる</li>\n</ul></li>\n<li>`Block`の適用\n<ul>\n<li>`{#if}`とか`{#each}`とかで生まれる概念</li>\n<li>ブロックごとにコンテキスト（スコープ）が異なる</li>\n<li>ブロックは、いくつかのノードにまたがる</li>\n</ul></li>\n<li>上層の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>から`props`として受け取るもののハンドリング\n<ul>\n<li>後に`$$props`に置き換え</li>\n</ul></li>\n<li>ASTの`instance`（`script`部）の精査\n<ul>\n<li>`AssignmentExpression`か`UpdateExpression`があったら、`$$invalidate()`するよう置き換え</li>\n</ul></li>\n<li>`create_fragment()`の挿入\n<ul>\n<li>ランタイムでも使われるやつ</li>\n<li>各<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>ごとに用意される</li>\n</ul></li>\n<li>`context=module`部の挿入</li>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>の実態である`instance()`の組み上げ\n<ul>\n<li>ランタイムでも使われるやつ</li>\n</ul></li>\n<li>リアクティブな変数のアップデート時に再<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>などするよう紐付け</li>\n<li>エクスポートするクラスのテンプレートの組み上げ\n<ul>\n<li>CustomElementの場合、`SvelteElement`</li>\n<li>それ以外の場合、`SvelteComponent`</li>\n</ul></li>\n<li>`js`はAST、`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>`は実行可能な文字列になったものを返す</li>\n</ul><p>理解するのも難しければ、説明するのも難しい！</p><p>`*.svelte`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を`parse()`して得たASTを元に得られた`Component`クラスを使って、ランタイムで動くコードのASTを、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>で動的に作ることをやってる。</p>\n\n<div class=\"section\">\n    <h4>ASTを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>で作る</h4>\n    <p>ASTを<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>で作るとはどういうことかは、その処理のコアであるこのライブラリを見たほうがはやい。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/Rich-Harris/code-red\">GitHub - Rich-Harris/code-red: Experimental toolkit for writing x-to-JavaScript compilers</a></p>\n\n    </blockquote>\n<p>READMEから転載したコードはこんな感じ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> b, x <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;code-red&quot;</span>;\n\n<span class=\"synStatement\">const</span> expression = x`i + j`;\n\nassert.equal(expression.type, <span class=\"synConstant\">&quot;AssignmentExpression&quot;</span>);\nassert.equal(expression.operator, <span class=\"synConstant\">&quot;+&quot;</span>);\nassert.equal(expression.left.name, <span class=\"synConstant\">&quot;i&quot;</span>);\nassert.equal(expression.right.name, <span class=\"synConstant\">&quot;j&quot;</span>);\n\n<span class=\"synStatement\">const</span> body = b`\n  <span class=\"synStatement\">const</span> i = 1;\n  <span class=\"synStatement\">const</span> j = 2;\n  <span class=\"synStatement\">const</span> k = i + j;\n`;\n\nassert.equal(body.length, 3);\nassert.equal(body<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span>.type, <span class=\"synConstant\">&quot;VariableDeclaration&quot;</span>);\n</pre><p>Tag付きのテンプレート<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%C6%A5%E9%A5%EB\">リテラル</a>で書いたコード片が、ESTreeのBodyになるという仕組み。<br />\nASTを制するものはすべてを制す！という心意気を感じる・・・。</p><p>なんしかこれを使って、動的にランタイムのコードを組み上げていく。</p>\n\n<ul>\n<li>参照だけされてる変数や純関数なら巻き上げてしまう</li>\n<li>更新されてるなら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>のスコープに動かす</li>\n</ul><p>みたいな最適化（実際はもっとたくさんのことを、あらゆる条件でやってる）を、動的にやってるというわけ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>compiler/compile/render_dom/Renderer.ts</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/Renderer.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/Renderer.ts</a></p>\n\n    </blockquote>\n\n<ul>\n<li>`fragment`プロパティに、`Fragment`クラスを初期化\n<ul>\n<li><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/wrappers/Fragment.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/wrappers/Fragment.ts</a></li>\n<li>これがDOMツリーの代わり</li>\n<li>各ノードは、連結リストになってる</li>\n<li><a href=\"https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_dom/wrappers\">https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/render_dom/wrappers</a></li>\n<li><a href=\"https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/nodes\">https://github.com/sveltejs/svelte/tree/master/src/compiler/compile/nodes</a></li>\n</ul></li>\n<li>ツリーと同時に、`Block`と<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>ごとに必要なコンテキスト（後の`$$ctx`）も管理してる\n<ul>\n<li><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/Block.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/render_dom/Block.ts</a></li>\n</ul></li>\n<li>状態の更新にあわせて、再描画などの処理が必要かどうかの判断 = `dirty`かどうかの判断もココでやってる\n<ul>\n<li>チェックはビット演算</li>\n<li>正確には、各ノードがその時の依存変数名のリストを渡して、それ用のビットマスクを用意してもらうイメージ</li>\n</ul></li>\n</ul><p>ツリーは`Fragment`で、そこに各種ラッパーに包まれたノードがぶら下がってる。<br />\nSvelte的な各ノードの要素の実態は`compiler/compile/nodes`にあって、`dom`用のラッパーと、`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a>`用のラッパーが別々に存在してるというわけ。</p><p>各ラッパは`Block`への参照を持ってて、処理の単位を協調させてるっぽい。<br />\nで、各ノード（ラッパー）がそれぞれ`render()`関数を持ってて、ランタイムで必要なときに呼ばれてアップデートされるという仕組み。</p>\n\n</div>\n<div class=\"section\">\n    <h4>render_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a>()</h4>\n    \n<ul>\n<li>`dom`とは別の`Renderer`を使う</li>\n<li>ラッパの代わりにハンドラという層があって、各ノードを包んでる</li>\n<li>各ノードはクラスではなく、文字列を返すようになってる\n<ul>\n<li>`Renderer`の`add_string()`を呼んで、文字列を組み上げてる</li>\n<li>その時点でわからないものは、`add_expression()`</li>\n</ul></li>\n<li>`code-red`を使って、同様の流れでASTを組み上げるところは同じ</li>\n</ul><p>`render_dom()`に比べると、やはり圧倒的にコード量が少ない・・・！</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>component.generate()</h3>\n    <p>`compile()`で行われる最後の処理。<br />\n`render_dom()`か`render_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a>()`で得られた`{ js, <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a> }`な結果を引数に実行される。（正確には`null`が渡されることもあるけど）</p><p>ちなみにこの`Component.generate()`の返り値が、`compile()`自体の返り値になっており、ついに実行可能な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の文字列が得られるところ。</p><p>やってることはこの通りで単純。</p>\n\n<ul>\n<li>バナーの挿入\n<ul>\n<li>Svelteバージョンいくつで生成しました的な</li>\n</ul></li>\n<li>ASTを歩いて、`helpers`プロパティに関数を抽出（`@`ではじまる関数を探してる）\n<ul>\n<li>これらがランタイムで呼ばれる関数名たち</li>\n</ul></li>\n<li>`create_module()`\n<ul>\n<li>引数は、AST本体、モジュールのフォーマット（`esm` or `cjs`）、`helpers`、バナー、などなど</li>\n<li>（後述）</li>\n</ul></li>\n<li>`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/css\">css</a>`の文字列化（既にそうなってるので代入だけ）</li>\n<li>`js`プロパティの文字列化\n<ul>\n<li>`code-red`の`print()`を使ってる</li>\n</ul></li>\n</ul><p>ついに総仕上げで、モジュールとして書き出すところをやってる。</p>\n\n<div class=\"section\">\n    <h4>create_module()</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/create_module.ts\">https://github.com/sveltejs/svelte/blob/master/src/compiler/compile/create_module.ts</a></p>\n\n    </blockquote>\n\n<ul>\n<li>`esm`か`cjs`かどちらかのフォーマット\n<ul>\n<li>`import`か`require()`かで微妙に完成するコードが変わる</li>\n</ul></li>\n<li>どちらも単一のモジュールを返すようになってる\n<ul>\n<li>なので現状、`*.svelte`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>から複数の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>は返せない</li>\n</ul></li>\n</ul><p>ここは関数名からイメージできるそのまんまの処理だった。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>`render_dom()`\n<ul>\n<li>ランタイムのためのASTを、`Component`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>を使って組み上げる</li>\n<li>必要なときにブロックごとに`render()`できるように</li>\n<li>`render_<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ssr\">ssr</a>()`も基本的には同様だが、文字列と関数を組み上げる</li>\n</ul></li>\n<li>`component.generate()`\n<ul>\n<li>ASTから実行可能な文字列に変換する処理</li>\n<li>モジュールとして使えるように</li>\n</ul></li>\n</ul><p>というわけでこれで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>は一通り読めたことになる・・・はず・・。</p><p>ただ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%EB\">コンパイル</a>結果には、ランタイムで読み出す変数や関数がいっぱい含まれてる（`SvelteComponent`とか）ので、近いうちにそっちも読みたい。</p>\n\n</div>\n<div class=\"section\">\n    <h3><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>総まとめ</h3>\n    <p>Svelteの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%D1%A5%A4%A5%E9\">コンパイラ</a>のコードを読むシリーズは、ひとまずこれで完結。</p>\n\n<ul>\n<li>`preprocess()`\n<ul>\n<li>Svelteの構文はそのままに、事前に処理が必要なら行う</li>\n</ul></li>\n<li>`parse()`\n<ul>\n<li>SvelteのASTを生成する</li>\n</ul></li>\n<li>`compile()`\n<ul>\n<li>ASTを解析し、環境ごとのASTを生成し、最終的に実行可能文字列へ</li>\n</ul></li>\n</ul><p>という3つの棲み分けはわかったし、Issueの読解も捗る予感がする。（コントリビュートできるかは別問題ではある）</p><p>コードを読んでみての感想は、</p>\n\n<ul>\n<li>想像してた以上に複雑だった</li>\n<li>ASTに慣れてないとつらい\n<ul>\n<li>というか、基本的にAST芸である</li>\n</ul></li>\n<li>コメントはそんなに書かれてないので、コード読むのそこそこ大変</li>\n<li>コード内に`TODO`も結構残ってた</li>\n</ul><p>まあ現世におけるモダンな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>の中身を読むの、どれを取っても大変なんやろうし、やはり我々は生かされておるのじゃ・・。</p>\n\n</div>"
}
