{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.2",
  "html": "<p>前回までのあらすじ。</p>\n\n<ul>\n<li>`nodertc/nodertc`を読んでた</li>\n<li>クライアントとSessionを確立する際に、内部的にいくつかサーバーを立ててた\n<ul>\n<li>STUN</li>\n<li>DTLS</li>\n<li>SCTP</li>\n</ul></li>\n<li>こいつらの詳細を読み進めていく</li>\n</ul><p>というわけで、まずはSTUNから。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>使われ方</h3>\n    \n<ul>\n<li>セッション確率の際に用意していた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットで初期化される</li>\n<li>1000ms間隔で`STUN_BINDING_REQUEST`というメッセージを`send()`</li>\n<li>`STUN_EVENT_BINDING_REQUEST`を待ち受けて、`STUN_BINDING_RESPONSE`を`send()`</li>\n<li>あとはエラーもいちおうコンソールに出してる</li>\n</ul><p>というわけで基本的には`StunServer`の`send()`しか呼んでないのでそこを重点的に読みたい。</p>\n\n</div>\n<div class=\"section\">\n    <h3>nodertc/stun</h3>\n    <p>読んだバージョンは`1.3.0`です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/stun\">GitHub - nodertc/stun: Low-level Session Traversal Utilities for NAT (STUN) server</a></p>\n\n    </blockquote>\n<p>`src/index.js`が全てであり、たった90行！かと思いきや、`node_modules`という<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%A3%A5%EC%A5%AF%A5%C8\">ディレクト</a>リをわざわざ用意してて、そこに依存がいろいろある。</p><p>全部の行数を総計すると、2192行もあった・・。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>module.exports = <span class=\"synIdentifier\">{</span>\n  createMessage,\n  createServer,\n  validateFingerprint,\n  validateMessageIntegrity,\n  StunMessage,\n  StunServer,\n  constants,\n<span class=\"synIdentifier\">}</span>;\n</pre><p>何はともあれ、これらを見ていく。</p><p>めぼしいクラスとしては`StunMessage`と`StunServer`くらい。<br />\n`createXxx()`系もこれらを使ってるだけ、あとは関数と定数なのでスルー。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: StunServer</h3>\n    \n<ul>\n<li>`constructor()`\n<ul>\n<li>NodeRTCのセッションが持ってた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットを引数に<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A4%A5%F3%A5%B9%A5%BF%A5%F3%A5%B9\">インスタンス</a>化</li>\n<li>extends `EventEmitter`</li>\n</ul></li>\n<li>`onMessage()`\n<ul>\n<li><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットが受け取った`message`をさばくのが主</li>\n<li>受け取ったパケットの先頭のbyteが`0..3` === STUNの時だけ、`process()`する</li>\n</ul></li>\n<li>`process()`\n<ul>\n<li>この時に内部的に扱いたいように、`StunMessage`に変換</li>\n<li>`type`によって、異なるイベントを`emit()`</li>\n</ul></li>\n<li>`send()`\n<ul>\n<li>`StunMessage`を`toBuffer()`して送る</li>\n<li>NodeRTCのセッションが持ってた<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケットの`send()`</li>\n</ul></li>\n</ul><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>に流れてきたパケットのうち、STUNに関するものだけをリレーするのが仕事っぽい。</p><p>他に見落としてないなら、なんか冗長な印象。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: StunMessage</h3>\n    \n<ul>\n<li>サーバーがやり取りするSTUNのパケットをいい感じにラップするもの</li>\n<li>`attribute`という単位で情報が付加されたり削られたり\n<ul>\n<li>ここでは9種類定義されてる</li>\n</ul></li>\n<li>内部的にバイナリを w/ <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B9%A5%AD%A1%BC%A5%DE\">スキーマ</a>で扱えるライブラリを使ってる\n<ul>\n<li><a href=\"https://github.com/reklatsmasters/binary-data\">GitHub - reklatsmasters/binary-data: Declarative binary data encoder / decoder</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>あらためて使われ方</h3>\n    \n<ul>\n<li>1000ms間隔で`STUN_BINDING_REQUEST`というメッセージを`send()`</li>\n<li>`STUN_EVENT_BINDING_REQUEST`を待ち受けて、`STUN_BINDING_RESPONSE`を`send()`</li>\n</ul><p>この2つの先を追う。</p>\n\n<ul>\n<li>`send(STUN_BINDING_REQUEST)`される先は、接続してきたピアの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ソケット\n<ul>\n<li>なので中身はブラウザのWebRTC実装なはず</li>\n<li>それは追えないにしても、このサーバー側でも同等の実装をしているはず</li>\n</ul></li>\n<li>それが`STUN_EVENT_BINDING_REQUEST`のイベントを受けてからやってること</li>\n</ul><p>コードとしてはこう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">this</span>.stun.on(STUN_EVENT_BINDING_REQUEST, (req, rinfo) =&gt; <span class=\"synIdentifier\">{</span>\n  assert(stun.validateFingerprint(req));\n  assert(stun.validateMessageIntegrity(req, <span class=\"synIdentifier\">this[</span>_icePassword<span class=\"synIdentifier\">]</span>));\n\n  <span class=\"synStatement\">const</span> userattr = req.getAttribute(STUN_ATTR_USERNAME);\n  <span class=\"synStatement\">const</span> sender = userattr.value.toString(<span class=\"synConstant\">'ascii'</span>);\n  <span class=\"synStatement\">const</span> expectedSender = `$<span class=\"synIdentifier\">{this[</span>_iceUsername<span class=\"synIdentifier\">]}</span>:$<span class=\"synIdentifier\">{this[</span>_peerIceUsername<span class=\"synIdentifier\">]}</span>`;\n  assert(sender === expectedSender);\n\n  <span class=\"synStatement\">const</span> response = stun.createMessage(\n    STUN_BINDING_RESPONSE,\n    req.transactionId\n  );\n\n  response.addAttribute(\n    STUN_ATTR_XOR_MAPPED_ADDRESS,\n    rinfo.address,\n    rinfo.port\n  );\n\n  response.addMessageIntegrity(<span class=\"synIdentifier\">this[</span>_icePassword<span class=\"synIdentifier\">]</span>);\n  response.addFingerprint();\n\n  <span class=\"synIdentifier\">this</span>.stun.send(response, rinfo.port, rinfo.address);\n<span class=\"synIdentifier\">}</span>);\n</pre><p>というわけで、送られてきたものを検証して返事するのが仕事っぽい。</p>\n\n</div>\n<div class=\"section\">\n    <h3>わかったこと</h3>\n    <p>途中までそもそもこんなコードが必要な理由がわかってなかった。</p><p>そもそも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>が確立できてるなら、その後もSTUN（自分・相手の居場所を知るという意味で）の仕事なんてないのでは？と。</p><p>ただこれは勘違いで、STUNはSTUNでもICEが継続的に接続を検証するために必要な機構の方であり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>もあった。</p>\n\n    <blockquote>\n        <p><a href=\"https://tools.ietf.org/html/rfc7675\">RFC 7675 - Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness</a></p>\n\n    </blockquote>\n<p>ちなみにログを仕込んでみたら、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>からは、2500ms間隔くらいで飛んできてて、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>も5秒間隔でやってると書いてあった。</p>\n\n    <blockquote>\n        <p><a href=\"https://blog.mozilla.org/webrtc/ice-disconnected-not/\">ICE connected or not... - Advancing WebRTC</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h4>そのほか知り得たこと</h4>\n    \n<ul>\n<li><a href=\"https://tools.ietf.org/html/rfc5389\">RFC 5389 - Session Traversal Utilities for NAT (STUN)</a>\n<ul>\n<li>元となる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>があったが、紆余曲折あって範囲が小さくなったらしい</li>\n<li><a href=\"https://tools.ietf.org/html/rfc3489\">RFC 3489 - STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)</a></li>\n<li>通称も\"Simple Traversal of <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a> through NAT\"から\"Session Traversal Utilities for NAT\"に</li>\n</ul></li>\n<li>STUNの実装はサーバーとクライアントと別れる\n<ul>\n<li>`stun:stun.l.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/google\">google</a>.com:19302`とか指定するやつで動いてるのがサーバーの実装</li>\n<li>クライアントの実装はブラウザのWebRTCが持ってる（はず）</li>\n<li>NodeRTCだとサーバー側の仕組はない（いらないから）</li>\n</ul></li>\n</ul><p>NodeJSで書かれたSTUNのサーバー、クライアントの実装はいくつかった。</p>\n\n<ul>\n<li>サーバー\n<ul>\n<li><a href=\"https://github.com/enobufs/stun\">GitHub - enobufs/stun: STUN server using node.js</a></li>\n</ul></li>\n<li>クライアント\n<ul>\n<li><a href=\"https://github.com/summerwind/node-stun\">GitHub - summerwind/node-stun: Session Traversal Utilities for NAT (STUN) client for Node.js.</a></li>\n<li><a href=\"https://github.com/nodertc/stun\">GitHub - nodertc/stun: Low-level Session Traversal Utilities for NAT (STUN) server</a></li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    \n<ul>\n<li>コードは本体より読みにくい\n<ul>\n<li>モジュールをまたがってやり取りされるオブジェクト、型がないので追いかけるのつらい</li>\n<li>`options`とか言われてもなんやっけ・・ってなる</li>\n</ul></li>\n<li>STUNはSTUNでも、そういうSTUNではなかった</li>\n</ul><p>やはり<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>を読むのが先か？感が強まってきたけど、やり取りの仕様（フォーマット）としての<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>もあれば、その仕様をなぜ使うかどう使うに触れてる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/RFC\">RFC</a>もあって、それぞれが体系的にどういう関係性なのかを最初に知らないと、筋道立てて調べられないことに気付いた・・。</p><p>まぁひとまず、当初の予定通りNodeRTCのDTLSサーバーの部分を読んでいきます。</p>\n\n</div>"
}
