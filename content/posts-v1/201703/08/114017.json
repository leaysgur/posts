{
  "title": "MobXを使ったアーキテクチャについて",
  "html": "<p>いまさらですが、俺的Real world MobXです。<br />\nいちおう半年くらい仕事でも趣味でも触ってきてての今です。</p><p>あくまで1つの例ですが、どこかの誰かの何かの参考になれば。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>その前に</h3>\n    <p>こんな風に使ってますを紹介する前に、もやもやーっと思ってることを箇条書きにしておきます。</p>\n\n<ul>\n<li>俺が考えた最強の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>\n<ul>\n<li>そんなものはない</li>\n<li>声のでかいやつの言うことを真に受けるな</li>\n<li>納得できない部分があるなら採用するな</li>\n</ul></li>\n<li>Reduxとの比較\n<ul>\n<li>Reduxでできたクソコードがあるように、MobXでできたクソコードもありえる</li>\n<li>役割が薄い分、そのリスクはMobXの方が高い（設計力が試される）と思ってる</li>\n<li>コードの記述量は絶対に減るので、書き味は良くなる\n<ul>\n<li>書きやすさと無秩序は紙一重</li>\n</ul></li>\n</ul></li>\n<li>Flux的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>を踏襲するべきか\n<ul>\n<li>Action的なものを投げる必要はないが、投げてもいい</li>\n<li>Storeも単一でもいいし、複数にしてもいい</li>\n<li>シングルトンも好き好き</li>\n</ul></li>\n<li>その他\n<ul>\n<li>1方向なフローと`view = f(state)`はReactの使命であり、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>は関係ない</li>\n<li>なんでもContext経由で渡すのは何を使おうと悪手やと思う</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>本題</h3>\n    <p>というわけで、こういう感じで最近使ってますのご紹介。<br />\n実際のコードで・・って場合は、 <a href=\"https://github.com/leader22/mmss-client\">https://github.com/leader22/mmss-client</a> なんかが新しいです。Flowで型型してて読みにくいかもですが・・。</p><p>ToDoアプリよりは大きいが、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EB%A1%BC%A5%BF%A1%BC\">ルーター</a>がネストして云々・・という規模のものではないです。<br />\n基本的な構成はこんな感じ。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>- main.js\n- store\n  - object\n- event.js\n- app.jsx\n- container\n- component</pre>\n<div class=\"section\">\n    <h4>main.js</h4>\n    <p>いわずもがなエントリーポイントです。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>mobx.useStrict(<span class=\"synConstant\">true</span>);\n\n<span class=\"synStatement\">const</span> store = <span class=\"synStatement\">new</span> Store(initialState);\n<span class=\"synStatement\">const</span> <span class=\"synStatement\">event</span> = <span class=\"synStatement\">new</span> Event(store);\n\nReactDOM.render(\n  &lt;Provider <span class=\"synStatement\">event</span>=<span class=\"synIdentifier\">{</span><span class=\"synStatement\">event</span><span class=\"synIdentifier\">}</span>&gt;\n    &lt;App store=<span class=\"synIdentifier\">{</span>store<span class=\"synIdentifier\">}</span> /&gt;\n  &lt;/Provider&gt;,\n  <span class=\"synStatement\">document</span>.getElementById(<span class=\"synConstant\">'root'</span>)\n);\n</pre><p>それぞれ、</p>\n\n<ul>\n<li>Store: アプリの状態でありMobXのObservableな値たち</li>\n<li>Event: アプリで起こる操作（によりStoreを更新するハンドラ）</li>\n<li>View: ReactのViewであり、MobXのObserverに</li>\n</ul><p>この3つでだいたい事足りると思います。<br />\n`mobx.useStrict(true)`は、Storeで扱うObservableを更新できる箇所を縛るものだと思ってください。<br />\nそれができるのがEventで、他からはStoreの状態を更新できない、のでそのままViewに渡してます。</p><p>`mobx-react`の`Provider`でEventはContext経由で渡すようにするのが最近は好きです。<br />\n見た目を構成するために必要なStoreのバケツリレーはある程度まで許容できても、ハンドラはな・・という好みなので人それぞれな気がする。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Store w/ Object</h4>\n    \n<ul>\n<li>単一Storeである必要はないので、それぞれの債務に応じた状態をそれぞれの場所に配置できる</li>\n<li>でもStoreAとStoreBの複合状態を、Viewで作るのはちょっと・・となる</li>\n<li>なら、個別のStoreは子Store（＝Object）として、それらをまとめる親Storeに持たせればいいのでは</li>\n</ul><p>という感じです。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Store <span class=\"synIdentifier\">{</span>\n  constructor(initialState) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.ui = <span class=\"synStatement\">new</span> UiObject();\n    <span class=\"synIdentifier\">this</span>.foo = <span class=\"synStatement\">new</span> FooObject();\n    <span class=\"synIdentifier\">this</span>.bar = <span class=\"synStatement\">new</span> BarObject();\n\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      isFooAndBar: computed(() =&gt; <span class=\"synIdentifier\">{</span>\n        <span class=\"synStatement\">return</span> <span class=\"synIdentifier\">this</span>.foo.isFoo &amp;&amp; <span class=\"synIdentifier\">this</span>.bar.isBar;\n      <span class=\"synIdentifier\">}</span>)\n    <span class=\"synIdentifier\">}</span>, initialState);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>複数のStoreを持つといえばそうだが、単一であるとも言える・・のは、こういうわけでした。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> <span class=\"synType\">Object</span> <span class=\"synIdentifier\">{</span>\n  constructor() <span class=\"synIdentifier\">{</span>\n    extendObservable(<span class=\"synIdentifier\">this</span>, <span class=\"synIdentifier\">{</span>\n      <span class=\"synComment\">// ここにstateを定義してく</span>\n      selected: <span class=\"synStatement\">null</span>,\n      foo: <span class=\"synConstant\">'foo'</span>,\n      bar: <span class=\"synIdentifier\">[]</span>,\n\n      hasBar: computed(() =&gt; <span class=\"synIdentifier\">{</span> <span class=\"synStatement\">return</span> <span class=\"synIdentifier\">this</span>.bar.length !== 0; <span class=\"synIdentifier\">}</span>),\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n\n  setSelected(target) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.selected = target;\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>Store / Objectを作るときに心がけてるのは、いわゆるGetterメソッドを\"生やさない\"こと。<br />\nというのも、それは9割がた`computed`で表現できるはずだから。そうしないならMobX使ってる意味ない。</p><p>もうひとつは、Observableである必要のないデータは、`extendObservable()`の外に出すこと。紛らわしいから。<br />\n必要に応じて`.shallow`のModifiersを。</p><p>あと冒頭で`useStrict(true)`したので、Store / Objectの値を更新するには、`mobx.action`でラップした関数の中でやらないとダメです。</p><p>デコレータが使える案件なら、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> FooObject <span class=\"synIdentifier\">{</span>\n  @observable foo = 300;\n\n  @action\n  setFoo(foo) <span class=\"synIdentifier\">{</span> <span class=\"synIdentifier\">this</span>.foo = foo; <span class=\"synIdentifier\">}</span>\n\n  @action.bound\n  setFoo2(foo) <span class=\"synIdentifier\">{</span> <span class=\"synIdentifier\">this</span>.foo = foo * 2; <span class=\"synIdentifier\">}</span>  \n<span class=\"synIdentifier\">}</span>\n</pre><p>てな感じに`action`化できる + `bind(this)`も手軽にできて最高なんですが、そうではない場合、<a href=\"https://github.com/leader22/mmss-client/blob/master/src/script/shared/util/class.js\">&#x611A;&#x76F4;</a>にラップしていくしかないです・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Event</h4>\n    <p>最後の方がこちら。<br />\nStoreおよびObjectを変更できる唯一無二の存在。</p><p>Viewは表示だけ、Storeは状態だけ、なのでそれ以外はすべてココでやるようにしてます。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> Event <span class=\"synIdentifier\">{</span>\n  constructor(store) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.store = store;\n  <span class=\"synIdentifier\">}</span>\n\n  onClickFooBtn(value) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>.store.foo.setFoo(value);\n  <span class=\"synIdentifier\">}</span>\n\n  onChangeBar(id) <span class=\"synIdentifier\">{</span>\n    fetch(`/api/bar/$<span class=\"synIdentifier\">{</span>id<span class=\"synIdentifier\">}</span>`)\n      .then(res =&gt; <span class=\"synIdentifier\">{</span> <span class=\"synIdentifier\">this</span>.store.bar.updateBar(res.json()); <span class=\"synIdentifier\">}</span>)\n      .<span class=\"synStatement\">catch</span>(err =&gt; <span class=\"synIdentifier\">{</span> <span class=\"synIdentifier\">this</span>.store.showError(err); <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>全てのStore/Objectのためにこの層が必要か？と言われると微妙だと思いますが、ココに全て寄せる意義はあると思うので、それも好き好きかなーと。<br />\nViewからStoreを直で叩こうとすると、UI絡みの処理やら非同期の処理やらどうすんの・・？ってなりがちなので、こういう層はあってもいいと思う。</p><p>この構成だと、`mobx.reaction()`とかもあわせ技的に使えるのでそこは強いと思います。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>reaction(\n  () =&gt; <span class=\"synIdentifier\">this</span>.store.bar.isBar,\n  (changedBar) =&gt; <span class=\"synIdentifier\">{</span>\n    fetch(`/api/bar/update`);\n    <span class=\"synIdentifier\">this</span>.store.ui.changeBar();\n  <span class=\"synIdentifier\">}</span>\n)\n</pre><p>ユーザー入力を起点にして全てのハンドラを手続き的に書いていくのではなく、ユーザー入力によって状態が更新される、それに呼応して勝手に処理されるというイメージで。<br />\nこれがキマるとMobX最高ってなると思います。</p>\n\n</div>\n<div class=\"section\">\n    <h4>Container / component</h4>\n    <p>これはReactの話なのでサクッと。</p>\n\n<ul>\n<li>Container: `context`からEventを受け取る、各Storeも直接受け取る</li>\n<li>Component: Containerにぶら下がる、`props`で全部もらう</li>\n</ul><p>いわゆるプレゼンテーショナルな<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>か、そうでないか。<br />\nContainerも出来る限り増やしたくないので薄いツリーを心がけたい気持ちはある・・が。<br />\nStoreを受け取るときにそのまま受け取るか、View用の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%DE%A5%C3%A5%D4%A5%F3%A5%B0\">マッピング</a>を通して渡すかとかも好き好きかなーと。</p><p>MobXでやる場合に必要なのは、`observer()`でラップすることだけです。<br />\n<br />\n</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>これより大きな規模になったらどうするのか</h3>\n    <p>基本の3本柱は変えないと思います。<br />\nRouteも、そういうstateを用意するだけなので・・。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>autorun(() =&gt; <span class=\"synIdentifier\">{</span>\n  () =&gt; <span class=\"synIdentifier\">this</span>.store.ui.route,\n  (route) =&gt; <span class=\"synStatement\">location</span>.hash = `!/$<span class=\"synIdentifier\">{</span>route<span class=\"synIdentifier\">}</span>`;\n<span class=\"synIdentifier\">}</span>);\n</pre><p>あとは`componentDidMount()`でEventとStoreを初期化すればいいかもしれないし、<br />\nStore / Event / Viewのセットを複数用意して、それぞれ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C1%C2%B7%EB%B9%E7\">疎結合</a>で協調させるようにするだけでもいいかもしれないし。</p><p>てかSPAだからといって1<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>だけマウントして全てをやる必要はないし、互いに干渉しないなら分割するべきで、そのへんがエンジニアの仕事なのでは・・と。<br />\nというか、昨今のSPA設計における勘所もとい運用が面倒にならないかって、この「いかに小さい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>に分けられるか」な気がする。</p>\n\n<div class=\"section\">\n    <h4>悩んだらVueを</h4>\n    \n    <blockquote>\n        <p><a href=\"https://jp.vuejs.org/v2/guide/comparison.html#MobX-と用いた場合\">&#x4ED6;&#x306E;&#x30D5;&#x30EC;&#x30FC;&#x30E0;&#x30EF;&#x30FC;&#x30AF;&#x3068;&#x306E;&#x6BD4;&#x8F03; - Vue.js</a></p>\n\n    </blockquote>\n<p>ここにも引用されてる通り、React x MobXはVue.jsと似たような感覚で使えます。<br />\nということは、Vuexとかの段階的な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A2%A1%BC%A5%AD%A5%C6%A5%AF%A5%C1%A5%E3\">アーキテクチャ</a>設計が真似できるということで・・・！</p>\n\n<ul>\n<li>Storeを直叩きするもよし</li>\n<li>Mutationを作るもよし</li>\n<li>GetterとActionを分けるもよし</li>\n</ul><p>迷ったら参考にしてみるとよいと思います。<br />\n<br />\n</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>特記事項</h3>\n    <p>MobXである程度まじめにアプリを作る場合の知っ得メモ？です。</p>\n\n<div class=\"section\">\n    <h4>Observableな値にも種類がある</h4>\n    <p>一口に`observable(value)`といっても、実は種類があります。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> obj = <span class=\"synIdentifier\">{</span> a: <span class=\"synIdentifier\">{</span> b: <span class=\"synIdentifier\">{</span> c: 1 <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span> <span class=\"synIdentifier\">}</span>;\n\n<span class=\"synComment\">// same</span>\nobservable(obj)\nobservable.object(obj)\nobservable.deep(obj)\n\n<span class=\"synComment\">// modifier</span>\nobservable.shallow(obj)\n</pre><p>`observable()`で基本的になんでもObservableにできますが、それぞれのターゲットを指定する記法もあります。<br />\n`.shallow`とか`.deep`とか`.ref`とか、Modifiersってのもあります。（`computed`も`action`も実はModifiers）</p><p>Observableな値のタイプを指定するのがModifiersで、まあ知らなくても困らんのでは？って感じ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#observablevalue\">mobx/api.md at gh-pages &middot; mobxjs/mobx &middot; GitHub</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を全部は使わない</h4>\n    \n    <blockquote>\n        <p>The most important MobX <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/api\">api</a>'s. Understanding observable, computed, reactions and actions is enough to master MobX and use it in your applications!</p>\n\n    </blockquote>\n<p>と、ドキュメントにもあるように、いろいろ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>はあるけどほとんど使わないで済むはずです。</p><p>ライブラリは必要に迫れれてはじめて入れるもんです。<br />\n<a href=\"https://github.com/mobxjs/mobx-utils\">https://github.com/mobxjs/mobx-utils</a> っていうUtil集もあるので、必要になったときに探してみると吉です。</p>\n\n</div>\n<div class=\"section\">\n    <h4>What does MobX react to?</h4>\n    <p>必読です。</p>\n\n    <blockquote>\n        <p><a href=\"https://mobx.js.org/best/react.html\">Understanding what MobX reacts to | MobX</a></p>\n\n    </blockquote>\n<p>`autorun`とか`observer`とか、Observableな値の更新に呼応する系の動きを把握するのがMobXを使いこなすポイントで、その仕組が書いてあります。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// コレと</span>\n&lt;App&gt;\n  &lt;Foo bar=<span class=\"synIdentifier\">{</span>foo.bar<span class=\"synIdentifier\">}</span> /&gt;\n&lt;/App&gt;\n\n<span class=\"synComment\">// コレは挙動が違う</span>\n&lt;App&gt;\n  &lt;Foo foo=<span class=\"synIdentifier\">{</span>foo<span class=\"synIdentifier\">}</span> /&gt;\n&lt;/App&gt;\n</pre><p>`foo.bar`が更新された場合、前者は`App`が`render()`されるのに対し、後者は`Foo`が`render()`されます。<br />\nなんとなくわかるかな・・？<br />\nつまり、該当するプロパティにアクセスした関数が、ト<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E9%A5%C3%A5%AD%A5%F3%A5%B0\">ラッキング</a>されて自動で呼ばれます。</p><p>なのでパフォーマンスにすごくこだわるならば、これを熟知した上で`props`を渡さないとダメです。<br />\nただ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>に渡す`props`はきっちり限定したいと普通は思うと思うので、まあ差し迫ってからでいいかと。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>おわりに</h3>\n    <p>とりあえず書いてみたものの、これがベストではないと思うので、あくまで参考にというわけで・・。</p><p>ちなみにMobXを使ったコードは、Qiitaとかで探すより<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/GitHub\">GitHub</a>でコード検索したほうが絶対にいいです。絶対に。</p>\n\n</div>"
}
