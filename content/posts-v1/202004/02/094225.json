{
  "title": "フロントエンド x RTC界隈の最近とこれから",
  "html": "<p>フロントエンドエンジニアからみる、この界隈で今どんなIssueが話題になってるのかと、この先どういう動きがありそうかについて。</p><p>そこまで自分に先見の明があるとも思ってないけど、アウトプットしておかないと忘れてしまいそうなので・・。</p><p>ちなみにここでいうフロントエンドは、いわゆるブラウザとか<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/JavaScript\">JavaScript</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>のことです。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>的な側面はそこまで詳しくないのであまり触れません。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>WebRTC 1.0</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/w3c/webrtc-pc\">GitHub - w3c/webrtc-pc: WebRTC 1.0 API</a></p>\n\n    </blockquote>\n<p>まず、RTCといえばズバリのWebRTCから。</p><p>昨年末にWDからCRへ格上げということで、もう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が激変したりはしない・・はず。<br />\n実際のところ、ここ半年くらい大きな対応した覚えがないです。（WebRTCそのものを実装してる人は、地味にいろいろ対応してると思うけど）</p><p>ガワの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>という観点でいうと、最近はもう<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>を掘り下げていくフェーズというよりか、仕様としてのつじつま合わせやら、こんなときどうなるの？っていうコーナーケースへのIssueが多い印象。</p><p>たとえば通信中のノートPCをパタンって閉じたら、その通信はどうなる？とか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>としてこういうケースは可能になってるけど、その場合の状態遷移はどうあるべきか？とか。</p><p>JSの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>ネタでいうと、Perfect Negotiationの一連<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>たちが実装された暁には、何かしら対応してみてもよいかもしれない。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2019/12/05/095721\">WebRTC&#x306E;Perfect negotiation&#x306B;&#x3064;&#x3044;&#x3066; - console.lealog();</a></p>\n\n    </blockquote>\n<p>まあ、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B7%A5%B0%A5%CA%A5%EA%A5%F3%A5%B0\">シグナリング</a>のグレアは他にも回避方法あるし、今さら・・とは思う。</p><p>（そんなことより<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>に`setConfiguration()`実装してほしい。）</p>\n\n<div class=\"section\">\n    <h4>蛇足: Unified-plan</h4>\n    <p>この記事を書いてて思い出したネタ。</p>\n\n    <blockquote>\n        <p><a href=\"https://webrtchacks.com/is-everyone-switching-to-unified-plan/\">Is everyone switching to Unified Plan? - webrtcHacks</a></p>\n\n    </blockquote>\n<p>Unified-planってそういえばどうなったっけ・・みんなちゃんと使ってる？恩恵受けてる？っていうやつ。</p><p>まぁその記事としても、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>の中の人たちとしても、どうやらあん<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A4%DE%A4%B7%A4%E9\">ましら</a>しい。</p>\n\n    <blockquote>\n        <p><a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=857004\">857004 - chromium - An open-source project to help move the web forward. - Monorail</a></p>\n\n    </blockquote>\n<p>まあ実際は1トランスポートあたり1audio+1video以上やりとりしたい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>ってあまり思いつかん + 別に2トランスポートでなんとかなるので、ほんとシビアな仕様やったんやなとは思う・・。</p><p>セマンティクスとしてはこっちのほうがシュッとしてると思うけど。</p>\n\n</div>\n<div class=\"section\">\n    <h4>webrtc-extensions</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/w3c/webrtc-extensions\">GitHub - w3c/webrtc-extensions: A repository for &quot;WebRTC 1.1+&quot; features</a></p>\n\n    </blockquote>\n<p>そんな1.0のスコープから漏れた機能群は、だいたい拡張仕様って扱いになってます。</p><p>たとえばTPACでも話題になってた`RTCRtpReceiver`の`playoutDelay`。<br />\nいまだと受け取ったメディアは<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ASAP\">ASAP</a>で再生されるけど、そこに恣意的な遅延をつけられるようにしてちょっとバッファしたい・・とか。</p><p>あとはHW<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>できるコーデックが<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>で事前にわかると嬉しいよね、とか。</p><p>まあこの界隈は論者が限られてるので、全般的にアクティブではないです。<br />\nそういう意味ではNextVersionに関しても、ここのところ下火。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/w3c/webrtc-nv-use-cases\">GitHub - w3c/webrtc-nv-use-cases: Use cases for WebRTC NV</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>Statistics</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/w3c/webrtc-stats\">GitHub - w3c/webrtc-stats: WebRTC Statistics</a></p>\n\n    </blockquote>\n<p>おなじみ`getStats()`で取れるレポートあれこれについて。<br />\nこれも年明けにCRになり、いろいろ頑張ってるところ。</p><p>ただ実際のところはブラウザ差異がまったく埋まってなくて、我々としてはもう一声といった感じ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/webrtc-stats-impl-status\">GitHub - leader22/webrtc-stats-impl-status</a></p>\n\n    </blockquote>\n<p>ここに現時点の最新ブラウザでの実装差異をチマチマ集めてますのでご参照をば。</p><p>ただこれで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%C4%EA%CE%CC\">定量</a>的な値が取れたとて、実際は手札（そういう細かい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>）が存在しなくてほとんどアクションできないんですよね〜。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Media Capture and Streams</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/w3c/mediacapture-main\">GitHub - w3c/mediacapture-main: Media Capture and Streams specification (aka getUserMedia)</a></p>\n\n    </blockquote>\n<p>おなじみの`getUserMedia()`とか、`enumerateDevices()`とか。</p><p>こちらもCRながら、セマンティクスの問題とプライバシー方面の議論が入り混じって大乱闘状態。</p><p>すごくかいつまんでトピックを並べると、</p>\n\n<ul>\n<li>デ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%B9\">バイス</a>機能の詳細はFingerprintになるから見せられないよ</li>\n<li>`{ video: true }`ですべてのデ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%B9\">バイス</a>の許可取れるのおかしくない？</li>\n<li>`getDisplayMedia()`みたいに、ブラウザがピッカー持つべきでは？\n<ul>\n<li>`{ video: true, semantics: \"user-chooses\" }`的な</li>\n</ul></li>\n<li>そもそも許可なしでデ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D0%A5%A4%A5%B9\">バイス</a>一覧見れるのがおかしくない？</li>\n<li>一口にaudioって言っても、チャット用と演説用とで性質違うしその旨も指定したいです\n<ul>\n<li><a href=\"https://github.com/w3c/mst-content-hint\">https://github.com/w3c/mst-content-hint</a></li>\n</ul></li>\n<li>etc..</li>\n</ul><p>`enumerateDevices()`もついこの間も変更があったところなので、これらに関してはまだこれからも変わりそうやなーという感じ。</p><p>ここに関しては、PSAが出たらさっさと検証するしかなさそう・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>WebTransport</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/WICG/web-transport\">GitHub - WICG/web-transport: WebTransport is a web API for flexible data transport</a></p>\n\n    </blockquote>\n<p>ここからはちょっと先の話題。</p><p>サーバーとクライアント間の双方向で低遅延なやり取りがしたい場合の選択肢として、現状ではWebSocketかWebRTCのDataChannelかが主な選択肢になるはず。</p><p>ただWebSocketだとHoLBでパフォーマンスの問題があるし、WebRTCだとICEいらないしDTLSでSCTPなので実装が大変+そもそもサバクラで使いにくい。</p><p>ちょうどいい<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>ベースのWebSocketライクなやつが欲しい・・ということで生まれたのが、QUICの上で動くWebTransport。</p><p>QUICとか、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>の詳細については、別に詳しい人がいると思うので気になった人は調べてみてください。<br />\nドラフトを訳したやつがあるのでいちおう置いておきます。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/webtransport-rfcs\">GitHub - leader22/webtransport-rfcs</a></p>\n\n    </blockquote>\n<p>たとえば<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%AF%A5%E9%A5%A6%A5%C9\">クラウド</a>ゲーミングだと、クライアントからサーバーにはユーザー操作をデータで送って、サーバーからは結果がメディアで返ってくるのでそれを描画する感じ。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>としては`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/whatwg\">whatwg</a>/streams`のそれ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Example of sending unreliable game state to server using QUIC datagrams</span>\n\n<span class=\"synStatement\">const</span> transport = <span class=\"synStatement\">new</span> QuicTransport(<span class=\"synConstant\">'example.com'</span>, 10001);\n<span class=\"synStatement\">const</span> datagramWriter = transport.sendDatagrams().getWriter();\n\nsetInterval(() =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> message = getSerializedGameState();\n  datagramWriter.write(message);\n<span class=\"synIdentifier\">}</span>, 100);\n</pre><p>`ReadableStream`しかり`WritableStream`しかりをよしなに使うことになるはずで、このあたりの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>は慣れが必要そう。</p><p>ただ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>ですらまだIn developmentなので、まっだまだ先の話です。</p>\n\n<div class=\"section\">\n    <h4>WebRTC-QUIC</h4>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/w3c/webrtc-quic\">GitHub - w3c/webrtc-quic: Interface to create and manage QUIC streams</a></p>\n\n    </blockquote>\n<p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>ではOriginTrialまでしてたけど、最近はWebTransportのこともあってかやや下火。<br />\nというか、気付けばWebTransportありきの仕様になってる感。</p><p>クライアント<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>でのWebRTCは、しばらく今のままって感じですかねー。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>WebSocketStream</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/ricea/websocketstream-explainer\">GitHub - ricea/websocketstream-explainer: Explainer for the WebSocketStream JavaScript API</a></p>\n\n    </blockquote>\n<p>WebSocketで`Stream`の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使えるようにして、BackPressureに対応したモダンな書き味にしたいよねというプロポーザル。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> wss = <span class=\"synStatement\">new</span> WebSocketStream(url);\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> readable <span class=\"synIdentifier\">}</span> = await wss.connection;\n\n<span class=\"synStatement\">const</span> reader = readable.getReader();\n<span class=\"synStatement\">while</span> (<span class=\"synConstant\">true</span>) <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> value, done <span class=\"synIdentifier\">}</span> = await reader.read();\n  <span class=\"synStatement\">if</span> (done) <span class=\"synStatement\">break</span>;\n\n  await process(value);\n<span class=\"synIdentifier\">}</span>\ndone();\n</pre><p>こちらもモノはおなじく`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/whatwg\">whatwg</a>/streams`ですね。</p><p>QUIC上で動くWebTransportのほうが上位互換ではあるけど、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/UDP\">UDP</a>が通らない環境とかもあると思うし、WebTransportがくるまでのつなぎとしての狙いもありそう。</p><p>ともあれデータをいい感じに流す土管は揃い踏みした感あるので、あとは何をやり取りするか。</p><p>ChromeCanaryではもう動くので、WebTransportよりは早そうではある。</p>\n\n</div>\n<div class=\"section\">\n    <h3>WebCodecs</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/WICG/web-codecs\">GitHub - WICG/web-codecs: WebCodecs is a flexible web API for encoding and decoding audio and video</a></p>\n\n    </blockquote>\n<p>いい感じの土管ができたら、そのデータを描画する部分の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>があるといいよね、ということで。</p><p>今もJS/WASMで自前<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%A8%A5%F3%A5%B3%A1%BC%A5%C9\">エンコード</a>・デコードすることはできるけど、それだとメモリ効率とかHWも有効利用できないし、そもそもブラウザに載ってるコーデックを再実装するのが無駄という話もあり。</p><p>WebRTCでも生のメディアには触れないし、やっぱあらゆる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>に対応するためには、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>を細かく切っていくしか無い世相を感じますね。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// Example of video rendering to Canvas for low-latency live streaming or cloud gaming</span>\n\n<span class=\"synStatement\">class</span> CanvasRendererSink <span class=\"synIdentifier\">{</span>\n  constructor(canvas) <span class=\"synIdentifier\">{</span>\n    <span class=\"synIdentifier\">this</span>._context = canvas.getContext(<span class=\"synConstant\">'bitmaprenderer'</span>);\n  <span class=\"synIdentifier\">}</span>\n\n  write(videoFrame) <span class=\"synIdentifier\">{</span>\n    _context.transferFromImageBitmap(videoFrame.image);\n    <span class=\"synStatement\">return</span> Promise.resolve();\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> canvas = <span class=\"synStatement\">document</span>.getElementById(<span class=\"synConstant\">&quot;canvas&quot;</span>);\n\n<span class=\"synStatement\">const</span> renderingStream = <span class=\"synStatement\">new</span> WritableStream(<span class=\"synStatement\">new</span> CanvasRendererSink(canvas));\n<span class=\"synStatement\">const</span> videoDecoder = <span class=\"synStatement\">new</span> VideoDecoder(<span class=\"synIdentifier\">{</span> codec: <span class=\"synConstant\">&quot;vp8&quot;</span> <span class=\"synIdentifier\">}</span> );\n\nencodedVideoStream.pipeThrough(videoDecoder).pipeTo(renderingStream);\n</pre><p>これも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>としては`<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/whatwg\">whatwg</a>/streams`のそれ（だいたい`TransformStream`）で、用途に応じていろいろ用意されるクラスを使い分けることになる想定。</p><p>これもIn developmentなやつ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Insertable Streams <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a> for WebRTC</h3>\n    \n    <blockquote>\n        <p><a href=\"https://github.com/alvestrand/webrtc-media-streams\">GitHub - alvestrand/webrtc-media-streams: Insertable Streams API for WebRTC</a></p>\n\n    </blockquote>\n<p>話は戻ってまたWebRTC。<br />\nこれもまだ単なるプロポーザルではあるけど、WebRTCでやり取りするメディアを手元で加工したいよねという話。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// それ用のフラグ</span>\n<span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  forceEncodedVideoInsertableStreams: <span class=\"synConstant\">true</span>,\n  forceEncodedAudioInsertableStreams: <span class=\"synConstant\">true</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// TransformStream</span>\n<span class=\"synStatement\">const</span> senderTransform = <span class=\"synStatement\">new</span> TransformStream(<span class=\"synIdentifier\">{</span>\n  async transform(chunk, controller) <span class=\"synIdentifier\">{</span> <span class=\"synComment\">/* ... */</span> <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">const</span> videoSender = pc.addTrack(track, stream)\n<span class=\"synStatement\">const</span> senderStreams = videoSender.getEncodedVideoStreams();\n\nsenderStreams.readable\n  .pipeThrough(senderTransform)\n  .pipeTo(senderStreams.writable);\n</pre><p>これは先述のWebCodecsありきなコードになってるけど、今の時点でも有効な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%E6%A1%BC%A5%B9%A5%B1%A1%BC%A5%B9\">ユースケース</a>が実はある。</p><p>それが、この<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を使って今話題のE2Eの暗号化を実現するサンプル。</p>\n\n    <blockquote>\n        <p><a href=\"https://webrtc.github.io/samples/src/content/peerconnection/endtoend-encryption/\">Peer connection end to end encryption</a></p>\n\n    </blockquote>\n<p>まだ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のCanaryでしか動かないけど。</p><p>あとは受け取ったvideoのキーフレームをカウントするサンプルとかもレビュー中。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/webrtc/samples/pull/1276\">Video analyzer by alvestrand &middot; Pull Request #1276 &middot; webrtc/samples &middot; GitHub</a></p>\n\n    </blockquote>\n<p>なんしか、画一的なやり方でメディアを加工できるようになるのはよいですね。</p>\n\n</div>\n<div class=\"section\">\n    <h3>フロントエンドエンジニアとして</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>を作る側としては、今後も仕様の動向や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>それ自体についてもある程度知っておく必要がありそう + <a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>としては`Stream`に慣れておくとよいかも？</p><p>一般的なフロントエンドエンジニアがRTC系のことをやる場合は、基本的に何某かの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>を使うはず。<br />\nなので、その背景の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>や<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を知っておく必要は実際ほぼないと思ってて、それよりもその<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>の通信モデルやら<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>を熟知して、できること・できないことを判断できるようになっておくほうがよいのかなと思います。</p><p>とは言っても汎用性の高い<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>を選んだなら、自分で`Stream`経由で生メディアに触れることもあるかもしれんけど・・。</p>\n\n</div>"
}
