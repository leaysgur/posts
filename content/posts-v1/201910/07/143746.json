{
  "title": "WebRTCでTURNを使う",
  "html": "<p>トピックとしてはまったく目新しくないけど、そういやまとめてないなと思ったのでメモ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h4>TURN</h4>\n    \n    <blockquote>\n        <p><a href=\"https://tools.ietf.org/html/rfc5766\">RFC 5766 - Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</a></p>\n\n    </blockquote>\n<p>`Traversal Using Relays around NAT`ってやつ。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>の場合、各エンドポイントにはそれぞれの都合があって、簡単につなげないこともある。</p><p>ざっくり言うと、たとえば特定の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D7%A5%ED%A5%C8%A5%B3%A5%EB\">プロトコル</a>が使えないとか、ポートが空いてないとか、変なプロキシがいるとか。</p><p>そんなときにいったんグローバルにいるTURNサーバーを中継することで、厳密な<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/P2P\">P2P</a>ではなくなるけど、接続成功率が上がったり、通信経路を固定化できたり、場合によっては通信の品質も安定したりする・・スルメ系なやつ。</p><p>まあそんな話はさておき、これをJSの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>からどう指定して、どう扱うか。</p>\n\n</div>\n<div class=\"section\">\n    <h4>RTCIceServer</h4>\n    <p>`RTCIceServer`というオブジェクトでもって、`RTCConfiguration`ってオブジェクトに指定する。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> iceServers = <span class=\"synIdentifier\">[</span>\n  <span class=\"synComment\">// STUNサーバーを使う場合も</span>\n  <span class=\"synIdentifier\">{</span> urls: <span class=\"synConstant\">&quot;stun:stun1.example.net&quot;</span> <span class=\"synIdentifier\">}</span>,\n  <span class=\"synComment\">// TURNサーバーを使う場合も</span>\n  <span class=\"synIdentifier\">{</span>\n    urls: <span class=\"synConstant\">&quot;turns:turn3.example.net&quot;</span>,\n    username: <span class=\"synConstant\">&quot;12334939:fred&quot;</span>,\n    credential: <span class=\"synConstant\">&quot;adfsaflsjflds&quot;</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">]</span>;\n\n<span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> iceServers <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// ...</span>\n</pre><p>という具合に、複数のサーバーが指定できる。</p><p>TURNには、なんらかの方法で払い出した`username/credential`が必要。<br />\nだってこれがないとタダ乗りされちゃうから・・・。</p><p>ちなみにこうすればTURNを必ず経由するかというと、そうではない。<br />\n今のままでは接続経路の候補に入るだけで、絶対に使われる保証はない。（他の経路でつながるなら、そもそもTURNは不要なので、そういう意味では妥当）</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span>\n  iceServers,\n  iceTransportPolicy: <span class=\"synConstant\">&quot;relay&quot;</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>こうすると、TURN経由の経路だけが接続候補になる。</p><p>まず最初に1発つなげるという意味では、これだけでOK。</p>\n\n</div>\n<div class=\"section\">\n    <h4>TURN as a Service</h4>\n    <p>WebRTCでWebのサービスやってると、やっぱりTURNのcredentialもRESTで提供したくない？したいよね？ってなる。<br />\nそれこそ、TURN as a Serviceとか。</p><p>ただTURNのサーバーはWebサーバーとは別にしたいし、認証はしたいけど、なんか疎に連携するいい方法はないじゃろか？ってなる。</p><p>そして生まれたのがこのドラフト。</p>\n\n    <blockquote>\n        <p><a href=\"https://tools.ietf.org/html/draft-uberti-rtcweb-turn-rest-00\">draft-uberti-rtcweb-turn-rest-00 - A REST API For Access To TURN Services</a></p>\n\n    </blockquote>\n<p>RESTサーバーとTURNサーバーで共有のシークレットキーを持っておいて、それを使って得たハッシュを使って認証する作戦。<br />\nユーザー名にはタイムスタンプを入れることで、期限付きのものにする。</p><p>さっきのコードと足してそれっぽく書くと・・。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> urls, username, credential, ttl <span class=\"synIdentifier\">}</span> = await turnService.getCredential(<span class=\"synIdentifier\">{</span> username: <span class=\"synConstant\">&quot;bob&quot;</span> <span class=\"synIdentifier\">}</span>);\nconsole.log(`TURN credential will be expired <span class=\"synStatement\">in</span> $<span class=\"synIdentifier\">{</span>ttl<span class=\"synIdentifier\">}</span>`);\n\n<span class=\"synStatement\">const</span> config = <span class=\"synIdentifier\">{</span>\n  iceServers: <span class=\"synIdentifier\">[</span>\n    <span class=\"synIdentifier\">{</span> urls, username, credential <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">]</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synStatement\">const</span> pc = <span class=\"synStatement\">new</span> RTCPeerConnection(<span class=\"synIdentifier\">{</span> iceServers <span class=\"synIdentifier\">}</span>);\n</pre><p>という感じ。</p><p>RESTにすれば、最寄りのTURNのURLを返すこともできるし、TURNサーバー自体のアップデートとかにも耐えられて良いですね。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ICEリスタート</h4>\n    <p>通信経路を決めるICEには、再起動をかける手順があって、それを俗にICEリスタートっていう。</p><p>なんかネットワーク（もとい、今使われてる経路）の調子が悪いとか、モバイルから<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/WiFi\">WiFi</a>になったのでつなぎなおしたいとか、そういうときに使う。</p><p>ただTURNの場合はここで1つ問題が。<br />\nさっきのユーザー名にタイムスタンプが入ってるので、同じクレデンシャルを使い回すと期限切れでおこられが発生する。</p><p>そしてTURNにはcredentialを延長するみたいな決まった手順があるわけではなくて、新しくcredentialを発行してねって感じになってる。もちろん任意にできる認証部分をそういうふうに作ればできるけど、疎に作りたい欲が勝つはず。</p><p>なので最終的にはこんな感じにする必要がある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// 再発行（というか単なる新規発行</span>\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> urls, username, credential <span class=\"synIdentifier\">}</span> = await turnService.getCredential(<span class=\"synIdentifier\">{</span> username: <span class=\"synConstant\">&quot;bob&quot;</span> <span class=\"synIdentifier\">}</span>);\n<span class=\"synComment\">// 設定のアップデート</span>\nwebRtcSdk.updateIceServers(<span class=\"synIdentifier\">[{</span> urls, username, credential <span class=\"synIdentifier\">}]</span>);\n<span class=\"synComment\">// ICEリスタート</span>\nawait webRtcSdk.restartIce();\n</pre><p>あるべき<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SDK\">SDK</a>の実装例でいうとこう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">class</span> WebRtcSdk <span class=\"synIdentifier\">{</span>\n  updateIceServers(iceServers) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">const</span> config = <span class=\"synIdentifier\">this</span>._pc.getConfiguration();\n    config.iceServers = iceServers;\n    <span class=\"synIdentifier\">this</span>._pc.setConfiguration(config);\n  <span class=\"synIdentifier\">}</span>\n\n  restartIce() <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">const</span> offer = await <span class=\"synIdentifier\">this</span>._pc.createOffer(<span class=\"synIdentifier\">{</span> iceRestart: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n    <span class=\"synComment\">// O/Aネゴシエーション</span>\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n</pre>\n</div>\n<div class=\"section\">\n    <h4>おまけ: 1</h4>\n    \n    <blockquote>\n        <p><a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1253706\">1253706 - Implement RTCPeerConnection.setConfiguration</a></p>\n\n    </blockquote>\n<p>残念なお知らせ。</p><p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a>には`setConfiguration()`が実装されてないため、TURN経由の場合にシームレスにICEリスタートができません！どうしようもない！</p><p>現時点では<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Firefox\">Firefox</a> 71でも未実装だった。</p>\n\n</div>\n<div class=\"section\">\n    <h4>おまけ: 2</h4>\n    \n    <blockquote>\n        <p><a href=\"https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-restartice\">https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-restartice</a></p>\n\n    </blockquote>\n<p>`createOffer({ iceRestart: true })`ではなく、ズバリ`restartIce()`って<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>が実装中。</p><p>現時点では、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a> 77以降でのみ使えます。</p>\n\n</div>"
}
