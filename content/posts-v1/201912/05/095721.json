{
  "title": "WebRTCのPerfect negotiationについて",
  "html": "<p>なんやそれ・・また新しいプロトコルか？って思いますよね。<br />\n安心してください！ただの造語です。</p>\n\n    <blockquote>\n        <p><a href=\"https://blog.mozilla.org/webrtc/perfect-negotiation-in-webrtc/\">Perfect negotiation in WebRTC - Advancing WebRTC</a></p>\n\n    </blockquote>\n<p>出自はこの記事で、書かれたのは4月とかなり前。<br />\nただちょいちょい更新されてる + `webrtc-pc`のIssueでも度々引用されてくる + 最近それが顕著だったので、今さら解説してみた。</p><p>この記事の概要と、思うところについて書きます。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>Perfect negotiationの概要</h3>\n    \n<div class=\"section\">\n    <h4>まえがき</h4>\n    \n<ul>\n<li>WebRTCのネゴシエーションは思った以上に複雑\n<ul>\n<li>SDPやICE candidateの交換</li>\n<li>ステートフルな`signalingState`</li>\n<li>TrickleICEのタイミング問題</li>\n<li>etc...</li>\n</ul></li>\n<li>ただしなんとかする方法もある\n<ul>\n<li>何も気にせず各エンドポイントが`addTrack()`すればいいだけにできる</li>\n</ul></li>\n<li>そのためには2つのピースが必要\n<ul>\n<li>`negotiationneeded`イベント</li>\n<li>SDPのtype: `rollback`</li>\n</ul></li>\n</ul><p>しかし現状ではFirefoxでしか実装されておらず、実現できない・・。</p>\n\n</div>\n<div class=\"section\">\n    <h4>negotiationneededを使おう</h4>\n    <p>ブラウザがネゴシエーションが必要だと思われるAPIコールに応じて、自動的に発火してくれるイベント。<br />\nICEのcandidateが見つかったときに、`icecandidate`イベントが発火するのと同じ。</p><p>送信側のコードのイメージ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.onnegotiationneeded = async () =&gt; <span class=\"synIdentifier\">{</span>\n  await pc.setLocalDescription(await pc.createOffer());\n  io.send(<span class=\"synIdentifier\">{</span> description: pc.localDescription <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>受信側はこう。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// candidateとSDPが飛んでくる</span>\nio.onmessage = async (<span class=\"synIdentifier\">{</span> data: <span class=\"synIdentifier\">{</span> description, candidate <span class=\"synIdentifier\">}}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// SDP</span>\n  <span class=\"synStatement\">if</span> (description) <span class=\"synIdentifier\">{</span>\n    await pc.setRemoteDescription(description);\n    <span class=\"synComment\">// オファーの場合は、アンサーを送り返す必要がある</span>\n    <span class=\"synStatement\">if</span> (description.type == <span class=\"synConstant\">&quot;offer&quot;</span>) <span class=\"synIdentifier\">{</span>\n      await pc.setLocalDescription(await pc.createAnswer());\n      io.send(<span class=\"synIdentifier\">{</span> description: pc.localDescription <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// candidate</span>\n  <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (candidate) await pc.addIceCandidate(candidate);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>これだけ仕込んでおけば、後は任意のタイミングで`addTrack()`するだけで、自動的にネゴシエーションが行われる。</p><p>基本的にはこれだけでPerfectなんだが、いわゆるグレア（両側で同時に操作した場合）の問題が残る。</p><p>（ちなみに、Chromeでこのイベントがまともに発火するようになったのは割と最近・・）</p>\n\n</div>\n<div class=\"section\">\n    <h4>そこでrollback</h4>\n    <p>そもそもグレアは、アプリケーションレイヤーで解消できるものでもある。<br />\nただし、WebRTCのレイヤーでも`rollback`を使えばなんとかできる。</p><p>端的にいうと、グレアに陥ったときに「お先にどうぞ」する紳士的な実装にすればよい。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// さっきのハンドラーをアップデート</span>\nio.onmessage = async (<span class=\"synIdentifier\">{</span> data: <span class=\"synIdentifier\">{</span> description, candidate <span class=\"synIdentifier\">}}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// SDP</span>\n  <span class=\"synStatement\">if</span> (description) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// オファーを受け取ったが、自分もオファーを出している状態だった</span>\n    <span class=\"synStatement\">if</span> (description.type == <span class=\"synConstant\">&quot;offer&quot;</span> &amp;&amp; pc.signalingState != <span class=\"synConstant\">&quot;stable&quot;</span>) <span class=\"synIdentifier\">{</span>\n      <span class=\"synComment\">// 礼儀正しいピアと、そうでないピアのP2Pになるようにしておく</span>\n      <span class=\"synStatement\">if</span> (!polite) <span class=\"synStatement\">return</span>;\n      <span class=\"synComment\">// 礼儀正しいならばロールバックして相手のオファーを優先</span>\n      await Promise.all(<span class=\"synIdentifier\">[</span>\n        pc.setLocalDescription(<span class=\"synIdentifier\">{</span> type: <span class=\"synConstant\">&quot;rollback&quot;</span> <span class=\"synIdentifier\">}</span>),\n        pc.setRemoteDescription(description)\n      <span class=\"synIdentifier\">]</span>);\n    <span class=\"synIdentifier\">}</span>\n    <span class=\"synComment\">// アンサーを受け取っただけ or 自分は何もしてないときにオファーを受けた</span>\n    <span class=\"synStatement\">else</span> <span class=\"synIdentifier\">{</span>\n      await pc.setRemoteDescription(description);\n    <span class=\"synIdentifier\">}</span>\n\n    <span class=\"synComment\">// それがオファーならアンサーを送り返す</span>\n    <span class=\"synStatement\">if</span> (description.type == <span class=\"synConstant\">&quot;offer&quot;</span>) <span class=\"synIdentifier\">{</span>\n      await pc.setLocalDescription(await pc.createAnswer());\n      io.send(<span class=\"synIdentifier\">{</span> description: pc.localDescription <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// candidateはそのまま</span>\n  <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (candidate) await pc.addIceCandidate(candidate);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>`polite`というフラグ変数だけ事前に用意して決めておく必要がある。</p><p>`rollback`のところで`Promise.all()`してる理由は、その隙間にICE candidateが飛んてくる可能性があるから。<br />\nちゃんと`await`すれば、このPromiseが解消されたあとで`addIceCandidate()`が解消される。</p><p>これでまた一歩Perfectに近づいたけど、あと一歩足りない。</p><p>同じような処理を、`negotiationneeded`時にも考慮する必要がある。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.onnegotiationneeded = async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> offer = await pc.createOffer();\n  <span class=\"synComment\">// 相手のオファーを処理中</span>\n  <span class=\"synStatement\">if</span> (pc.signalingState != <span class=\"synConstant\">&quot;stable&quot;</span>) <span class=\"synStatement\">return</span>;\n  await pc.setLocalDescription(offer);\n  io.send(<span class=\"synIdentifier\">{</span> description: pc.localDescription <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>`return`しちゃったら呼ばれないまま消えちゃうのでは？と思うけど、`signalingState`が`stable`にもどったら、再度`negotiationneeded`が発火するので問題ない。</p>\n\n</div>\n<div class=\"section\">\n    <h4>つらくない？</h4>\n    \n<ul>\n<li>その気持ちはわかる</li>\n<li>なので`Promise.all()`や`stable`かどうかの確認をスキップできるような仕様も提案してる\n<ul>\n<li><a href=\"https://github.com/w3c/webrtc-pc/issues/2165\">https://github.com/w3c/webrtc-pc/issues/2165</a></li>\n<li><a href=\"https://github.com/w3c/webrtc-pc/issues/2166\">https://github.com/w3c/webrtc-pc/issues/2166</a></li>\n<li><a href=\"https://github.com/w3c/webrtc-pc/issues/2167\">https://github.com/w3c/webrtc-pc/issues/2167</a></li>\n</ul></li>\n<li>ただ1回書いてしまえば、この実装は隠蔽できる\n<ul>\n<li>そしてアプリケーション要件に振り回されないところなはず</li>\n</ul></li>\n<li>WebRTCのAPIが内部的にそうやってくれればいいのでは？はごもっとも\n<ul>\n<li>ただハイレベルなAPIとローレベルなAPIへの需要はどちらもある</li>\n<li>APIデザインとして決めきれなかったのは事実</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h5>Issue: 2165</h5>\n    <p>`setLocalDescription()`を引数なしでできるように。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.onnegotiationneeded = async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// これが非同期なので</span>\n  <span class=\"synStatement\">const</span> offer = await pc.createOffer();\n  <span class=\"synComment\">// ここで相手からオファーが届いてしまう可能性がある</span>\n\n  <span class=\"synComment\">// そうなるとコレが困る</span>\n  await pc.setLocalDescription(offer);\n  io.send(<span class=\"synIdentifier\">{</span> desc: pc.localDescription <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>なので、`signalingState`が`stable`かどうかのチェックをしようって話だった。</p><p>でもそんなことするくらいならもうこうしたいって話。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>pc.onnegotiationneeded = async () =&gt; <span class=\"synIdentifier\">{</span>\n  io.send(<span class=\"synIdentifier\">{</span> desc: await pc.setLocalDescription() <span class=\"synIdentifier\">}</span>);\n<span class=\"synIdentifier\">}</span>;\n</pre><p>これは、</p>\n\n<ul>\n<li>自分の`signalingState`によって、これがアンサーかオファーかは判断する</li>\n<li>まだO/Aしてないなら、`createOffer()`か`createAnswer()`する</li>\n<li>それを返す</li>\n</ul><p>というように動く。</p><p>というか実は、</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>await pc.createOffer();\nawait pc.setLocalDescription(<span class=\"synIdentifier\">{</span> type: <span class=\"synConstant\">&quot;offer&quot;</span> <span class=\"synIdentifier\">}</span>);\n</pre><p>これが動作する・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h5>Issue: 2166</h5>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>await Promise.all(<span class=\"synIdentifier\">[</span>\n  pc.setLocalDescription(<span class=\"synIdentifier\">{</span>type: <span class=\"synConstant\">&quot;rollback&quot;</span><span class=\"synIdentifier\">}</span>),\n  pc.setRemoteDescription(description)\n<span class=\"synIdentifier\">]</span>);\n</pre><p>これをなんとかしたいという話。</p><p>`setRemoteDescription(desc)`が、暗黙的に`rollback`的な効力を持つようになる。</p>\n\n</div>\n<div class=\"section\">\n    <h5>Issue: 2167</h5>\n    <p>現状だとICEリスタートは、`createOffer({ iceRestart: true })`ではじめるしかない。</p><p>しかしそれだと、`negotiationneeded`が動かない！</p><p>なので、`pc.restartIce()`で動くようにしたいという話。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h4>なぜこれらが必要か</h4>\n    \n<ul>\n<li>ネゴシエーションの必要性を決めるアルゴリズムは、思ってる以上に複雑である</li>\n<li>たとえばアンサー側の`addTrack()`は`signalingState`によって挙動が変わる\n<ul>\n<li>`stable`に戻ったとき、利用可能な`Transceiver`の数に応じて変わる</li>\n<li>改めてネゴシエーションが必要な場合と不要な場合がある</li>\n</ul></li>\n<li>手動でそういうのも管理できる？</li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>というわけで</h3>\n    <p>叩くべきAPIは決まってるけど、ネゴシエーションの落とし穴は思ってるより多いよという話と、こうすればPerfectですっていう提案。</p><p>まぁアプリケーションレイヤーでコントロールすることもできるのはできるけど、そこまでやる？っていうトレードオフはあるはずで・・。</p><p>ここにあるコードを使えば、そういうしがらみからは逃れられるけど、Firefoxでしか使えないので実用的ではないんよね。<br />\n気になるChromeの実装状況はこちらから。</p>\n\n    <blockquote>\n        <p><a href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=980872\">980872 - chromium - An open-source project to help move the web forward. - Monorail</a></p>\n\n    </blockquote>\n<p>まぁWebRTCやってる人の中でも、SDK作りに心血を注いでる人くらいしか気にしてないトピックやと思うけど・・。</p><p>個人的には、いまさら感 + Firefoxでしか動かんので、送信用と受信用で2コネクション張るほうが考えることなくなって楽では？という気持ち。</p>\n\n</div>"
}
