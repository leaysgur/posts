{
  "title": "バンドラを使わずにRustをWASMにする",
  "html": "<p>調べると初手`wasm-pack`があまりに多くて、諸事情により`webpack`いらないんですけど・・ってなシーンでどうすればいいかわからんかった。</p><p>それを2019年末にあれこれ<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C8%A5%E9%A5%A4%A5%A2%A5%F3%A5%C9%A5%A8%A5%E9%A1%BC\">トライアンドエラー</a>してみた結果のメモです。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>最小構成で試す</h3>\n    <p>とりあえずやってみる。</p>\n\n<div class=\"section\">\n    <h4>Rustを書く</h4>\n    <p>まずモジュールを作る。</p><p>`cargo new --lib wasm`的な感じでプロジェクトを作って書いてく。</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synPreProc\">#[no_mangle]</span>\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">add</span>(a: <span class=\"synType\">i32</span>, b: <span class=\"synType\">i32</span>) <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">i32</span> {\n    a <span class=\"synStatement\">+</span> b\n}\n</pre><p>あわせて`Cargo.toml`にこれを書き足す。</p>\n<pre class=\"code toml\" data-lang=\"toml\" data-unlink>[lib]\ncrate-type = [&#34;cdylib&#34;]</pre><p>これをビルドする。<br />\n`cargo build --target wasm32-unknown-unknown --release`とかで。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ホストする</h4>\n    <p>適当にサーバーを立てればいい。</p><p>`.wasm`は、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/MIME\">MIME</a>-TYPEを`application/wasm`として返す必要があるので注意。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Python\">Python</a>の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EF%A5%F3%A5%E9%A5%A4%A5%CA%A1%BC\">ワンライナー</a>みたいなのだとダメだった。</p>\n\n</div>\n<div class=\"section\">\n    <h4>ブラウザで実行する</h4>\n    <p>こんなJSで読める。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> path = <span class=\"synConstant\">&quot;./wasm/target/wasm32-unknown-unknown/release/wasm.wasm&quot;</span>;\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span>\n    instance: <span class=\"synIdentifier\">{</span>\n      exports: <span class=\"synIdentifier\">{</span> add <span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span> = await WebAssembly.instantiateStreaming(fetch(path), <span class=\"synIdentifier\">{}</span>);\n\n  console.log(add(10, 7));\n<span class=\"synIdentifier\">}</span>)();\n</pre><p>`instantiateStreaming()`は<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Safari\">Safari</a>ではまだ使えない。<br />\nその場合は`fetch()`を`ArrayBuffer`でやって、`instantiate()`に渡すひと手間が必要。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>wasm-bindgenを使う</h3>\n    <p>とりあえず動くものの、これだとRust側で`i32`, `i64`, `f32`, `f64`しか扱えないので、ほぼ何もできない・・。<br />\n配列も返せないし文字列も返せない！</p><p>実際にRustで`String`を返す関数を作っても、実行すると`undefined`が返ってきちゃう。</p><p>なので、このあたりをいい感じに橋渡ししてくれる存在の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%C7%A5%D5%A5%A1%A5%AF%A5%C8\">デファクト</a>である、`wasm-bindgen`を使う。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/rustwasm/wasm-bindgen/\">GitHub - rustwasm/wasm-bindgen: Facilitating high-level interactions between Wasm modules and JavaScript</a></p>\n\n    </blockquote>\n<p>モジュールをこんな感じで書き直す。</p>\n<pre class=\"code lang-rust\" data-lang=\"rust\" data-unlink><span class=\"synStatement\">extern</span> <span class=\"synStatement\">crate</span> <span class=\"synIdentifier\">wasm_bindgen</span>;\n\n<span class=\"synStatement\">use</span> <span class=\"synPreProc\">wasm_bindgen</span><span class=\"synSpecial\">::</span><span class=\"synPreProc\">prelude</span><span class=\"synSpecial\">::</span><span class=\"synType\">*</span>;\n\n<span class=\"synPreProc\">#[wasm_bindgen]</span>\n<span class=\"synStatement\">pub</span> <span class=\"synStatement\">fn</span> <span class=\"synIdentifier\">greet</span>() <span class=\"synStatement\">-&gt;</span> <span class=\"synType\">String</span> {\n    <span class=\"synConstant\">&quot;from wasm&quot;</span>.<span class=\"synIdentifier\">to_string</span>()\n}\n</pre><p>クレートを読み込んで`prelude`書いて、`no_mangle`の代わりに`wasm_bindgen`ってするだけ。</p><p>ただコレを使うと、↑に書いた最低限コードでは読み込めなくなるので、`wasm-bindgen-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>`を使って変換する必要がある。</p><p>`cargo install wasm-bindgen-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>`すると、`wasm-bindgen`コマンドが使えるようになる。</p><p>`wasm-bindgen`コマンドは、ビルドした`.wasm`に対して実行するイメージ。</p>\n\n<div class=\"section\">\n    <h4>ES Modulesにする</h4>\n    <p>`wasm-bindgen`のドキュメントにやり方は書いてある。</p>\n\n    <blockquote>\n        <p><a href=\"https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html\">Without a Bundler - The `wasm-bindgen` Guide</a></p>\n\n    </blockquote>\n<p><br />\n`wasm-bindgen target/wasm32-unknown-unknown/release/wasm.wasm --out-dir ./pkg --target web`でビルドできる。</p><p>この`--target web`が、ES Modulesにする指定。</p><p>そして読み込む。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// in script[type=module]</span>\n<span class=\"synStatement\">import</span> init, <span class=\"synIdentifier\">{</span> add, greet <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">'./pkg/wasm.js'</span>;\n\n(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// これがいわゆるWASMのロードになり、これをしないと使えない</span>\n  await init();\n\n  <span class=\"synComment\">// あとは自由に</span>\n  console.log(greet());\n<span class=\"synIdentifier\">}</span>)();\n</pre><p>これでよし。</p>\n\n</div>\n<div class=\"section\">\n    <h4>WebWorkerからも使いたい</h4>\n    <p>ES ModulesがWorker内で使えない2019年現在、どうすればいいか。<br />\n<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>のM80から、WebWorkerでだけはES Modulesが使えるようになるらしいけど、それでも<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/Chrome\">Chrome</a>だけ。</p><p>メインスレッドでWASMを読み込んで、それをまるごとWorker側に`postMessage()`する方法もあるけど、なんとなく避けたい・・。</p><p>そこで使えるのが`no-modules`っていうターゲット！</p><p>`wasm-bindgen target/wasm32-unknown-unknown/release/wasm.wasm --out-dir ./pkg --target no-modules`でビルドできる。</p><p>`--target no-modules`が重要。<br />\n`--target web`のときと、成果物の種類は変わらない。</p><p>それをこのように読み込む。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// in WebWorker</span>\nimportScripts(<span class=\"synConstant\">&quot;./pkg/wasm.js&quot;</span>);\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> wasm_bindgen <span class=\"synIdentifier\">}</span> = <span class=\"synStatement\">self</span>;\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> add, greet <span class=\"synIdentifier\">}</span> = wasm_bindgen;\n\n(async () =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// またも先に読み込みが必要</span>\n  await wasm_bindgen(<span class=\"synConstant\">'./pkg/wasm.wasm'</span>);\n\n  <span class=\"synComment\">// あとは自由に</span>\n  greet();\n<span class=\"synIdentifier\">}</span>)();\n</pre><p>仕組みは`web`ターゲットとほとんど一緒で、いったん初期化のステップを踏まないといけない。</p><p>あとは使いやすいようによしなにすればよい。<br />\nちなみにこれは、ES Modulesを使わない場合に、メインスレッド側でWASMを読み込む方法としても使える。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>バンドラを使うべきなのか</h3>\n    <p>Rustで書いたものをモジュールとして使う場合、実際ほとんど`webpack`になると思うし、やっぱり`wasm-pack`にしとけって感じなんやろなという予想・・。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/wasm-tool/wasm-pack-plugin\">GitHub - wasm-tool/wasm-pack-plugin: webpack plugin for Rust</a></p>\n\n    </blockquote>\n<p>ただサクッと試す分には`wasm-bindgen-<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/cli\">cli</a>`で十分やと思った。</p>\n\n</div>"
}
