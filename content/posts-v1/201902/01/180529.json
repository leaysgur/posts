{
  "title": "WebRTC QUICがChromeでOrigin Trialできるように",
  "html": "\n    <blockquote>\n        <p><a href=\"https://developers.google.com/web/updates/2019/01/rtcquictransport-api\">RTCQuicTransport Coming to an Origin Trial Near You (Chrome 73) &nbsp;|&nbsp; Web &nbsp;|&nbsp; Google Developers</a></p>\n\n    </blockquote>\n<p>今回は翻訳ではなく、気になる点の抜粋です。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>TL;DR</h3>\n    \n<ul>\n<li>WebRTCにQUICがくるよ</li>\n<li>まずは`RTCQuicTransport`がChromeに実装されます</li>\n<li>M73からOriginTrialできます</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>WebRTCにQUICがくる</h3>\n    \n<ul>\n<li>まずは`RTCQuicTransport`というクラスから</li>\n<li>ICEは変わらず、`RTCIceTransport`というクラスに</li>\n<li>QUICなので順序も再送も保証！\n<ul>\n<li>ゲームやメディアや様々な用途に使えるよ</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>なんで</h3>\n    \n<ul>\n<li>こういう低レイヤーが充実すると、もっといろんなことができる</li>\n<li>それがWebRTC Next Versionだよ</li>\n</ul>\n<div class=\"section\">\n    <h4>なぜQUIC</h4>\n    \n<ul>\n<li>リアルタイム性のため</li>\n<li>UDPの上に位置する</li>\n<li>`RTCDataChannel`的に見えるかも\n<ul>\n<li>似てるけど違う</li>\n<li>それSCTPじゃなくてQUICでできるよ</li>\n<li>`RTCPeerConnection`とも隔離されてるし</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>どうやって使うの</h3>\n    \n<ul>\n<li>3つの構成要素がカギ\n<ul>\n<li>`RTCIceTransport`</li>\n<li>`RTCQuicTransport`</li>\n<li>`RTCQuicStream`</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>RTCIceTransport</h4>\n    \n<ul>\n<li>ICEです</li>\n<li>`RTCQuicTransport`のコンストラクタに渡される</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>RTCQuicTransport</h4>\n    \n<ul>\n<li>QUICのコネクション\n<ul>\n<li>なので接続状況のstatsとかもとれる</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>RTCQuicStream</h4>\n    \n<ul>\n<li>Read/Write</li>\n<li>1つの`RTCQuicTransport`に複数もてる</li>\n<li>なんかWriteすると`onquicstream`イベントがリモートで発火する</li>\n<li>軽量でコネクションを越えてmultiprexされる</li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>コードのイメージ</h3>\n    \n<div class=\"section\">\n    <h4>コネクションの確立</h4>\n    <p>ただコピペしてもしゃーないので、コメントをいれてみた。</p><p>とあるクライアント。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> iceTransport = <span class=\"synStatement\">new</span> RTCIceTransport();\n<span class=\"synComment\">// ICEは別クラスになってて渡せる</span>\n<span class=\"synStatement\">const</span> quicTransport = <span class=\"synStatement\">new</span> RTCQuicTransport(iceTransport);\n\n<span class=\"synComment\">// いわゆるオファー</span>\n<span class=\"synComment\">// シグナリングを規定しないのは変わらず</span>\nsignalingChannel.send(<span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// SDPの代わり</span>\n  iceParams: iceTransport.getLocalParameters(),\n  quicKey: quicTransport.getKey(),\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// TrickleICEっぽい</span>\niceTransport.onicecandidate = e =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (e.candidate) <span class=\"synIdentifier\">{</span>\n    signalingChannel.send(<span class=\"synIdentifier\">{</span>candidate: e.candidate<span class=\"synIdentifier\">}</span> );\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synComment\">// いわゆるアンサー待ち</span>\nsignalingChannel.onMessage = async (<span class=\"synIdentifier\">{</span>iceParams, candidate<span class=\"synIdentifier\">}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// これがアンサー</span>\n  <span class=\"synStatement\">if</span> (iceParams) <span class=\"synIdentifier\">{</span>\n    iceTransport.start(iceParams);\n    quicTransport.connect();\n  <span class=\"synIdentifier\">}</span>\n  <span class=\"synComment\">// ICE candidateだけ</span>\n  <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (candidate) <span class=\"synIdentifier\">{</span>\n    iceTransport.addRemoteCandidate(candidate);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>;\n</pre><p>とあるサーバー。<br />\nほとんど一緒。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> iceTransport = <span class=\"synStatement\">new</span> RTCIceTransport();\n<span class=\"synStatement\">const</span> quicTransport = <span class=\"synStatement\">new</span> RTCQuicTransport(iceTransport);\n\nsignalingChannel.send(<span class=\"synIdentifier\">{</span>\n  iceParams: iceTransport.getLocalParameters(),\n<span class=\"synIdentifier\">}</span>);\niceTransport.onicecandidate = e =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (e.candidate) <span class=\"synIdentifier\">{</span>\n    signalingChannel.send(<span class=\"synIdentifier\">{</span>candidate: e.candidate<span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>\n\nsignalingChannel.onMessage = async (<span class=\"synIdentifier\">{</span>iceParams, quicKey, candidate<span class=\"synIdentifier\">}</span>) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">if</span> (iceParams &amp;&amp; quicKey) <span class=\"synIdentifier\">{</span>\n    iceTransport.start(iceParams);\n    quicTransport.listen(quicKey);\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">else</span> <span class=\"synStatement\">if</span> (candidate) <span class=\"synIdentifier\">{</span>\n    iceTransport.addRemoteCandidate(candidate);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>;\n</pre><p>実行順序やら細かいところには目をつぶるとして、だいたいこんな感じらしい。</p><p>`RTCPeerConnection`的な層がないとこんな感じよねー。</p>\n\n</div>\n<div class=\"section\">\n    <h4>データを送る</h4>\n    <p>`RTCQuicStream`にあるAPIはこんな感じらしい。</p>\n<pre class=\"code lang-typescript\" data-lang=\"typescript\" data-unlink>RTCQuicStreamReadResult readInto<span class=\"synStatement\">(</span>Uint8Array data<span class=\"synStatement\">);</span>\n<span class=\"synType\">void</span> write<span class=\"synStatement\">(</span>RTCQuicStreamWriteParameters data<span class=\"synStatement\">);</span>\nPromise<span class=\"synStatement\">&lt;</span><span class=\"synType\">void</span><span class=\"synStatement\">&gt;</span> waitForWriteBufferedAmountBelow<span class=\"synStatement\">(</span>unsigned <span class=\"synStatement\">long</span> amount<span class=\"synStatement\">);</span>\nPromise<span class=\"synStatement\">&lt;</span><span class=\"synType\">void</span><span class=\"synStatement\">&gt;</span> waitForReadable<span class=\"synStatement\">(</span>unsigned <span class=\"synStatement\">long</span> amount<span class=\"synStatement\">);</span>\n</pre><p>肝心の`stream`はこのように。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>quicTransport.addEventListener(<span class=\"synConstant\">'quicstream'</span>, stream =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// ...</span>\n<span class=\"synIdentifier\">}</span>);\n</pre><p>受け取った`stream`の使い方はこちらから。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/shampson/RTCQuicTransport-Origin-Trial-Documentation\">GitHub - shampson/RTCQuicTransport-Origin-Trial-Documentation: Documentation and demos for developers using the RTCQuicTransport in Chrome&#39;s origin trial.</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h5>Read</h5>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">let</span> readAllData = <span class=\"synConstant\">false</span>;\n<span class=\"synStatement\">while</span> (!readAllData) <span class=\"synIdentifier\">{</span>\n  await readStream.waitForReadable(readStream.maxReadBufferedAmount / 2);\n  <span class=\"synStatement\">const</span> readBuffer = <span class=\"synStatement\">new</span> Uint8Array(stream.maxReadBufferedAmount);\n  <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> amount, finished <span class=\"synIdentifier\">}</span> = readStream.readInto(readBuffer);\n  <span class=\"synComment\">// Do something with the data.</span>\n<span class=\"synIdentifier\">}</span>\n<span class=\"synComment\">// Close the stream. Writing a finish back to the remote side also will close</span>\n<span class=\"synComment\">// the stream.</span>\nreadStream.reset();\n</pre>\n</div>\n<div class=\"section\">\n    <h5>Write</h5>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">while</span> (haveDataToWrite()) <span class=\"synIdentifier\">{</span>\n  await waitForWriteBufferedAmountBelow(writeStream.maxWriteBufferedAmount / 2);\n  <span class=\"synStatement\">const</span> nextChunkSize =\n      writeStream.maxWriteBufferedAmount - writeStream.writeBufferedAmount;\n  writeStream.write(<span class=\"synIdentifier\">{</span> data: getNextChunk(nextChunkSize) <span class=\"synIdentifier\">}</span>)\n<span class=\"synIdentifier\">}</span>\n<span class=\"synComment\">// All waitForReadable promises are resolved when the finish arrives to the read</span>\n<span class=\"synComment\">// buffer on the remote side. Writing it after we are done here ensures that</span>\n<span class=\"synComment\">// all chunks of data are read out on the remote side.</span>\nwriteStream.write(<span class=\"synIdentifier\">{</span> finish: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n</pre><p>という感じで、どことなくWHATWG Streamを思わせる・・・。</p>\n\n</div>\n<div class=\"section\">\n    <h5>バッファリング</h5>\n    \n<ul>\n<li>いろいろメソッドがあるので手動です</li>\n<li>詳しくはコレをみてね\n<ul>\n<li><a href=\"https://github.com/shampson/RTCQuicTransport-Origin-Trial-Documentation\">GitHub - shampson/RTCQuicTransport-Origin-Trial-Documentation: Documentation and demos for developers using the RTCQuicTransport in Chrome&#39;s origin trial.</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>unordered/unreliable</h5>\n    \n<ul>\n<li>QUICだとデフォルトでできない</li>\n<li>なので意図的にストリームを分けるとかしてやって</li>\n</ul>\n</div>\n</div>\n</div>\n<div class=\"section\">\n    <h3>いつから使えるの</h3>\n    \n<ul>\n<li>ChromeのM73からOriginTrial</li>\n<li>M75まで</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>対象ブラウザ</h3>\n    \n<ul>\n<li>iOSを除くChromeブラウザ\n<ul>\n<li>Win, Mac, Linux, Androidかな？</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    \n<div class=\"section\">\n    <h4>Feedback</h4>\n    \n<ul>\n<li>フィードバックがほしいです</li>\n</ul><p>  - APIの使い勝手とか<br />\n  - パフォーマンスとか</p>\n\n<ul>\n<li>お申込みはこちらから\n<ul>\n<li><a href=\"https://developers.chrome.com/origintrials/#/trials/active\">Origin Trials</a></li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>Spec</h4>\n    \n<ul>\n<li>WHATWG Streamとも足並み揃えるよ</li>\n<li>再送を無効にするのも検討中</li>\n<li>あとはデータグラム\n<ul>\n<li>なにこれ？UDP直で叩けるの・・？</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>セキュリティ</h4>\n    \n<ul>\n<li>QUICのhandshakeで使うキーはJSから見えます</li>\n<li>シグナリングするときは気をつけて\n<ul>\n<li>PSK</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>というわけで</h3>\n    <p>まだ全然一般ユーザーには関係ないけど、WebRTC業界としては大きな動きがありそうという。</p><p>実装される風のAPIたちも、本家のSpecと微妙に違うようにも見えるし、まだまだ変わる可能性に満ち溢れてるけど・・。</p><p>初OriginTrialしてみようかしら。</p>\n\n</div>"
}
