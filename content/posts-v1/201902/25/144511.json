{
  "title": "OSSのWebRTC SFU mediasoup v3のコードを読む（クライアント編）",
  "html": "<p>OSSのSFUである`mediasoup`のコードを読みました。</p><p>サーバーの実装とJS-SDKがあって、JS-SDKの方です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/versatica/mediasoup-client\">GitHub - versatica/mediasoup-client: mediasoup client side JavaScript library</a></p>\n\n    </blockquote>\n<p>現時点でのstableはv2.xなので、今回読んだv3は次期バージョン。</p><p>つまりはAPIがまだ変わるかもしれないんですが、まあ読んだことが無駄にはならんやろーという感じ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>コードの入手</h3>\n    <p>すでに`master`ブランチがv3に向いてるので、そのまま`git clone`すれば落ちてきます。</p><p>サーバー実装の`master`はまだv2.xなので、むしろなぜ・・って感じではある。<br />\n近いうちにv3になるんでしょうね。</p>\n\n</div>\n<div class=\"section\">\n    <h3>コードの雰囲気</h3>\n    <p>読み込む前にいわゆるOverviewを。</p><p>READMEに書いてあるコードをそのまま抜粋。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> Device <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;mediasoup-client&quot;</span>;\n<span class=\"synStatement\">import</span> mySignaling from <span class=\"synConstant\">&quot;./my-signaling&quot;</span>; <span class=\"synComment\">// Our own signaling stuff.</span>\n\n<span class=\"synComment\">// Create a device (use browser auto-detection).</span>\n<span class=\"synStatement\">const</span> device = <span class=\"synStatement\">new</span> Device();\n\n<span class=\"synComment\">// Communicate with our server app to retrieve router RTP capabilities.</span>\n<span class=\"synStatement\">const</span> routerRtpCapabilities = await mySignaling.request(\n  <span class=\"synConstant\">&quot;getRouterCapabilities&quot;</span>\n);\n\n<span class=\"synComment\">// Load the device with the router RTP capabilities.</span>\nawait device.load(<span class=\"synIdentifier\">{</span> routerRtpCapabilities <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// Check whether we can produce video to the router.</span>\n<span class=\"synStatement\">if</span> (!device.canProduce(<span class=\"synConstant\">&quot;video&quot;</span>)) <span class=\"synIdentifier\">{</span>\n  console.warn(<span class=\"synConstant\">&quot;cannot produce video&quot;</span>);\n\n  <span class=\"synComment\">// Abort next steps.</span>\n<span class=\"synIdentifier\">}</span>\n\n<span class=\"synComment\">// Create a transport in the server for sending our media through it.</span>\n<span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span>\n  id,\n  iceParameters,\n  iceCandidates,\n  dtlsParameters\n<span class=\"synIdentifier\">}</span> = await mySignaling.request(<span class=\"synConstant\">&quot;createTransport&quot;</span>);\n\n<span class=\"synComment\">// Create the local representation of our server-side transport.</span>\n<span class=\"synStatement\">const</span> sendTransport = device.createSendTransport(<span class=\"synIdentifier\">{</span>\n  id,\n  iceParameters,\n  iceCandidates,\n  dtlsParameters\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// Set transport &quot;connect&quot; event handler.</span>\nsendTransport.on(<span class=\"synConstant\">&quot;connect&quot;</span>, async (<span class=\"synIdentifier\">{</span> dtlsParameters <span class=\"synIdentifier\">}</span>, callback, errback) =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// Here we must communicate our local parameters to our remote transport.</span>\n  <span class=\"synStatement\">try</span> <span class=\"synIdentifier\">{</span>\n    await mySignaling.request(<span class=\"synConstant\">&quot;transport-connect&quot;</span>, <span class=\"synIdentifier\">{</span>\n      transportId: sendTransport.id,\n      dtlsParameters\n    <span class=\"synIdentifier\">}</span>);\n\n    <span class=\"synComment\">// Done in the server, tell our transport.</span>\n    callback();\n  <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">catch</span> (error) <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// Something was wrong in server side.</span>\n    errback(error);\n  <span class=\"synIdentifier\">}</span>\n<span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// Set transport &quot;produce&quot; event handler.</span>\nsendTransport.on(\n  <span class=\"synConstant\">&quot;produce&quot;</span>,\n  async (<span class=\"synIdentifier\">{</span> kind, rtpParameters, appData <span class=\"synIdentifier\">}</span>, callback, errback) =&gt; <span class=\"synIdentifier\">{</span>\n    <span class=\"synComment\">// Here we must communicate our local parameters to our remote transport.</span>\n    <span class=\"synStatement\">try</span> <span class=\"synIdentifier\">{</span>\n      <span class=\"synStatement\">const</span> <span class=\"synIdentifier\">{</span> id <span class=\"synIdentifier\">}</span> = await mySignaling.request(<span class=\"synConstant\">&quot;produce&quot;</span>, <span class=\"synIdentifier\">{</span>\n        transportId: sendTransport.id,\n        kind,\n        rtpParameters,\n        appData\n      <span class=\"synIdentifier\">}</span>);\n\n      <span class=\"synComment\">// Done in the server, pass the response to our transport.</span>\n      callback(<span class=\"synIdentifier\">{</span> id <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span> <span class=\"synStatement\">catch</span> (error) <span class=\"synIdentifier\">{</span>\n      <span class=\"synComment\">// Something was wrong in server side.</span>\n      errback(error);\n    <span class=\"synIdentifier\">}</span>\n  <span class=\"synIdentifier\">}</span>\n);\n\n<span class=\"synComment\">// Produce our webcam video.</span>\n<span class=\"synStatement\">const</span> stream = await navigator.mediaDevices.getUserMedia(<span class=\"synIdentifier\">{</span> video: <span class=\"synConstant\">true</span> <span class=\"synIdentifier\">}</span>);\n<span class=\"synStatement\">const</span> webcamTrack = stream.getVideoTracks()<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span>;\n<span class=\"synStatement\">const</span> webcamProducer = await sendTransport.produce(<span class=\"synIdentifier\">{</span> track: webcamTrack <span class=\"synIdentifier\">}</span>);\n</pre><p>ざっくり書くと、</p>\n\n<ul>\n<li>`Device`の初期化</li>\n<li>サーバー側で対応してるコーデックやらRTPの要件を確認</li>\n<li>それがこちらの環境でも使えるかチェック</li>\n<li>サーバーから接続に必要な情報をサーバーからもらう（ICE/DTLS）\n<ul>\n<li>サーバー側でOffer作って投げるイメージ</li>\n</ul></li>\n<li>それを使ってトランスポートを作る（ここでは送信専用）</li>\n<li>そこに対してメディアをつなぐ\n<ul>\n<li>トランスポートに対して`MediaStreamTrack`を</li>\n</ul></li>\n<li>そしてローカルの接続情報をサーバーに送る\n<ul>\n<li>SRDしてAnswer作って投げるイメージ</li>\n</ul></li>\n<li>その後は`Producer`を介してやりとり</li>\n</ul><p>なのでこの送信専用のサンプルコードの登場人物として重要なのは、`Device`, `Transport`, `Producer`の3つで、順に依存関係がある。</p><p>`MediaStream`ではなく`MediaStreamTrack`をそのままI/Oに使ってるのもポイント。<br />\nうーん、ORTC・・！</p><p>それを踏まえてコードを読んでいく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ファイル一覧</h3>\n    <pre class=\"code\" data-lang=\"\" data-unlink>.\n├── CommandQueue.js\n├── Consumer.js\n├── Device.js\n├── EnhancedEventEmitter.js\n├── Logger.js\n├── Producer.js\n├── Transport.js\n├── detectDevice.js\n├── errors.js\n├── handlers\n│   ├── Chrome55.js\n│   ├── Chrome67.js\n│   ├── Chrome70.js\n│   ├── Edge11.js\n│   ├── Firefox60.js\n│   ├── ReactNative.js\n│   ├── Safari11.js\n│   ├── Safari12.js\n│   ├── ortc\n│   │   └── edgeUtils.js\n│   └── sdp\n│       ├── RemotePlainRtpSdp.js\n│       ├── RemotePlanBSdp.js\n│       ├── RemoteUnifiedPlanSdp.js\n│       ├── commonUtils.js\n│       ├── plainRtpUtils.js\n│       ├── planBUtils.js\n│       └── unifiedPlanUtils.js\n├── index.js\n├── internals.js\n├── ortc.js\n└── utils.js</pre><p>ディレクトリはフラットで、さっきの依存関係は察せない。<br />\nむしろクロスブラウザ対応っていつの時代も大変よね・・っていう感じが押し出された構造になってる。</p><p>モジュールとしての`main`である`index.js`がエクスポートしてるのは、</p>\n\n<ul>\n<li>`Device`: `Device.js`</li>\n<li>`version`: ただのバージョン番号</li>\n</ul><p>なので、いわゆるエントリーポイントは`Device`クラス。</p><p>v2.x時代は他にも関数があったりしてたと思うので、そこが整理された感。</p>\n\n</div>\n<div class=\"section\">\n    <h3>Device</h3>\n    <p>エンドポイントごとに1つ存在する概念。</p><p>いま使ってるブラウザならブラウザ、Nodeならそのプロセスって感じかな？</p><p>`Device`は唯一の引数として`Handler`を受け取るようになってて、ブラウザから利用する場合はデフォルトのものがUAによって用意される。</p><p>その処理をしてるのが`detectDevice.js`。</p>\n\n<ul>\n<li>ReactNativeの場合は`RTCPeerConnection`がないとダメとか</li>\n<li>Chrome/Firefox/Safariに関してはバージョンごとに違うものを</li>\n<li>非対応な場合は`null`が返って、`Device`のインスタンスが作れずに`throw`される</li>\n</ul>\n<div class=\"section\">\n    <h4>Handler</h4>\n    <p>`/handlers`にあるやつら。</p><p>概要はさっき書いた通りで、細かい差分をざっと見ておく。</p>\n\n<ul>\n<li>各ブラウザごとに別れてるが基本のI/Oは同じ（当然\n<ul>\n<li>たとえばChromeだと`unified-plan`なAPI or NOTなどが差分</li>\n<li>試してないけどEdgeへの対応もあって偉い</li>\n</ul></li>\n<li>Send用のHandlerとRecv用のHandlerの2つがコアで、どちらかを返す\n<ul>\n<li>それぞれに`RTCPeerConnection`のインスタンスがある</li>\n<li>= Senderで1つ、Receiverで1つ別のができる</li>\n<li>`send()/stopSend()/iceRestart()`みたいに役割がある</li>\n</ul></li>\n<li>`MediaStream`ではなく`MediaStreamTrack`をI/Oに使う\n<ul>\n<li>中で自前の`new MediaStream()`はする</li>\n</ul></li>\n<li>SDPはテキストではなくオブジェクトにしたものを使う\n<ul>\n<li>RTPとかメディアに関するものを主に操作</li>\n<li>ローカルとリモートで分けていて、それらを操作する処理が`/handlers/sdp`にある</li>\n</ul></li>\n</ul><p>`SendHandler`か`RecvHandler`かどっちかまたは両方が、`Device`の操作によって行われる。</p>\n\n</div>\n<div class=\"section\">\n    <h4>load()</h4>\n    \n<ul>\n<li>ユーザーが使用したい！と渡してきたRTPの要件</li>\n<li>`getNativeRtpCapabilities()`で取得できる対応している要件\n<ul>\n<li>これは各`Handler`から取れる</li>\n</ul></li>\n<li>`RTCRtpCapabilities`自体は、いわゆるORTCからきた概念</li>\n<li>その要件を元に関数をロードしたりフラグを立てたりする</li>\n</ul><p>`Device`のインスタンスを作ったらまずコレをしろっていうやつ。</p>\n\n</div>\n<div class=\"section\">\n    <h4>canProduce()</h4>\n    <p>`mediasoup`において、メディアを送信することを`produce()`するという。</p><p>なので、さっきのクライアント・サーバー側のRTP要件を照らして、実際に送信可能かどうかをチェックしてる処理。</p>\n\n</div>\n<div class=\"section\">\n    <h4>createSendTransport()</h4>\n    \n<ul>\n<li>メディア送信用の`Transport`を作る処理\n<ul>\n<li>もちろん受信用の`createRecvTransport()`もある</li>\n<li>この2つの違いは、directionが`send`か`recv`かだけ</li>\n</ul></li>\n<li>あらかじめサーバーにICE/DTLSの情報をもらっておいて、それを渡す\n<ul>\n<li>ちなみにサーバーはICE Lite</li>\n</ul></li>\n</ul><p>ここから先が`Transport.js`です。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>Transport</h3>\n    \n<ul>\n<li>`send`/`recv`どちらかの役割になる</li>\n<li>さっきの`Handler`が内部的に使われる</li>\n<li>メディアを送信・受信するようの処理\n<ul>\n<li>`send`の`Transport`なら`produce()`</li>\n<li>`recv`の`Transport`なら`consume()`</li>\n</ul></li>\n<li>ICEの管理\n<ul>\n<li>`restartIce()`</li>\n</ul></li>\n<li>`getStats()`も生えてる</li>\n</ul><p>あとはこの`Transport`に対してイベントハンドラを設定しておくと、後述する処理でフックされてP2Pがつながる。</p>\n\n<div class=\"section\">\n    <h4>イベント</h4>\n    <p>3つのイベントが発火される。</p>\n\n<div class=\"section\">\n    <h5>`connect`</h5>\n    \n<ul>\n<li>`Handler`の`@connect`イベントをつなげる</li>\n<li>`Handler`の`send()`/`recv()`の処理中に呼ばれる\n<ul>\n<li>= `Transport`の`produce()`/`consume()`の処理中に呼ばれる</li>\n</ul></li>\n<li>`createOffer()`/`sLD()`したSDPから、DTLSの情報を抜いたものが飛んでくる</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>`connectionstatechange`</h5>\n    \n<ul>\n<li>`Handler`の`@connectionstatechange`イベントをつなげる</li>\n<li>`RTCPeerConnection`のイベントがそのまま飛んでくる</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h5>`produce`</h5>\n    \n<ul>\n<li>`Transport`の`produce()`の処理中に呼ばれる</li>\n<li>`consume()`のイベントはない</li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h4>produce()</h4>\n    <p>`send`な`Transport`がメディアを送る処理。</p>\n\n<ul>\n<li>なので`MediaStreamTrack`を引数に</li>\n<li>自身の`Handler`を使って`send()`する\n<ul>\n<li>`addTransceiver(sendonly)`</li>\n<li>`createOffer()`/`sLD()`</li>\n<li>リモートのSDP情報は`new Transport()`の時点で知ってるので、即`sRD()`できる</li>\n</ul></li>\n<li>さっきの`produce`イベントの発火</li>\n<li>後述する`Producer`を返す\n<ul>\n<li>イベントハンドラをセットしてから</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>consume()</h4>\n    <p>`recv`な`Transport`がメディアを受け取る処理。</p>\n\n<ul>\n<li>基本的に`produce()`の逆</li>\n<li>自身の`Handler`を使って`receive()`する\n<ul>\n<li>サーバーのSDPはわかってるので即`sRD()`</li>\n<li>`createAnswer()`/`sLD()`</li>\n</ul></li>\n<li>後述する`Consumer`が返る\n<ul>\n<li>イベントハンドラをセットしてから</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>Producer / Consumer</h3>\n    <p>`Producer.js`が送信メディアを管理するクラス。</p>\n\n<ul>\n<li>単一の`MediaStreamTrack`の面倒を見る</li>\n<li>`replaceTrack()`/`close()`</li>\n<li>`pause()`/`resume()`でミュート/解除できる</li>\n<li>`this.track`で取れる`MediaStreamTrack`を、画面には描画する</li>\n</ul><p>`Consumer.js`が受信メディアを管理するクラス。</p>\n\n<ul>\n<li>単一の`MediaStreamTrack`の面倒を見る</li>\n<li>とはいえ受信専用なのでできることは少ない\n<ul>\n<li>`close()`</li>\n</ul></li>\n<li>`pause()`/`resume()`でミュート/解除できる</li>\n<li>`this.track`で取れる`MediaStreamTrack`を、画面には描画する</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    \n<div class=\"section\">\n    <h4>EnhancedEventEmitter</h4>\n    <p>純正の`EventEmitter`ではなく、コレを継承するクラスがほとんど。</p>\n\n<ul>\n<li>`emit()`を`try/catch`したり</li>\n<li>中で`await`できるように、`Promise`を返す`emit()`を作ったり</li>\n</ul><p>このワザ、Electronのアプリ書いてたときに使ってたなー。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    <p>そういえばORTCってこんな感じでしたね・・！</p>\n\n<ul>\n<li>`Device`を1つ作って</li>\n<li>そこから`Transport`をつなげていく</li>\n<li>メディア送信用の`Transport`とその`Producer`</li>\n<li>メディア受信用の`Transport`とその`Consumer`</li>\n<li>`Producer`/`Consumer`は`MediaStreamTrack`が紐づくので、それを画面に出す</li>\n</ul><p>送受信で`RTCPeerConnection`を2つ使うの、コードを分離できるメリットがあるのでなるほどな〜という感じ。</p>\n\n<ul>\n<li>send:video + send:audio = 2pc\n<ul>\n<li>sendTransportで1pc\n<ul>\n<li>sendonly <-> recvonly</li>\n</ul></li>\n<li>recvTransportで1pc\n<ul>\n<li>recvonly <-> sendonly</li>\n<li>部屋に入ると = consumeすると動き出す</li>\n</ul></li>\n</ul></li>\n<li>Transportを用意するときに方向が決まってる\n<ul>\n<li>`send` or `recv`</li>\n<li>`send`で作ったTransportは`produce()`しかできない</li>\n</ul></li>\n<li>send(video+video+audio)の場合\n<ul>\n<li>sendTransportは1つでよい</li>\n</ul></li>\n<li>つまりPCは、送信で1つ、受信で1つ\n<ul>\n<li>最低1つあればいい</li>\n<li>それ以上は分けてもいいが、分ける必要はないかも</li>\n</ul></li>\n</ul><p>APIもコードもシンプルでシュッとしてて、WebRTCのJSのAPIも熟知しながらSDPをハックしていく感じでお見事！参考にさせていただきます！というコードでした。</p><p>サーバー側も踏まえて、SDPと各メディアをどのように紐付けて扱えばいいかは、サーバー編があればそっちで書こうかと。</p>\n\n</div>"
}
