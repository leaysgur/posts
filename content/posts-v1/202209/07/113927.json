{
  "title": "PreactにSignalsがきた",
  "html": "\n    <blockquote>\n        <p><a href=\"https://preactjs.com/guide/v10/signals/\">Signals &ndash; Preact Guide</a></p>\n\n    </blockquote>\n<p>端的にいってしまうと、Solidのソレとほぼ同様の体験でコードが書けるようになる・・・！<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3 id=\"まずはコード\">まずはコード</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// store.js</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> signal <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;@preact/signals&quot;</span>;\n\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> count = signal(0);\n<span class=\"synStatement\">export</span> <span class=\"synStatement\">const</span> add = () =&gt; count.value++;\n\n\n<span class=\"synComment\">// Counter.jsx</span>\n<span class=\"synStatement\">import</span> <span class=\"synIdentifier\">{</span> count, add <span class=\"synIdentifier\">}</span> from <span class=\"synConstant\">&quot;./store.js&quot;</span>;\n\n<span class=\"synStatement\">const</span> Counter = () =&gt; (\n  &lt;div&gt;\n    &lt;p&gt;Count: <span class=\"synIdentifier\">{</span>count.value<span class=\"synIdentifier\">}</span>&lt;/p&gt;\n    &lt;button onClick=<span class=\"synIdentifier\">{</span>add<span class=\"synIdentifier\">}</span>&gt;click me&lt;/button&gt;\n  &lt;/div&gt;\n);\n</pre><p>さすがにこの時代になるといろいろ既視感もあって、すんなり読めるコードかと。</p><p>値は`.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/value\">value</a>`に入ってて、それにアクセスした<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>が、更新時にre-renderされる。</p><p>途中の<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>でバケツリレーされてても、Signal自体はただの参照であるがゆえに、re-renderされない。グローバルに定義すれば、バケツリレーする必要すらない。</p><p>同様のことは今までもMobXなり他のライブラリでもできたけど、だいたいは`observe()`的な関数で<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>をHoCにしたり、必要なものを`selector()`で切り出す必要があって、そこが地味にいろいろ不便だったはず。</p><p>それが今、3rdではなくビルトインで提供されるというところがポイント。もう迷わない！</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"Preactでの最適化\">Preactでの最適化</h3>\n    <p>なんと実は`.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/value\">value</a>`でアクセスする必要すらない。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> count = signal(0);\n\n<span class=\"synComment\">// こう書くと、コンポーネント単位でre-renderされる</span>\n<span class=\"synStatement\">const</span> Counter = () =&gt; &lt;p&gt;<span class=\"synIdentifier\">{</span>count.value<span class=\"synIdentifier\">}</span>&lt;/p&gt;;\n\n<span class=\"synComment\">// こう書けば、TextNodeだけre-renderできる！！</span>\n<span class=\"synStatement\">const</span> Counter = () =&gt; &lt;p&gt;<span class=\"synIdentifier\">{</span>count<span class=\"synIdentifier\">}</span>&lt;/p&gt;;\n</pre><p>これをシームレスに達成できるのすばらしい・・。</p><p>ちなみに、PreactにはそのVDOM<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>フェーズに介入できる機構（Options Hook）がもともとあって、それで拡張してる。<br />\nこの例だと、`children`が`Signal`だったらば、そこを`Text`だけアップデートされる<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>に置き換えてくれる。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/preactjs/signals/blob/d25e8bac09c94ed3bad7f12fe380becd8bf1a7ad/packages/preact/src/index.ts#L140-L163\">https://github.com/preactjs/signals/blob/d25e8bac09c94ed3bad7f12fe380becd8bf1a7ad/packages/preact/src/index.ts#L140-L163</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"API\"><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a></h3>\n    \n<ul>\n<li>`signal(val)`</li>\n<li>`computed(fn)`</li>\n<li>`effect(fn)`</li>\n<li>`batch(fn)`</li>\n</ul><p>という基本的なものが揃ってて、`untrack()`的な挙動は、`signal.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/value\">value</a>`ではなく`signal.peek()`でアクセスすることで達成可能。</p><p>Preactで<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>ローカルな状態にしたい場合は、`useSignal()`と`useComputed()`っていうのもある。（中身は`useMemo(signal(val))`でしかないけど）</p><p>ちなみに、コアなプリミティブたちはPreactの外でも使えるようになってて、MobXを生で使ってた身としては地味に嬉しいポイント。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/preactjs/signals\">https://github.com/preactjs/signals</a></p>\n\n    </blockquote>\n<p>ってかこの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EA%A5%DD%A5%B8%A5%C8%A5%EA\">リポジトリ</a>にあるのがコードのすべてなのに、行数少なくてびっくりする。毎度のことながら洗練されてるし学びの塊である・・。</p><p>内部的に`Proxy`は使ってなくて、`.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/value\">value</a> = xxx`っていう値の代入でしかアップデートできないので、そこはもしかしたらちょっと不便に感じるかもしれない。</p><p>あとは、Svelteのstoreみたく`subscribe()`だけ公開してReadOnlyにする仕組みとか、MobXの`action()`みたくそれ経由でしかアップデートできないようにしたいとか、そういうのはまあ出てくるんやろうなーとは思った。</p>\n\n</div>\n<div class=\"section\">\n    <h3 id=\"まとめ\">まとめ</h3>\n    \n<ul>\n<li>`useState()`に代わる新しい状態管理の仕組みである`signal()`が、Preactに追加された</li>\n<li>値を更新する（setterを叩く）だけで、必要な箇所だけが自動でre-renderされる\n<ul>\n<li>参照を直で使えば、<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%EC%A5%F3%A5%C0%A5%EA%A5%F3%A5%B0\">レンダリング</a>も最適化できる</li>\n</ul></li>\n</ul><p>同様の書き味がほしいのであれば、SolidやSvelteのそれでもよかったけど、V-DOMがほしいならVueしかない・・っていうところに、Preactっていう選択肢が増えたって感じで、今後にも注目。</p><p>Reactから離れて独自路線に舵を切ったかどうかでいうと、`useErrorBoundary()`みたいなReactに存在しない<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>も前からあったし、SignalsもReactと一緒にも使えるようになってるし、なかなか断ずるのが微妙なところ。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/preactjs/signals#react-integration\">https://github.com/preactjs/signals#react-integration</a></p>\n\n    </blockquote>\n<p>こういうUI<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%D5%A5%EC%A1%BC%A5%E0%A5%EF%A1%BC%A5%AF\">フレームワーク</a>って、やっぱりいろいろ最適化しようとすると、全部入りにならざるを得ないのだなあ。</p>\n\n</div>"
}
