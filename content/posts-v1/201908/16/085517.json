{
  "title": "mediasoupのスケーラビリティについて",
  "html": "<p>実際に調べたわけではなくてその前段。</p><p>公式のドキュメントに記述があるので、そこを抜粋したメモです。</p>\n\n    <blockquote>\n        <p><a href=\"https://mediasoup.org/documentation/v3/scalability/\">mediasoup :: Scalability</a></p>\n\n    </blockquote>\n\n<div class=\"section\">\n    <h3>そもそもmediasoupの仕組み</h3>\n    \n<ul>\n<li>`mediasoup`自体はNodeのモジュール</li>\n<li>`Worker`という概念と`Router`という概念がある</li>\n<li>`Worker`はC++のプロセスで、単一のCPUコアで動作する\n<ul>\n<li>`Worker`はNヶの`Router`を抱える</li>\n</ul></li>\n<li>`Router`はいわゆるRoomのようなもの\n<ul>\n<li>そこに接続したエンドポイントが互いにメディアを送受信する</li>\n</ul></li>\n<li>`mediasoup`はSFUなので、送られてきたメディアをトランスコードしたりはしない</li>\n<li>SFUに対してメディアを送信することを`produce`すると表す\n<ul>\n<li>受信は`consume`すると表す</li>\n<li>それらを行う主体をそれぞれ`Producer`と`Consumer`と表す</li>\n</ul></li>\n</ul>\n</div>\n<div class=\"section\">\n    <h3>ユースケース: 会議アプリ</h3>\n    \n<ul>\n<li>CPUの強さにもよるが、単一のC++プロセス = `Worker`が抱えられる`Consumer`の最大数は500が目安\n<ul>\n<li>`Worker`はNヶの`Router`を抱えるが、そのトータル</li>\n</ul></li>\n<li>たとえば4人が互いにvideo+audioを送り合う場合\n<ul>\n<li>その`Router`に`produce`されるのは、4人 * 2track = 8 producers</li>\n<li>送られてくるのは自分を除く3人分のメディアなので、4人 * (3人 * 2track) = 24 consumers</li>\n</ul></li>\n<li>スケールさせるためには、複数のCPU、複数のホストで`Router`を配分する</li>\n</ul><p>参加者全員がvideo+audioを送り合う場合で、上限目安の500を考えた場合。</p>\n\n<ul>\n<li>N人の部屋: N * (N-1 * 2)</li>\n<li>4人部屋: 24 consumers</li>\n<li>10人部屋: 180 consumers</li>\n<li>16人部屋: 480 consumers</li>\n<li>17人部屋: 544 consumers</li>\n</ul><p>というわけで、参加者が全員audio+videoを送受信する場合、概算では1つの`Worker`で抱えられるのは16人まで。</p><p>そしてそもそも同じ部屋に入るためには同じ`Router`に属する必要があるので、16人会議をやるとなると、その`Worker`ではもうほかの会議は捌けない。</p><p>まあそんな全員がvideo+audioを送受信することはそうそうないと過程して、audioのみならどうか。</p>\n\n<ul>\n<li>N人の部屋: N * (N-1 * 1)</li>\n<li>4人部屋: 12 consumers</li>\n<li>22人部屋: 462 consumers</li>\n<li>23人部屋: 506 consumers</li>\n</ul><p>ふむ。</p><p>改めて書くけど上記すべてはあくまで1コア = 1worker = 1routerでの試算。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ユースケース: 1:Nの配信</h3>\n    \n<ul>\n<li>1 ~ 数人の配信者がvideo+audioを配信する</li>\n<li>先述の上限で概算すると、\n<ul>\n<li>全員がvideo+audioを受信した場合、500 consumers = 250人で頭打ちになる</li>\n</ul></li>\n<li>これ以上をカバーするためのAPIとして、`Router#pipeToRouter()`というAPIがある\n<ul>\n<li>その名の通り、`Router`同士をつなげる</li>\n</ul></li>\n<li>これにより、たとえば4コアのマシンであれば 250 * 4 = 1000人まで配信できる\n<ul>\n<li>APIとしてはホストを超えてつなげることもできるので、4コア * 3台なら3000人まで配信できる</li>\n<li>もちろんリアルタイム</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>RTPの再送に関する注意</h4>\n    \n<ul>\n<li>この場合の構成は以下</li>\n<li>1配信者 -> 1router -> Nrouter -> N視聴者</li>\n<li>視聴者とNrouter間で、パケロスが起きた場合はその区間で再送される</li>\n<li>ただしRTCPのPLI or FIRは、配信者まで届く\n<ul>\n<li>`mediasoup`としては1秒に1つ以上は届かないようになってるけど</li>\n<li>それでも2xから3xの帯域を消費することになる</li>\n</ul></li>\n<li>視聴者が増えれば増えるほどそのリスクは高まる</li>\n<li>これを回避するためには、サーバー側で再エンコードする仕組みが必要\n<ul>\n<li>つまりは配信者と同じバックエンド上で、帯域の制約を無視しつつ配信者にメディアを配るレイヤー</li>\n</ul></li>\n</ul>\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    \n<ul>\n<li>利用者の数が読めないのであれば、制約を設ける必要がありそう</li>\n<li>無限にスケールする実装を設計するのも手だが、ユースケース的にコスパが悪そう</li>\n<li>やろうと思えば数千人単位への配信も可能なはず</li>\n<li>なにはともあれ要実証</li>\n</ul>\n</div>"
}
