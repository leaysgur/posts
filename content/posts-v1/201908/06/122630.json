{
  "title": "mediasoupとGStreamerで録音する",
  "html": "\n    <blockquote>\n        <p><a href=\"https://github.com/leader22/mediasoup-recording\">GitHub - leader22/mediasoup-recording</a></p>\n\n    </blockquote>\n<p>最近こんな参考実装を書いたので、その学びとハマりをメモ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>はじめに</h3>\n    <p>材料の確認から。</p>\n\n<ul>\n<li>`mediasoup`\n<ul>\n<li>サーバー側で使う</li>\n<li>Nodeのモジュールとして使えるWebRTCの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a></li>\n<li>受け取ったメディアからRTPを抜き出す</li>\n</ul></li>\n<li>`gst-launch-1.0`\n<ul>\n<li>録音を担当するのはGStreamer</li>\n<li>RTPを受け取って、ファイルに書き出す</li>\n</ul></li>\n</ul><p>サーバー側はこれだけ。</p><p>あとはクライアントとつなぐ部分を実装するだけ。</p>\n\n<ul>\n<li>RESTの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/API\">API</a>サーバー</li>\n<li>WebRTCまわりは`mediasoup-client`</li>\n</ul><p>シンプル構成でいいですね。</p>\n\n</div>\n<div class=\"section\">\n    <h3>クライアント</h3>\n    <p>`mediasoup-client`を使うだけ。</p><p>コードは割愛するけど、必要な流れを簡略化して書くとこのように。</p>\n\n<ul>\n<li>`Device`の初期化</li>\n<li>`SendTransport`の作成</li>\n<li>その上で録音したい`audio`のトラックを`produce()`</li>\n</ul><p>最低限で必要なのは以上。</p><p>必要であれば自分の確認用に`consume()`したり。</p><p>録音関連はRESTで叩けるようにしてあって、`produce()`したときの`id`を知らせるようにした。</p>\n\n</div>\n<div class=\"section\">\n    <h3>サーバー</h3>\n    <p>RESTのハンドラと`mediasoup`の呼び出しをよしなにする。</p><p>サーバーは`fastify`で書いたけど、前より便利機能が増えてたし最高だった。</p><p>こちらも録音に必要な流れを書くとこのように。</p>\n\n<ul>\n<li>クライアントの`produce()`を待つ\n<ul>\n<li>サーバーで`Producer`が作られる</li>\n</ul></li>\n<li>クライアントの録音開始RESTで、`Producer`の`id`がわかる</li>\n<li>`PlainRtpTransport`を作って`connect()`\n<ul>\n<li>RTPが吐かれるポートがわかる</li>\n<li>GStreamerをそのポートに向けて起動</li>\n</ul></li>\n<li>そこでさっきの`Producer`を`consume()`する</li>\n</ul>\n<div class=\"section\">\n    <h4>PlainRtpTransport</h4>\n    <p>使ってる部分のコード抜粋。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synComment\">// クライアントより</span>\n<span class=\"synStatement\">const</span> producerId = <span class=\"synConstant\">&quot;...&quot;</span>;\n\n<span class=\"synStatement\">const</span> rtpTransport = await router\n  .createPlainRtpTransport(<span class=\"synIdentifier\">{</span> listenIp: serverIp <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synComment\">// RTPを出したいポートを適当に</span>\n<span class=\"synStatement\">const</span> remotePort = pickIpFromRange(recMinPort, recMaxPort);\nawait rtpTransport\n  .connect(<span class=\"synIdentifier\">{</span> ip: serverIp, port: remotePort <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">const</span> rtpConsumer = await rtpTransport\n  .consume(<span class=\"synIdentifier\">{</span>\n    producerId,\n    rtpCapabilities: router.rtpCapabilities\n  <span class=\"synIdentifier\">}</span>);\n\n<span class=\"synStatement\">const</span> ps = spawnGStreamer(\n  rtpTransport.tuple.remotePort,\n  router.rtpCapabilities.codecs<span class=\"synIdentifier\">[</span>0<span class=\"synIdentifier\">]</span>,\n  `$<span class=\"synIdentifier\">{</span>recordDir<span class=\"synIdentifier\">}</span>/$<span class=\"synIdentifier\">{</span>producerId<span class=\"synIdentifier\">}</span>.ogg`\n);\n</pre><p>いま見るとわかりやすいけど、最初は「？」だった。</p>\n\n<ul>\n<li>`createPlainRtpTransport()`\n<ul>\n<li>既に立ってるはずの`mediasoup`というWebRTCエンドポイントに向けて橋を架ける</li>\n</ul></li>\n<li>`connect()`\n<ul>\n<li>その橋を渡ってくるRTPの向き先</li>\n<li>つまり受け取りたいIPとポート</li>\n<li>1サーバーでやってるので`ip`が同じなだけ</li>\n</ul></li>\n</ul><p>ちなみに、RTP/RTCPを分けて吐き出すこともできる。</p>\n\n    <blockquote>\n        <p><a href=\"https://mediasoup.org/documentation/v3/mediasoup/api/#PlainRtpTransport\">mediasoup :: API</a></p>\n\n    </blockquote>\n\n</div>\n<div class=\"section\">\n    <h4>GStreamer</h4>\n    <p>こいつのパイプラインを組むのがいちばん大変だった。</p><p>最終的に落ち着いたのがコレ。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synStatement\">const</span> cmd = <span class=\"synConstant\">&quot;gst-launch-1.0&quot;</span>;\n<span class=\"synStatement\">const</span> opts = <span class=\"synIdentifier\">[</span>\n  `rtpbin name=rtpbin udpsrc port=$<span class=\"synIdentifier\">{</span>port<span class=\"synIdentifier\">}</span> caps=<span class=\"synConstant\">&quot;application/x-rtp,media=audio,clock-rate=${clockRate},encoding-name=OPUS,payload=${pt}&quot;</span>`,\n  <span class=\"synConstant\">&quot;rtpbin.recv_rtp_sink_0 rtpbin.&quot;</span>,\n  <span class=\"synConstant\">&quot;rtpopusdepay&quot;</span>,\n  <span class=\"synConstant\">&quot;opusparse&quot;</span>,\n  <span class=\"synConstant\">&quot;oggmux&quot;</span>,\n  `filesink <span class=\"synStatement\">location</span>=$<span class=\"synIdentifier\">{</span>dest<span class=\"synIdentifier\">}</span>`\n<span class=\"synIdentifier\">]</span>.join(<span class=\"synConstant\">&quot; ! &quot;</span>);\n</pre>\n<ul>\n<li>`rtpbin`というGStreamerの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/%A5%B3%A5%F3%A5%DD%A1%BC%A5%CD%A5%F3%A5%C8\">コンポーネント</a>で受ける</li>\n<li>受けるのは`audio`のRTP\n<ul>\n<li>`caps`には、`mediasoup`の設定をいれる</li>\n</ul></li>\n<li>コーデックはOPUSに限定してる</li>\n<li>なのでそれを`depeay`して`parse`</li>\n<li>最終的には`.<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/ogg\">ogg</a>`にして書き出す</li>\n</ul><p>今回はこれを`child_process`で`exec()`した。</p><p>大事なのはこれの起動ではなく、録音終了時のお作法。</p><p>`gst-launch-1.0`がそういう仕様になってるっぽいけど、`SIGINT`で落とさないといけない。</p><p>これを`SIGTERM`や`SIGKILL`で落とすと、ファイルが壊れて再生できない・・・というので半日潰しました。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>まとめ</h3>\n    <p><a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/OSS\">OSS</a>のWebRTCの<a class=\"keyword\" href=\"http://d.hatena.ne.jp/keyword/SFU\">SFU</a>、もはや`mediasoup`一択なのでは・・？と思う今日この頃。<br />\nGStreamer、ドキュメントは豊富なものの、豊富すぎてまったく読み解けない。</p><p>今回は録音しか試してないけど、録画も同じような感じでできるかな・・？</p>\n\n</div>"
}
