{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.5",
  "html": "<p>Part.1はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2018/11/26/174220\">NodeJS&#x88FD;WebRTC DataChannel&#x3001;NodeRTC&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; Part.1 - console.lealog();</a></p>\n\n    </blockquote>\n<p>この記事では、ついにSCTPのレイヤーへ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>前回までのあらすじ</h3>\n    \n<ul>\n<li>`nodertc/nodertc`を読んでた</li>\n<li>クライアントとSessionを確立する際に、内部的にいくつかサーバーを立ててた\n<ul>\n<li>STUN: 読んだ</li>\n<li>DTLS: 読んだ</li>\n<li>SCTP: 今回はコレ</li>\n</ul></li>\n</ul><p>というわけで、今回はSCTPの部分。<br />\nこれも読んでみたら長くなったので、前後編になってます。</p>\n\n</div>\n<div class=\"section\">\n    <h3>使われ方</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>startSCTP() <span class=\"synIdentifier\">{</span>\n  console.log(<span class=\"synConstant\">'[nodertc][sctp] start'</span>);\n\n  <span class=\"synIdentifier\">this</span>.sctp = sctp.createServer(<span class=\"synIdentifier\">{</span>\n    transport: <span class=\"synIdentifier\">this</span>.dtls,\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.sctp.once(<span class=\"synConstant\">'listening'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'[nodertc][sctp] server started'</span>);\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.sctp.on(<span class=\"synConstant\">'connection'</span>, socket =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'[nodertc][sctp] got a new connection!'</span>);\n\n    socket.on(<span class=\"synConstant\">'stream'</span>, sctpStreamIn =&gt; <span class=\"synIdentifier\">{</span>\n      console.log(<span class=\"synConstant\">'[nodertc][sctp] got stream %s'</span>, sctpStreamIn.stream_id);\n\n      <span class=\"synStatement\">const</span> sctpStreamOut = socket.createStream(sctpStreamIn.stream_id);\n\n      <span class=\"synStatement\">const</span> channel = createChannel(<span class=\"synIdentifier\">{</span>\n        input: sctpStreamIn,\n        output: sctpStreamOut,\n        negotiated: <span class=\"synConstant\">true</span>,\n      <span class=\"synIdentifier\">}</span>);\n\n      channel.once(<span class=\"synConstant\">'open'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n        <span class=\"synIdentifier\">this</span>.emit(<span class=\"synConstant\">'channel'</span>, channel);\n      <span class=\"synIdentifier\">}</span>);\n    <span class=\"synIdentifier\">}</span>);\n\n    socket.on(<span class=\"synConstant\">'error'</span>, err =&gt; <span class=\"synIdentifier\">{</span>\n      console.error(<span class=\"synConstant\">'[nodertc][sctp]'</span>, err);\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.sctp.on(<span class=\"synConstant\">'error'</span>, err =&gt; <span class=\"synIdentifier\">{</span>\n    console.error(<span class=\"synConstant\">'[nodertc][sctp]'</span>, err);\n  <span class=\"synIdentifier\">}</span>);\n\n  <span class=\"synIdentifier\">this</span>.sctp.listen(5000); <span class=\"synComment\">// Port defined in SDP</span>\n<span class=\"synIdentifier\">}</span>\n</pre><p>という感じ。</p>\n\n<ul>\n<li>SCTPの`createServer()`に、DTLSのStreamを渡す</li>\n<li>`on('connection')`で得られる`socket`の`on('stream')`から、DataChannelが作れる</li>\n<li>`listen()`で起動</li>\n</ul><p>サーバーとソケット、それぞれを見ていく必要がありそう。</p>\n\n</div>\n<div class=\"section\">\n    <h3>nodertc/sctp</h3>\n    <p>読んだバージョンは`0.1.0`です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/sctp\">GitHub - nodertc/sctp: [WIP] SCTP network protocol in plain js</a></p>\n\n    </blockquote>\n<p>今回は`node_modules`って名前のディレクトリではないらしい。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>lib\n├── association.js\n├── chunk.js\n├── defs.js\n├── endpoint.js\n├── index.js\n├── packet.js\n├── reassembly.js\n├── serial.js\n├── sockets.js\n└── transport.js</pre><p>さて、さっき見てたコードは`index.js`からエクスポートされてる。</p><p>というわけでまずは`createServer()`からですが、コレは`new Server()`してるだけなので、`Server`を。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: Server</h3>\n    \n<ul>\n<li>extends `EventEmitter`</li>\n<li>`transport`のオプションは、`udpTransport`と名前を変えて保持される</li>\n</ul><p>`constructor()`ではほぼ何もしてない。<br />\n続いて`listen()`を見てみる。</p>\n\n<ul>\n<li>実態は`_listen()`</li>\n<li>`Endpoint.INITIALIZE()`という大仰なやつを呼んでる\n<ul>\n<li>`udpTransport`も渡される</li>\n</ul></li>\n<li>`on('association')`でサーバーが立って、`Socket`が返る\n<ul>\n<li>`emit('connection', socket)`</li>\n</ul></li>\n</ul><p>`Endpoint`ってやつが何者なのかと、`Socket`を追う。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: Endpoint</h3>\n    <p>`INITIALIZE()`と`on('association')`を見る。</p>\n\n<ul>\n<li>`INITIALIZE()`\n<ul>\n<li>`new Endpoint()`してる`static`メソッド</li>\n<li>`transport.register(endpoint)`</li>\n</ul></li>\n</ul><p>`Endpoint`本体はというと、</p>\n\n<ul>\n<li>extends `EventEmitter`</li>\n<li>`constructor()`では特に副作用はない\n<ul>\n<li>`on('icmp')`と`on('packet')`くらい</li>\n</ul></li>\n<li>`this.udpTransport`も、このクラスでは使われてない</li>\n</ul><p>なので`transport.register(endpoint)`の先で何かやってるはず。</p>\n\n</div>\n<div class=\"section\">\n    <h3>transport.register()</h3>\n    <p>この関数だけを返してるファイル。</p>\n\n<ul>\n<li>`WeakMap`に`endpoint.udpTransport`を保持してる</li>\n<li>`endpoint.transport`に`UDPTransport`をセットして、それの`register()`を呼ぶ</li>\n</ul><p>コードを見るに、同じピアから複数回呼ばれることを想定してる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: UDPTransport / Transport</h3>\n    \n<ul>\n<li>extends `Transport`</li>\n<li>`udpTransport`を受け取ったあと、`on('data')`で`receivePacket()`</li>\n</ul><p>この`on('data')`がおそらくきっかけになって動き出す。</p><p>`register()`も`receivePacket()`も、`Transport`クラスに定義されてるやつ。</p>\n\n<ul>\n<li>`Transport`の`constructor()`\n<ul>\n<li>`pool`に`port`ごとに`endpoint`を保持</li>\n</ul></li>\n<li>`register()`\n<ul>\n<li>さっきの`pool`にポートを割り当てるだけ</li>\n<li>`endpoint.localPort`が埋められて返される</li>\n</ul></li>\n<li>`receivePacket()`\n<ul>\n<li>`endpoint.emit('packet')`</li>\n</ul></li>\n</ul><p>さっきの`on('packet')`がココでつながる！</p>\n\n</div>\n<div class=\"section\">\n    <h3>続 class: Endpoint</h3>\n    <p>`on('packet')`で呼ばれるのは、`onPacket()`。</p><p>ただこいつが270行くらいある重い感じの処理・・。</p><p>ようは、</p>\n\n<ul>\n<li>届いたパケットをそのまま流していいかチェックするのが仕事</li>\n<li>ついでにデコードして後で使おうとしてる</li>\n<li>ココで唐突に出てくる`association`という概念\n<ul>\n<li>これがないなら`onInit()`</li>\n<li>あるなら`onCookieEcho()`</li>\n<li>もしくは`sendPacket()`</li>\n</ul></li>\n<li>送られてきたパケット、`Chunk`によって処理が変わるっぽい</li>\n</ul><p>Associationとはなんぞや？というと、SCTPのエンドポイントをペアにして扱う単位みたいなもので、各エンドポイント = ノードは単数かもしれないし複数かもしれない・・みたいなことがRFCに書いてあった。</p><p>`Association`のクラスは、2000行くらいあって読めたもんじゃなかったので割愛。</p><p>ちなみにさっきの`onPacket()`のくだりで、`onCookieEcho()`にたどり着いた場合、最初のほうで待ってた`on('association')`が発火するようになってる。</p><p>`association.acceptRemote()`で内部的な状態を初期化してる。</p><p>これでやっとSCTPのSocketが手に入る・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>ざっくり</h3>\n    <p>ここまできてふと思った。</p><p>RFCを読み込まないまでも、ざっくりした情報を知っておくともっと読みやすかったなーと。</p>\n\n    <blockquote>\n        <p><a href=\"https://www.ibm.com/developerworks/jp/linux/library/l-sctp/\">SCTP&#x306B;&#x3088;&#x308B;&#x30CD;&#x30C3;&#x30C8;&#x30EF;&#x30FC;&#x30AD;&#x30F3;&#x30B0;&#x306E;&#x5411;&#x4E0A;</a></p>\n\n    </blockquote>\n<p>たとえば、</p>\n\n<ul>\n<li>マルチホーミング・ストリーミング\n<ul>\n<li>複数のエンドポイント（IP）との接続を束ねて扱う</li>\n</ul></li>\n<li>4-way handshake\n<ul>\n<li>INIT / INIT-ACK / COOKIE-ECHO / COOKIE-ACK</li>\n</ul></li>\n</ul><p>このあたりを知ってると、コードに出てきた`endpoint`とか`association`とかも理解できたので。</p><p>いやー、RFC読むって大変・・。</p><p>続きは後編へ。</p>\n\n</div>"
}
