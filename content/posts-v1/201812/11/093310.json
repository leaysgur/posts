{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.6",
  "html": "<p>Part.1はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2018/11/26/174220\">NodeJS&#x88FD;WebRTC DataChannel&#x3001;NodeRTC&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; Part.1 - console.lealog();</a></p>\n\n    </blockquote>\n<p>今回もSCTPの実装を読んでいく後編です。</p><p>だいぶ長丁場になってきたけど、そろそろゴールも見えてきたところ。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>前編のおさらい</h3>\n    \n<ul>\n<li>SCTPのコードを追ってた</li>\n<li>エンドポイントの初期化を待って、SCTPのソケットを初期化してた</li>\n</ul><p>具体的には次のコード。</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>endpoint.on(<span class=\"synConstant\">'association'</span>, association =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synComment\">// Todo other params</span>\n  <span class=\"synStatement\">const</span> socket = <span class=\"synStatement\">new</span> Socket(<span class=\"synIdentifier\">{</span>ppid: <span class=\"synIdentifier\">this</span>.ppid<span class=\"synIdentifier\">}</span>)\n  socket.establish(endpoint, association)\n  <span class=\"synIdentifier\">this</span>.emit(<span class=\"synConstant\">'connection'</span>, socket)\n  <span class=\"synIdentifier\">this</span>.<span class=\"synStatement\">debugger</span>.debug(<span class=\"synConstant\">'connect &lt;- %s:%s'</span>, association.remoteAddress, association.remotePort)\n<span class=\"synIdentifier\">}</span>)\n</pre><p>この`Socket`と、`establish()`を見ていく。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: Socket</h3>\n    \n<ul>\n<li>extends `Duplex`</li>\n<li>`constructor()`では特に何もしてない</li>\n<li>`_read()`\n<ul>\n<li>何もしてない</li>\n</ul></li>\n<li>`_write()`\n<ul>\n<li>`this.association.SEND()`</li>\n</ul></li>\n</ul>\n<div class=\"section\">\n    <h4>`establish()`</h4>\n    \n<ul>\n<li>`endpoint`と`association`を引数に取る</li>\n<li>`association`で各イベントを購読してる\n<ul>\n<li>基本的には受けてそのまま`this.emit()`してる</li>\n<li>`on('DATA ARRIVE')`で`this.push()`</li>\n<li>当初の使われ方にあった`socket.on('data')`へ</li>\n</ul></li>\n</ul><p>すごいざっくりではあるけど、これで一通りの流れは追えたはず。（メインの導線のみやけど・・）</p>\n<pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink>association.on(<span class=\"synConstant\">'DATA ARRIVE'</span>, streamId =&gt; <span class=\"synIdentifier\">{</span>\n  <span class=\"synStatement\">const</span> buffer = association.RECEIVE(streamId)\n  <span class=\"synStatement\">if</span> (!buffer) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">return</span>\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synIdentifier\">this</span>.<span class=\"synStatement\">debugger</span>.debug(<span class=\"synConstant\">'&lt; DATA ARRIVE %d bytes on stream %d'</span>, buffer.length, streamId)\n\n  <span class=\"synStatement\">if</span> (<span class=\"synIdentifier\">this</span>.listenerCount(<span class=\"synConstant\">'stream'</span>) &gt; 0) <span class=\"synIdentifier\">{</span>\n    <span class=\"synStatement\">if</span> (!<span class=\"synIdentifier\">this</span>.streamsReadable<span class=\"synIdentifier\">[</span>streamId<span class=\"synIdentifier\">]</span>) <span class=\"synIdentifier\">{</span>\n      <span class=\"synIdentifier\">this</span>.streamsReadable<span class=\"synIdentifier\">[</span>streamId<span class=\"synIdentifier\">]</span> = <span class=\"synStatement\">new</span> SCTPStreamReadable(<span class=\"synIdentifier\">this</span>, streamId)\n      <span class=\"synIdentifier\">this</span>.emit(<span class=\"synConstant\">'stream'</span>, <span class=\"synIdentifier\">this</span>.streamsReadable<span class=\"synIdentifier\">[</span>streamId<span class=\"synIdentifier\">]</span>, streamId)\n    <span class=\"synIdentifier\">}</span>\n    <span class=\"synIdentifier\">this</span>.streamsReadable<span class=\"synIdentifier\">[</span>streamId<span class=\"synIdentifier\">]</span>.push(buffer)\n  <span class=\"synIdentifier\">}</span>\n\n  <span class=\"synIdentifier\">this</span>.bytesRead += buffer.length\n  <span class=\"synIdentifier\">this</span>.push(buffer)\n<span class=\"synIdentifier\">}</span>)\n</pre><p>真ん中あたりがキモで、`on('stream')`されてるなら、それ用のストリームを作って返してる。</p><p>これがSCTPのストリームで、`streamId`がそれぞれに割り振られる。</p><p>`SCTPStreamReadable`があるように`SCTPStreamWritable`もあって、それはどこかで作られるかというと、</p>\n\n<ul>\n<li>`createStream(streamId)`で作られる</li>\n<li>`SCTPStreamWritable`はソケットの参照を持つ</li>\n<li>`_write()`で、`this.socket.association.SEND()`</li>\n</ul><p>このメソッド自体は、より上層で使われるはず。</p><p>次に読むDataChannelのEstablishment Protocolのあたりで。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>その他</h3>\n    <p>このSCTPのモジュールに含まれてて触れてないファイルもちらっと見ておく。</p>\n\n<div class=\"section\">\n    <h4>chunk.js</h4>\n    \n<ul>\n<li>`endpoint`の`onPacket()`で届いたパケットをさばくための単位</li>\n<li>様々な`chunkType`がある\n<ul>\n<li>`init`, `init_ack`, `abort`, ...etc</li>\n<li>RFCにずらずら書いてあるやつ</li>\n</ul></li>\n<li>`fromBuffer()` / `toBuffer()`</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>defs.js</h4>\n    \n<ul>\n<li>いわゆる定数など</li>\n<li>さっきの`chunkType`ごとに決まってるパラメータなども</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>packet.js</h4>\n    \n<ul>\n<li>さっきの`Chunk`を内包する単位\n<ul>\n<li>個別に持ってるヘッダと`Chunk`をボディにしてまとめてる</li>\n</ul></li>\n<li>`fromBuffer()` / `toBuffer()`</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>serial.js</h4>\n    \n<ul>\n<li>「RFC 1982 Serial Number Arithmetic」とのこと</li>\n<li>一連のやり取りにおける通し番号を管理するための単位っぽい</li>\n</ul>\n</div>\n<div class=\"section\">\n    <h4>reassembly.js</h4>\n    \n<ul>\n<li>extends `EventEmitter`</li>\n<li>`association`が内部的に保持する</li>\n<li>パケットを受け取った際に、それをどう処理するか決めるために参照される存在っぽい\n<ul>\n<li>状態を管理しておく風</li>\n</ul></li>\n<li>前回見た`acceptRemote()`の先で`reassembly.init()`してる</li>\n</ul><p>これはがっつりRFC読まないと読めないコード・・。</p>\n\n</div>\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    \n<ul>\n<li>今までで一番重い\n<ul>\n<li>息切れして記事がこんなに短くなるくらいに重い</li>\n</ul></li>\n<li>RFCを理解してないと、この程度しかわからない\n<ul>\n<li>まぁこれは予想できてたことやし、理解するきっかけになればいいのでよし</li>\n</ul></li>\n<li>この作者これ全部1人で書いてるの・・まじ・・</li>\n</ul><p>とりあえずなんとなくだいたいは読めたのでもうすぐゴールできそう。</p>\n\n</div>"
}
