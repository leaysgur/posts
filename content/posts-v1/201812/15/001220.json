{
  "title": "NodeJS製WebRTC DataChannel、NodeRTCのコードを読む Part.7",
  "html": "<p>Part.1はこちら。</p>\n\n    <blockquote>\n        <p><a href=\"https://lealog.hateblo.jp/entry/2018/11/26/174220\">NodeJS&#x88FD;WebRTC DataChannel&#x3001;NodeRTC&#x306E;&#x30B3;&#x30FC;&#x30C9;&#x3092;&#x8AAD;&#x3080; Part.1 - console.lealog();</a></p>\n\n    </blockquote>\n<p>長かったこのシリーズもこれで最後です。<br />\n<br />\n</p>\n\n<div class=\"section\">\n    <h3>DataChannel</h3>\n    <p>WebRTCのDataChannelは、</p>\n\n<ul>\n<li>UDP</li>\n<li>DTLS</li>\n<li>SCTP</li>\n</ul><p>で構成されてる風ではあるけど実は最後にもう1層、DataChannel自体の層があるイメージになってる。</p><p>NodeRTCのコードを読み始めた段階では実装されてなかったこの最後の1ピースが、最近実装されたのでそこを読んでいく。</p><p>いわゆるEstablishment Protocolの部分。</p>\n\n</div>\n<div class=\"section\">\n    <h3>nodertc/datachannel</h3>\n    <p>読んだバージョンは`1.0.0`です。</p>\n\n    <blockquote>\n        <p><a href=\"https://github.com/nodertc/datachannel\">GitHub - nodertc/datachannel: WebRTC Data Channel Establishment Protocol</a></p>\n\n    </blockquote>\n<p>ディレクトリはこのように。</p>\n<pre class=\"code\" data-lang=\"\" data-unlink>.\n├── channel.js\n├── constants.js\n├── handshake.js\n├── index.js\n└── protocol.js</pre><p>ファイル数少なくて安心した。</p>\n\n</div>\n<div class=\"section\">\n    <h3>使われ方</h3>\n    <pre class=\"code lang-javascript\" data-lang=\"javascript\" data-unlink><span class=\"synIdentifier\">this</span>.sctp.on(<span class=\"synConstant\">'connection'</span>, socket =&gt; <span class=\"synIdentifier\">{</span>\n  console.log(<span class=\"synConstant\">'[nodertc][sctp] got a new connection!'</span>);\n\n  socket.on(<span class=\"synConstant\">'stream'</span>, sctpStreamIn =&gt; <span class=\"synIdentifier\">{</span>\n    console.log(<span class=\"synConstant\">'[nodertc][sctp] got stream %s'</span>, sctpStreamIn.stream_id);\n\n    <span class=\"synStatement\">const</span> sctpStreamOut = socket.createStream(sctpStreamIn.stream_id);\n\n    <span class=\"synStatement\">const</span> channel = createChannel(<span class=\"synIdentifier\">{</span>\n      input: sctpStreamIn,\n      output: sctpStreamOut,\n      negotiated: <span class=\"synConstant\">true</span>,\n    <span class=\"synIdentifier\">}</span>);\n\n    channel.once(<span class=\"synConstant\">'open'</span>, () =&gt; <span class=\"synIdentifier\">{</span>\n      <span class=\"synIdentifier\">this</span>.emit(<span class=\"synConstant\">'channel'</span>, channel);\n    <span class=\"synIdentifier\">}</span>);\n  <span class=\"synIdentifier\">}</span>);\n</pre><p>という感じ。</p>\n\n<ul>\n<li>SCTPのコネクションで`socket`を得る</li>\n<li>その`socket`の`on('stream')`で得たストリームを使ってChannelを作る\n<ul>\n<li>前回みたSCTPの`createStream()`はココで使う</li>\n</ul></li>\n<li>IN/OUTがあって、それぞれがSCTPのストリーム</li>\n<li>`channel`のAPIで、WebRTCのクライアントにつながる実装がされてる\n<ul>\n<li>`write()`すれば送信できる</li>\n<li>`on('data')`で受信できる</li>\n</ul></li>\n</ul><p>`createChannel()`は`index.js`に定義されてるけど、`new Channel()`するだけなのでそっちから。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: Channel</h3>\n    \n<ul>\n<li>extends `Duplex`</li>\n<li>`constructor()`\n<ul>\n<li>`input` / `output`でそれぞれ`Readable` / `Writable`が必須</li>\n<li>オプションはDCの挙動を制御するもの（`reliable`とか）</li>\n<li>実態は`HandshakeMachine`なるクラスが握ってる</li>\n<li>`pipeline(input, handshake)`してる</li>\n<li>`negotiated`のオプションを`true`にすると、先にHandshakeをはじめるために`opening()`を呼ぶ</li>\n</ul></li>\n<li>`_read()`は空っぽ</li>\n<li>`_write()`は`handshake`の状態に応じて、`output.write()`</li>\n</ul><p>今まで散々重い実装を読んできただけあって、すんなり理解できる。</p>\n\n</div>\n<div class=\"section\">\n    <h3>class: HandshakeMachine</h3>\n    <p>`negotiated`は`true`で初期化されるので、きっかけは`opening()`が呼ばれるところから。</p>\n\n<ul>\n<li>`emit('postopen')`</li>\n<li>接続してるピア側に、`DATA_CHANNEL_OPEN`を送ってHandshakeを開始する\n<ul>\n<li>ピア側から返されるであろう`DATA_CHANNEL_ACK`を受け取るはず</li>\n</ul></li>\n<li>ピア側（`input`）からのパケットは、`_transform()`で処理される\n<ul>\n<li>Handshakeが終わってないはずなので、`_handshake()`が呼ばれる</li>\n</ul></li>\n<li>`_handshake()`\n<ul>\n<li>`emit('final')` -> `channel.emit('open')`</li>\n</ul></li>\n</ul><p>これでピア側とDataChannelがつながった。今度こそ。</p>\n\n</div>\n<div class=\"section\">\n    <h3>読んでみて</h3>\n    <p>実装が薄いからか今まで重いのを呼んでたからか、あっさり読めて良かった。</p><p>これくらいの薄さならRFCの全文を読んでもすんなりいけたので、まあそういうのの積み重ねなんかなーと思った。</p><p>そしてやっぱりTypeScriptでやらなかった理由は何なんやろう・・。</p>\n\n</div>\n<div class=\"section\">\n    <h3>シリーズ通して読んでみて</h3>\n    <p>そもそもDataChannelについてでいうと、やはりWebSocketで良いのでは感が拭えないけど、まあいろいろな経緯があっての今だと思うので、それはそれこれはこれで。</p><p>DataChannelでこれだけ大変だったので、MediaChannelとなるともっと大変なんやろなーWebRTC Implementorすげーなーというのが最終的な感想。</p><p>けど同時に、RFCさえ読めればやれんことはなさそうとも思えた。やるかどうかは別として。</p><p>個人的にはNodeJSでサーバー書くのもナシではないと思うので、引き続きリポジトリはwatchしようと思います。</p>\n\n</div>"
}
